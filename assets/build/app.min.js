(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
    fullScreen: false, // @TODO: implement full screen editing
    images: {
        man: './assets/images/cowboy.png',
        map: './assets/images/tilesheet.png'
    },
    map: './assets/images/example.tmx',
    size: [800, 600],
    step: 1
};
},{}],2:[function(require,module,exports){
var gamejs = require('gamejs');

module.exports = (function () {

    function Controls(step) {
        this.step = step;

        this.reset();
    }

    Controls.prototype.update = function (key, state) {

        switch (key) {
            case gamejs.event.K_UP:
            case gamejs.event.K_w:
                this.up = state;

                break;
            case gamejs.event.K_RIGHT:
            case gamejs.event.K_d:
                this.right = state;

                break;
            case gamejs.event.K_DOWN:
            case gamejs.event.K_s:
                this.down = state;

                break;
            case gamejs.event.K_LEFT:
            case gamejs.event.K_a:
                this.left = state;

                break;
            default:
                break;
        }

        return this;
    };

    Controls.prototype.reset = function () {
        this.up = false;
        this.right = false;
        this.down = false;
        this.left = false;
        this.direction = 'down';
        this.move = false;
        this.position = {
            left: 0,
            top: 0
        };

        return this;
    };

    Controls.prototype.calculate = function () {
        this.move = false;
        this.position = {
            left: 0,
            top: 0
        };

        if (this.up && this.right) {
            this.position.top = -this.step/2;
            this.position.left = this.step/2;
            this.direction = 'UpRight';
            this.move = true;
        } else if (this.up && this.left) {
            this.position.top = -this.step/2;
            this.position.left = -this.step/2;
            this.direction = 'UpLeft';
            this.move = true;
        } else if (this.down && this.right) {
            this.position.top = this.step/2;
            this.position.left = this.step/2;
            this.direction = 'DownRight';
            this.move = true;
        } else if (this.down && this.left) {
            this.position.top = this.step/2;
            this.position.left = -this.step/2;
            this.direction = 'DownLeft';
            this.move = true;
        } else if (this.up) {
            this.position.top = -this.step;
            this.direction = 'Up';
            this.move = true;
        } else if (this.right) {
            this.position.left = this.step;
            this.direction = 'Right';
            this.move = true;
        } else if (this.down) {
            this.position.top = this.step;
            this.direction = 'Down';
            this.move = true;
        } else if (this.left) {
            this.position.left = -this.step;
            this.direction = 'Left';
            this.move = true;
        }

        return this;
    };

    return Controls;
})();
},{"gamejs":8}],3:[function(require,module,exports){
var config = require('./config'),
    gamejs = require('gamejs'),
    images = [],
    Controls = require('./controls'),
    Man = require('./objects/man'),
    Map = require('./objects/map');

for (var key in config.images) {
    if (config.images.hasOwnProperty(key)) {
        images.push(config.images[key]);
    }
}
gamejs.preload(images);

gamejs.ready(function () {
    var display = gamejs.display.getSurface(),
        controls = new Controls(config.step),
        cowboy = new Man(gamejs.image.load(config.images.man), config.size),
        map = new Map(config.map, config.size);

    gamejs.display.setMode(config.size);

    gamejs.event.onKeyDown(function (event) {
        controls.update(event.key, true);
    });
    gamejs.event.onKeyUp(function (event) {
        controls.update(event.key, false);
    });

    gamejs.onTick(function (msDuration) {
        var isMapPositionChanged;

        display.clear();
        controls.calculate();
        isMapPositionChanged = map.move(controls)
            .draw(display);
        cowboy.move(controls, isMapPositionChanged, msDuration)
            .draw(display);
    });
});
},{"./config":1,"./controls":2,"./objects/man":5,"./objects/map":7,"gamejs":8}],4:[function(require,module,exports){
module.exports.firstToLowerCase = function (string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
};
},{}],5:[function(require,module,exports){
var gamejs = require('gamejs'),
    states = require('./man/states'),
    string = require('../helpers/string');

module.exports = (function () {

    function Man(image, canvasSize) {
        this.height = 50;
        this.width = 50;
        this.sprite = new gamejs.animate.SpriteSheet(image, {
            height: 120,
            width: 120,
            scaleTo: [
                this.height,
                this.width
            ],
            spacing: 8
        });
        this.states = states;
        this.animation = new gamejs.animate.Animation(this.sprite, 'down', this.states);
        this.canvas = {
            height: canvasSize[1],
            width: canvasSize[0]
        };

        this.reset();
        /**
         * @TODO: implement collision mask
         */
        //this.mask = new gamejs.pixelcollision.Mask(this.image);
    }

    Man.prototype.move = function (controls, isMapPositionChanged, msDuration) {
        var direction;

        if (!controls.direction) {
            direction = 'down';
        } else {
            direction = controls.move ? 'move' + controls.direction : string.firstToLowerCase(controls.direction);
        }
        this.animation.setState(direction);
        this.animation.update(msDuration);

        if (!isMapPositionChanged.top) {
            this.top = Math.max(0, this.top + controls.position.top);
            this.top = Math.min(this.top, this.canvas.height - 3/2*this.height);
        }

        if (!isMapPositionChanged.left) {
            this.left = Math.max(0, this.left + controls.position.left);
            this.left = Math.min(this.left, this.canvas.width - 3/2*this.width);
        }

        return this;
    };

    Man.prototype.draw = function (display) {
        display.blit(this.animation.image, [this.left, this.top]);

        return this;
    };

    Man.prototype.reset = function () {
        this.top = this.canvas.height/2 - this.height/2;
        this.left = this.canvas.width/2 - this.width/2;

        return this;
    };

    return Man;
})();
},{"../helpers/string":4,"./man/states":6,"gamejs":8}],6:[function(require,module,exports){
var RATE = 10;

module.exports = {
    up: {
        frames: [70],
        loop: true,
        rate: RATE
    },
    moveUp: {
        frames: [71, 72, 73, 74, 75, 76, 77, 78],
        loop: true,
        rate: RATE
    },
    right: {
        frames: [42],
        loop: true,
        rate: RATE
    },
    moveRight: {
        frames: [43, 44, 45, 46, 47, 48, 49, 50],
        loop: true,
        rate: RATE
    },
    down: {
        frames: [126],
        loop: true,
        rate: RATE
    },
    moveDown: {
        frames: [127, 128, 129, 130, 131, 132, 133, 134],
        loop: true,
        rate: RATE
    },
    left: {
        frames: [98],
        loop: true,
        rate: RATE
    },
    moveLeft: {
        frames: [99, 100, 101, 102, 103, 104, 105, 106],
        loop: true,
        rate: RATE
    },
    upRight: {
        frames: [56],
        loop: true,
        rate: RATE
    },
    moveUpRight: {
        frames: [57, 58, 59, 60, 61, 62, 63, 64],
        loop: true,
        rate: RATE
    },
    downRight: {
        frames: [28],
        loop: true,
        rate: RATE
    },
    moveDownRight: {
        frames: [29, 30, 31, 32, 33, 34, 35, 36],
        loop: true,
        rate: RATE
    },
    upLeft: {
        frames: [84],
        loop: true,
        rate: RATE
    },
    moveUpLeft: {
        frames: [85, 86, 87, 88, 89, 90, 91, 92],
        loop: true,
        rate: RATE
    },
    downLeft: {
        frames: [112],
        loop: true,
        rate: RATE
    },
    moveDownLeft: {
        frames: [113, 114, 115, 116, 117, 118, 119, 120],
        loop: true,
        rate: RATE
    }
};
},{}],7:[function(require,module,exports){
var gamejs = require('gamejs');

module.exports = (function () {

    function Map(url, canvasSize) {
        this.map = new gamejs.tiledmap.Map(url);
        this.mapView = new gamejs.tiledmap.MapView(this.map);
        this.isMoving = {
            top: true,
            left: true
        };
        this.overHeight = this.mapView.viewRect.height - canvasSize[1];
        this.overWidth = this.mapView.viewRect.width - canvasSize[0];
    }

    Map.prototype.move = function (controls) {
        var top = Math.min(this.mapView.viewRect.top + controls.position.top, this.overHeight),
            left = Math.min(this.mapView.viewRect.left + controls.position.left, this.overWidth);

        this.mapView.viewRect.top = Math.max(0, top);
        this.mapView.viewRect.left = Math.max(0, left);

        return this;
    };

    Map.prototype.draw = function (display) {
        this.mapView.draw(display, [0, 0]);
        this.isMoving = {
            top: true,
            left: true
        };

        if (!this.mapView.viewRect.top || this.mapView.viewRect.top >= this.overHeight) {
            this.isMoving.top = false;
        }
        
        if (!this.mapView.viewRect.left || this.mapView.viewRect.left >= this.overWidth) {
            this.isMoving.left = false;
        }

        return this.isMoving;
    };

    return Map;
})();
},{"gamejs":8}],8:[function(require,module,exports){
var matrix = require('./gamejs/math/matrix');
var objects = require('./gamejs/utils/objects');
var Callback = require('./gamejs/utils/callback').Callback;

/**
 * @fileoverview  `gamejs.ready()` is maybe the most important function as it kickstarts your app:
 *
 *     var gamejs = require('gamejs');
 *     ready(function() {
 *         gamejs.logging.info('I am ready!')
 *     });
 *
 * If you use images or sounds preload all assets with `gamejs.preload(['./files/foo.png'])` before calling `ready()`.
 *
 * Also in this module is the `Rect` class which is generally useful when dealing with Surfaces and simple rectangles (e.g. for collisions).
 */
// preloading stuff
var gamejs = exports;
var RESOURCES = {};
/**
 * @ignore
 */
exports.thread = require('./gamejs/thread');


/**
 * ReadyFn is called once all modules and assets are loaded.
 * @param {Function} callbackFunction the function to be called once gamejs finished loading
 * @name ready
 */
if (gamejs.thread.inWorker === true) {
   exports.ready = function(readyFn) {
      require('./gamejs/thread')._ready();
      gamejs.init();
      readyFn();
   };
} else {
   exports.ready = function(readyFn) {

      var getMixerProgress = null;
      var getImageProgress = null;

      // init time instantly - we need it for preloaders
      gamejs.time.init();

      // 2.
      function _ready() {
         if (!document.body) {
            return window.setTimeout(_ready, 50);
         }
         getImageProgress = gamejs.image.preload(RESOURCES);
         try {
            getMixerProgress = gamejs.audio.preload(RESOURCES);
         } catch (e) {
            gamejs.debug('Error loading audio files ', e);
         }
         window.setTimeout(_readyResources, 50);
      }

      // 3.
      function _readyResources() {
         if (getImageProgress() < 1 || getMixerProgress() < 1) {
            return window.setTimeout(_readyResources, 100);
         }
         gamejs.display.init();
         gamejs.image.init();
         gamejs.audio.init();
         gamejs.event.init();
         gamejs.math.random.init();
         readyFn();
      }

      // 1.
      window.setTimeout(_ready, 13);

      function getLoadProgress() {
         if (getImageProgress) {
            return (0.5 * getImageProgress()) + (0.5 * getMixerProgress());
         }
         return 0.1;
      }

      return getLoadProgress;
   };
}

/**
 * Initialize all gamejs modules. This is automatically called
 * by `gamejs.ready()`.
 * @returns {Object} the properties of this objecte are the moduleIds that failed, they value are the exceptions
 * @ignore
 */
exports.init = function() {
   var errorModules = {};
   ['time', 'display', 'image', 'audio', 'event'].forEach(function(moduleName) {
      try {
         gamejs[moduleName].init();
      } catch (e) {
         errorModules[moduleName] = e.toString();
      }
   });
   return errorModules;
};

var resourceBaseHref = function() {
    return (window.$g && window.$g.resourceBaseHref) || document.location.href;
};

/**
 * Preload resources.
 * @param {Array} resources list of resources paths
 * @name preload
 */
var preload = exports.preload = function(resources) {
   var uri = require('./gamejs/utils/uri');
   var baseHref = resourceBaseHref();
   resources.forEach(function(res) {
      RESOURCES[res] = uri.resolve(baseHref, res);
   }, this);
   return;
};

/**
 * The function passed to `onTick` will continously be called at a
 * frequency determined by the browser (typically between 1 and 60 times per second).
 * @param {Function} callbackFunction the function you want to be called
 * @param {Function} callbackScope optional scope for the function call
 */
exports.onTick = function(fn, scope) {
  /** ignore **/
  exports.time._CALLBACKS.push(new Callback(fn, scope));
};

/**
 * Normalize various ways to specify a Rect into {left, top, width, height} form.
 * @ignore
 *
 */
var normalizeRectArguments = exports.normalizeRectArguments = function () {
   var left = 0;
   var top = 0;
   var width = 0;
   var height = 0;

   if (arguments.length === 2) {
      if (arguments[0] instanceof Array && arguments[1] instanceof Array) {
         left = arguments[0][0];
         top = arguments[0][1];
         width = arguments[1][0];
         height = arguments[1][1];
      } else {
         left = arguments[0];
         top = arguments[1];
      }
   } else if (arguments.length === 1 && arguments[0] instanceof Array) {
      left = arguments[0][0];
      top = arguments[0][1];
      width = arguments[0][2];
      height = arguments[0][3];
   } else if (arguments.length === 1 && arguments[0] instanceof Rect) {
      left = arguments[0].left;
      top = arguments[0].top;
      width = arguments[0].width;
      height = arguments[0].height;
   } else if (arguments.length === 4) {
      left = arguments[0];
      top = arguments[1];
      width = arguments[2];
      height = arguments[3];
   } else {
      throw new Error('not a valid rectangle specification');
   }
   return {left: left || 0, top: top || 0, width: width || 0, height: height || 0};
};


/**
 * Creates a Rect. Rects are used to hold rectangular areas. There are a couple
 * of convinient ways to create Rects with different arguments and defaults.
 *
 * Any function that requires a `gamejs.Rect` argument also accepts any of the
 * constructor value combinations `Rect` accepts.
 *
 * Rects are used a lot. They are good for collision detection, specifying
 * an area on the screen (for blitting) or just to hold an objects position.
 *
 * The Rect object has several virtual attributes which can be used to move and align the Rect:
 *
 *   top, left, bottom, right
 *   topleft, bottomleft, topright, bottomright
 *   center
 *   width, height
 *   w,h
 *
 * All of these attributes can be assigned to.
 * Assigning to width or height changes the dimensions of the rectangle; all other
 * assignments move the rectangle without resizing it. Notice that some attributes
 * are Numbers and others are pairs of Numbers.
 *
 * @example
 * new Rect([left, top]) // width & height default to 0
 * new Rect(left, top) // width & height default to 0
 * new Rect(left, top, width, height)
 * new Rect([left, top], [width, height])
 * new Rect(oldRect) // clone of oldRect is created
 *
 * @property {Number} right
 * @property {Number} bottom
 * @property {Number} center
 * @constructor
 * @param {Array|gamejs.Rect} position Array holding left and top coordinates
 * @param {Array} dimensions Array holding width and height
 */
var Rect = exports.Rect = function() {

   var args = normalizeRectArguments.apply(this, arguments);

   /**
    * Left, X coordinate
    * @type Number
    */
   this.left = args.left;

   /**
    * Top, Y coordinate
    * @type Number
    */
   this.top = args.top;

   /**
    * Width of rectangle
    * @type Number
    */
   this.width = args.width;

   /**
    * Height of rectangle
    * @type Number
    */
   this.height = args.height;

   return this;
};

objects.accessors(Rect.prototype, {
   /**
    * Bottom, Y coordinate
    * @name Rect.prototype.bottom
    * @type Number
    */
   'bottom': {
      get: function() {
         return this.top + this.height;
      },
      set: function(newValue) {
         this.top = newValue - this.height;
         return;
      }
   },
   /**
    * Right, X coordinate
    * @name Rect.prototype.right
    * @type Number
    */
   'right': {
      get: function() {
         return this.left + this.width;
      },
      set: function(newValue) {
         this.left = newValue - this.width;
      }
   },
   /**
    * Center Position. You can assign a rectangle form.
    * @name Rect.prototype.center
    * @type Array
    */
   'center': {
      get: function() {
         return [this.left + (this.width / 2) | 0,
                 this.top + (this.height / 2) | 0
                ];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left - (this.width / 2) | 0;
         this.top = args.top - (this.height / 2) | 0;
         return;
      }
   },
   /**
    * Top-left Position. You can assign a rectangle form.
    * @name Rect.prototype.topleft
    * @type Array
    */
   'topleft': {
      get: function() {
         return [this.left, this.top];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left;
         this.top = args.top;
         return;
      }
   },
   /**
    * Bottom-left Position. You can assign a rectangle form.
    * @name Rect.prototype.bottomleft
    * @type Array
    */
   'bottomleft': {
      get: function() {
         return [this.left, this.bottom];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.left = args.left;
         this.bottom = args.top;
         return;
      }
   },
   /**
    * Top-right Position. You can assign a rectangle form.
    * @name Rect.prototype.topright
    * @type Array
    */
   'topright': {
      get: function() {
         return [this.right, this.top];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.right = args.left;
         this.top = args.top;
         return;
      }
   },
   /**
    * Bottom-right Position. You can assign a rectangle form.
    * @name Rect.prototype.bottomright
    * @type Array
    */
   'bottomright': {
      get: function() {
         return [this.right, this.bottom];
      },
      set: function() {
         var args = normalizeRectArguments.apply(this, arguments);
         this.right = args.left;
         this.bottom = args.top;
         return;
      }
   },
   /**
    * Position x value, alias for `left`.
    * @name Rect.prototype.y
    * @type Array
    */
   'x': {
      get: function() {
         return this.left;
      },
      set: function(newValue) {
         this.left = newValue;
         return;
      }
   },
   /**
    * Position y value, alias for `top`.
    * @name Rect.prototype.y
    * @type Array
    */
   'y': {
      get: function() {
         return this.top;
      },
      set: function(newValue) {
         this.top = newValue;
         return;
      }
   }
});

/**
 * Move returns a new Rect, which is a version of this Rect
 * moved by the given amounts. Accepts any rectangle form.
 * as argument.
 *
 * @param {Number|gamejs.Rect} x amount to move on x axis
 * @param {Number} y amount to move on y axis
 */
Rect.prototype.move = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   return new Rect(this.left + args.left, this.top + args.top, this.width, this.height);
};

/**
 * Move this Rect in place - not returning a new Rect like `move(x, y)` would.
 *
 * `moveIp(x,y)` or `moveIp([x,y])`
 *
 * @param {Number|gamejs.Rect} x amount to move on x axis
 * @param {Number} y amount to move on y axis
 */
Rect.prototype.moveIp = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   this.left += args.left;
   this.top += args.top;
   return;
};

/**
 * Return the area in which this Rect and argument Rect overlap.
 *
 * @param {gamejs.Rect} Rect to clip this one into
 * @returns {gamejs.Rect} new Rect which is completely inside the argument Rect,
 * zero sized Rect if the two rectangles do not overlap
 */
Rect.prototype.clip = function(rect) {
   if(!this.collideRect(rect)) {
      return new Rect(0,0,0,0);
   }

   var x, y, width, height;

   // Left
   if ((this.left >= rect.left) && (this.left < rect.right)) {
      x = this.left;
   } else if ((rect.left >= this.left) && (rect.left < this.right)) {
      x = rect.left;
   }

   // Right
   if ((this.right > rect.left) && (this.right <= rect.right)) {
      width = this.right - x;
   } else if ((rect.right > this.left) && (rect.right <= this.right)) {
      width = rect.right - x;
   }

   // Top
   if ((this.top >= rect.top) && (this.top < rect.bottom)) {
      y = this.top;
   } else if ((rect.top >= this.top) && (rect.top < this.bottom)) {
      y = rect.top;
   }

   // Bottom
   if ((this.bottom > rect.top) && (this.bottom <= rect.bottom)) {
     height = this.bottom - y;
   } else if ((rect.bottom > this.top) && (rect.bottom <= this.bottom)) {
     height = rect.bottom - y;
   }
   return new Rect(x, y, width, height);
};

/**
 * Join two rectangles
 *
 * @param {gamejs.Rect} union with this rectangle
 * @returns {gamejs.Rect} rectangle containing area of both rectangles
 */
Rect.prototype.union = function(rect) {
   var x, y, width, height;

   x = Math.min(this.left, rect.left);
   y = Math.min(this.top, rect.top);
   width = Math.max(this.right, rect.right) - x;
   height = Math.max(this.bottom, rect.bottom) - y;
   return new Rect(x, y, width, height);
};

/**
 * Grow or shrink the rectangle size
 *
 * @param {Number} amount to change in the width
 * @param {Number} amount to change in the height
 * @returns {gamejs.Rect} inflated rectangle centered on the original rectangle's center
 */
Rect.prototype.inflate = function(x, y) {
    var copy = this.clone();

    copy.inflateIp(x, y);

    return copy;
};

/**
 * Grow or shrink this Rect in place - not returning a new Rect like `inflate(x, y)` would.
 *
 * @param {Number} amount to change in the width
 * @param {Number} amount to change in the height
 */
Rect.prototype.inflateIp = function(x, y) {
    // Use Math.floor here to deal with rounding of negative numbers the
    // way this relies on.
    this.left -= Math.floor(x / 2);
    this.top -= Math.floor(y / 2);
    this.width += x;
    this.height += y;
};

/**
 * Check for collision with a point.
 *
 * `collidePoint(x,y)` or `collidePoint([x,y])` or `collidePoint(new Rect(x,y))`
 *
 * @param {Array|gamejs.Rect} point the x and y coordinates of the point to test for collision
 * @returns {Boolean} true if the point collides with this Rect
 */
Rect.prototype.collidePoint = function() {
   var args = normalizeRectArguments.apply(this, arguments);
   return (this.left <= args.left && args.left <= this.right) &&
       (this.top <= args.top && args.top <= this.bottom);
};

/**
 * Check for collision with a Rect.
 * @param {gamejs.Rect} rect the Rect to test check for collision
 * @returns {Boolean} true if the given Rect collides with this Rect
 */
Rect.prototype.collideRect = function(rect) {
   return !(this.left > rect.right || this.right < rect.left ||
      this.top > rect.bottom || this.bottom < rect.top);
};

/**
 * @param {Array} pointA start point of the line
 * @param {Array} pointB end point of the line
 * @returns true if the line intersects with the rectangle
 * @see http://stackoverflow.com/questions/99353/how-to-test-if-a-line-segment-intersects-an-axis-aligned-rectange-in-2d/293052#293052
 *
 */
Rect.prototype.collideLine = function(p1, p2) {
   var x1 = p1[0];
   var y1 = p1[1];
   var x2 = p2[0];
   var y2 = p2[1];

   function linePosition(point) {
      var x = point[0];
      var y = point[1];
      return (y2 - y1) * x + (x1 - x2) * y + (x2 * y1 - x1 * y2);
   }

   var relPoses = [[this.left, this.top],
                   [this.left, this.bottom],
                   [this.right, this.top],
                   [this.right, this.bottom]
                  ].map(linePosition);

   var noNegative = true;
   var noPositive = true;
   var noZero = true;
   relPoses.forEach(function(relPos) {
      if (relPos > 0) {
         noPositive = false;
      } else if (relPos < 0) {
         noNegative = false;
      } else if (relPos === 0) {
         noZero = false;
      }
   }, this);

   if ( (noNegative || noPositive) && noZero) {
      return false;
   }
   return !((x1 > this.right && x2 > this.right) ||
            (x1 < this.left && x2 < this.left) ||
            (y1 < this.top && y2 < this.top) ||
            (y1 > this.bottom && y2 > this.bottom)
            );
};

/**
 * @returns {String} Like "[x, y][w, h]"
 */
Rect.prototype.toString = function() {
   return ["[", this.left, ",", this.top, "]"," [",this.width, ",", this.height, "]"].join("");
};

/**
 * @returns {gamejs.Rect} A new copy of this rect
 */
Rect.prototype.clone = function() {
   return new Rect(this);
};

/**
 * @ignore
 */
exports.animate = require('./gamejs/animate');
/**
 * @ignore
 */
exports.event = require('./gamejs/event');
/**
 * @ignore
 */
exports.font = require('./gamejs/font');
/**
 * @ignore
 */
exports.http = require('./gamejs/http');
/**
 * @ignore
 */
exports.image = require('./gamejs/image');
/**
 * @ignore
 */
exports.audio = require('./gamejs/audio');
/**
 * @ignore
 */
exports.graphics = require('./gamejs/graphics');

/**
 * @ignore
 */
exports.logging = require('./gamejs/logging');

/**
 * @ignore
 */
exports.math = {
   matrix: require('./gamejs/math/matrix'),
   vectors: require('./gamejs/math/vectors'),
   angles: require('./gamejs/math/angles'),
   binaryheap: require('./gamejs/math/binaryheap'),
   random: require('./gamejs/math/random'),
   noise: require('./gamejs/math/noise'),
};

/**
 * @ignore
 */
exports.utils = {
   arrays: require('./gamejs/utils/arrays'),
   objects: require('./gamejs/utils/objects'),
   uri: require('./gamejs/utils/uri'),
   strings: require('./gamejs/utils/strings'),
   xml: require('./gamejs/utils/xml'),
   base64: require('./gamejs/utils/base64')
};
/**
 * @ignore
 */
exports.display = require('./gamejs/display');
/**
 * @ignore
 */
exports.pathfinding = require('./gamejs/pathfinding');


/**
 * @ignore
 */
exports.tiledmap = require('./gamejs/tiledmap');


/**
 * @ignore
 */
exports.time = require('./gamejs/time');

/**
 * @ignore
 */
exports.pixelcollision = require('./gamejs/pixelcollision');
},{"./gamejs/animate":9,"./gamejs/audio":10,"./gamejs/display":11,"./gamejs/event":12,"./gamejs/font":13,"./gamejs/graphics":14,"./gamejs/http":15,"./gamejs/image":16,"./gamejs/logging":17,"./gamejs/math/angles":18,"./gamejs/math/binaryheap":19,"./gamejs/math/matrix":20,"./gamejs/math/noise":21,"./gamejs/math/random":22,"./gamejs/math/vectors":23,"./gamejs/pathfinding":24,"./gamejs/pixelcollision":25,"./gamejs/thread":26,"./gamejs/tiledmap":27,"./gamejs/time":28,"./gamejs/utils/arrays":29,"./gamejs/utils/base64":30,"./gamejs/utils/callback":31,"./gamejs/utils/objects":32,"./gamejs/utils/strings":33,"./gamejs/utils/uri":34,"./gamejs/utils/xml":35}],9:[function(require,module,exports){
var gamejs = require('../gamejs');

/**
 * @fileoverview `Animations` on top of `SpriteSheets`.
 *
 * @example
 * var spriteSheet = new SpriteSheet(sheetSurface, {width: 16, height: 16});
 * var animation = new Animation(spriteSheet, {walk: [0,1,2,3], loop: true});
 * animation.setState('walk');
 * ....
 * animation.update(msDuration)
 * ....
 * display.blit(animation.currentFrame);
 *
 */

/**
 * Turn a Surface into a SpriteSheet. This makes individual images ("tiles") within the
 * larger Surface retrievable with the SpriteSheet's `get(indexPositon)` method.
 *
 * Available option properties are (width and height are required):
 *
 *  * `width` individual tile, number
 *  * `height` of individual tile, number
 *  * `spacing` between two tiles, number
 *  * `margin` at the image border without tiles, number
 *  * `scaleTo` [width,height] scale tiles to this size after loading
 *  *
 *
 * @param {Surface} image containing the individual tiles
 * @param {Object} options describing the tile dimensions, size, spacing, etc. (see above)
 */
var SpriteSheet = exports.SpriteSheet = function(image, opts) {
    /** @ignore **/
    this.width = opts.width;
    /** @ignore **/
    this.height = opts.height;
    /** @ignore **/
    this.spacing = opts.spacing || 0;
    /** @ignore **/
    this.margin = opts.margin || 0;
    /** @ignore **/
    this.image = image;

    /** @ignore **/
    this.surfaceCache = [];

    var imgSize = new gamejs.Rect([0,0],[this.width,this.height]);
    if (opts.scaleTo) {
        imgSize = new gamejs.Rect([0,0], opts.scaleTo);
    }

    // Extract the cells from the spritesheet image.
    for (var i = this.margin; i < this.image.rect.height; i += this.height + this.spacing) {
        for (var j = this.margin; j < this.image.rect.width; j += this.width + this.spacing) {
            var surface = new gamejs.graphics.Surface([this.width, this.height]);
            var rect = new gamejs.Rect(j, i, this.width, this.height);
            //surface._context.imageSmoothingEnabled = false;
            surface.blit(this.image, imgSize, rect);
            this.surfaceCache.push(surface);
        }
    }
    return this;
};

/**
 * Retrieve the tile at given index position. The index position can be calculated as:

 *    index = column + row * rowLength
 *
 * @param {Number} index
 * @returns {Surface} the tile surface
 */
SpriteSheet.prototype.get = function(index) {
        return this.surfaceCache[index];
};

/**
 * An Animation is a gamejs.animate.SpriteSheet with an animation specification which
 * explains what states the animation has and which tiles in the SpriteSheet compose
 * those states.
 *
 * An animation specification might look like this:
 *       var npcAnimationSpec = {
 *           idle: {frames: [0], rate: 5, loop: true},
 *           moveup: {frames: [0,1,2,3,4,5,6,7,8], rate: rate, loop: true},
 *           die: {frames: [18,19,20,21,22,23,24,25,26], rate: rate, loop: true},
 *           ....
 *       };
 *
 *  The keys in the npcAnimationSpec are the animation state names and each object
 * is describing on such state: `frames` are the index positions of the tiles in the
 * SpriteSheet making up that state. `rate` is the frequence per second at which the
 * state should switch from tile to tile of the state and `loop` designates whether
 * the state shold end or loop endlessly.
 *
 * @param {gamejs.animate.SpriteSheet} spriteSheet
 * @param {String} initialState name of the initital state
 * @param {Object} animationSpecification
 *
 */
var Animation = exports.Animation = function(spriteSheet, initial, spec) {
    /** @ignore **/
    this.spec = spec;

    /** The current tile surface of the animation. Draw this to the screen. **/
    this.currentFrame = null;
    /** @ignore **/
    this.currentFrameDuration = 0;
    /** @ignore **/
    this.currentAnimation = null;
    /** @ignore */
    this._isFinished = false;
    /** @ignore **/
    this.spriteSheet = spriteSheet;
    /** @ignore **/
    this.image = spriteSheet.get(0);
    this.start(initial);

};

/** @ignore **/
Animation.prototype.setFrame = function(frame) {
    this.frameIndex = frame;
};

/** @ignore **/
Animation.prototype.start = function(name) {
    this._isFinished = false;
    this.setState(name);
    this.update(0);
    return;
};

/**
 * Set the animation to the given state.
 *
 * @param {String} stateName
 */
Animation.prototype.setState = function(name) {
    if (this.currentAnimation === name) {
        return;
    }

    this.currentAnimation = name;
    this.currentFrame = this.spec[name].frames[0];
    this.frameIndex = 0;
    this.currentFrameDuration = 0;
    this.frameDuration = 1000 / this.spec[name].rate;
};

/**
 * Call this function every tick to update the animation.
 *
 * @param {Number} msDuration since last tick
 * @returns {Boolean} whether animation image has changed during this update
 */
Animation.prototype.update = function(msDuration) {
    if (!this.currentAnimation) {
        throw new Error('No animation started.');
    }

    this.currentFrameDuration += msDuration;
    if (this.currentFrameDuration >= this.frameDuration && this._isFinished === false){
        var frames = this.spec[this.currentAnimation].frames;

        this.currentFrame = frames[this.frameIndex++];
        this.currentFrameDuration = 0;

        var length = this.spec[this.currentAnimation].frames.length - 1;
        if (this.frameIndex > length) {
            if (this.spec[this.currentAnimation].loop) {
                this.frameIndex = 0;
                this.currentFrame = frames[this.frameIndex];
            } else {
                this._isFinished = true;
                this.frameIndex--;
                this.currentFrame = frames[this.frameIndex];
            }
        }
        this.image = this.spriteSheet.get(this.currentFrame);
        return true;
    }

    return false;
};

/**
 * Whether the animation has ended. Looping animations never end.
 */
Animation.prototype.isFinished = function() {
    return this._isFinished;
};

},{"../gamejs":8}],10:[function(require,module,exports){
var gamejs = require('../gamejs');

/**
 * @fileoverview Playing sounds with the html5 audio tag. Audio files must be preloaded
 * with the usual `gamejs.preload()` function. Ogg, wav and webm supported.
 *
 */

var CACHE = {};

/**
 * need to export preloading status for require
 * @ignore
 */
var _PRELOADING = false;

/**
 * @ignore
 */
var NUM_CHANNELS = 8;

/**
 * Sets the number of available channels for the mixer. The default value is 8.
 */
exports.setNumChannels = function(count) {
   NUM_CHANNELS = parseInt(count, 10) || NUM_CHANNELS;
};

exports.getNumChannels = function() {
   return NUM_CHANNELS;
};

/**
 * put all audios on page in cache
 * if same domain as current page, remove common href-prefix
 * @ignore
 */
exports.init = function() {
   var audios = Array.prototype.slice.call(document.getElementsByTagName("audio"), 0);
   addToCache(audios);
   return;
};

/**
 * Preload the audios into cache
 * @param {String[]} List of audio URIs to load
 * @returns {Function} which returns 0-1 for preload progress
 * @ignore
 */
exports.preload = function(audioUrls, showProgressOrImage) {
   var countTotal = 0;
   var countLoaded = 0;

   function incrementLoaded() {
      countLoaded++;
      if (countLoaded == countTotal) {
         _PRELOADING = false;
      }
   }

   function getProgress() {
      return countTotal > 0 ? countLoaded / countTotal : 1;
   }

   function successHandler() {
      addToCache(this);
      incrementLoaded();
   }
   function errorHandler() {
      incrementLoaded();
      throw new Error('Error loading ' + this.src);
   }

   for (var key in audioUrls) {
      if (key.indexOf('wav') == -1 && key.indexOf('ogg') == -1 && key.indexOf('webm') == -1) {
         continue;
      }
      countTotal++;
      var audio = new Audio();
      audio.addEventListener('canplay', successHandler, true);
      audio.addEventListener('error', errorHandler, true);
      audio.src = audioUrls[key];
      audio.gamejsKey = key;
      audio.load();
   }
   if (countTotal > 0) {
      _PRELOADING = true;
   }
   return getProgress;
};

/**
 * @ignore
 */
exports.isPreloading = function() {
   return _PRELOADING;
};

/**
 * @param {dom.ImgElement} audios the <audio> elements to put into cache
 * @ignore
 */
function addToCache(audios) {
   if (!(audios instanceof Array)) {
      audios = [audios];
   }

   var docLoc = document.location.href;
   audios.forEach(function(audio) {
      CACHE[audio.gamejsKey] = audio;
   });
   return;
}

/**
 * Sounds can be played back.
 * @constructor
 * @param {String|dom.AudioElement} uriOrAudio the uri of <audio> dom element
 *                of the sound
 */
exports.Sound = function Sound(uriOrAudio) {
   var cachedAudio;
   if (typeof uriOrAudio === 'string') {
      cachedAudio = CACHE[uriOrAudio];
   } else {
      cachedAudio = uriOrAudio;
   }
   if (!cachedAudio) {
      // TODO sync audio loading
      throw new Error('Missing "' + uriOrAudio + '", gamejs.preload() all audio files before loading');
   }

   var channels = [];
   var i = NUM_CHANNELS;
   while (i-->0) {
      var audio = new Audio();
      audio.preload = "auto";
      audio.loop = false;
      audio.src = cachedAudio.src;
      channels.push(audio);
   }
   /**
    * start the sound
    * @param {Boolean} loop whether the audio should loop for ever or not
    */
   this.play = function(loop) {
      channels.some(function(audio) {
         if (audio.ended || audio.paused) {
            audio.loop = !!loop;
            audio.play();
            return true;
         }
         return false;
      });
   };

   /**
    * Stop the sound.
    * This will stop the playback of this Sound on any active Channels.
    */
   this.stop = function() {
      channels.forEach(function(audio) {
         audio.stop();
      });
   };

   /**
    * Set volume of this sound
    * @param {Number} value volume from 0 to 1
    */
   this.setVolume = function(value) {
      channels.forEach(function(audio) {
         audio.volume = value;
      });
   };

   /**
    * @returns {Number} the sound's volume from 0 to 1
    */
   this.getVolume = function() {
      return channels[0].volume;
   };

   /**
    * @returns {Number} Duration of this sound in seconds
    */
   this.getLength = function() {
      return channels[0].duration;
   };

   return this;
};

},{"../gamejs":8}],11:[function(require,module,exports){
var Surface = require('./graphics').Surface;

/**
 * @fileoverview Methods to create, access and manipulate the display Surface.
 *
 * You can just grab the canvas element whether it exists in the DOM or not (GameJs
 * will create it if necessary):
 *
 *     var display = gamejs.display.getSurface();
 *
 * If you need to resize the canvas - although it is recommended to style it with CSS - you can
 * call the `setMode()` function, which conviniently returns the new display surface:
 *
 *     newDisplay = gamejs.display.setMode([800, 600]);
 *
 * ### Browser window gets resized
 *
 * When the canvas size is configured with CSS, the display surface might change when
 * the browser window is resized. GameJs will internally deal with this and recreate
 * the the display surface with the new size.
 *
 * You will typically not have to worry about this but if you want to get informed
 * about a display resize, you can register a callback with `gamejs.event.onDisplayResize`.
 *
 *
 * ### Flags
 *
 * For advanced uses you can set a few modes which additionally change how the display
 * behaves with regards to pixel smoothing and whether you want a fullscreen canvas with
 * or withouth the mouse pointer locked inside the window (for endless mouse movement in
 * all directions).
 *
 *
 * `gamejs.display.setMode()` understands three flags:
 *
 *   * gamejs.display.FULLSCREEN
 *   * gamejs.display.DISABLE_SMOOTHING
 *   * gamejs.display.POINTERLOCK (implies FULLSCREEN)
 *
 * For example:
 *      // disable smoothing
 *      gamejs.display.setMode([800, 600], gamejs.display.DISABLE_SMOOTHING);
 *      // disable smoothing and fullscreen
 *      gamejs.display.setMode(
               [800, 600],
               gamejs.display.DISABLE_SMOOTHING | gamejs.display.FULLSCREEN
         );
 *
 * ### Fullscreen mode
 *
 * When `setMode()` is called with the fullscreen flag then the fullscreen mode can be enabled by the
 * player by clicking on the DOM element with id "gjs-fullscreen-toggle". Browser security requires
 * that a user enables fullscreen with a "gesture" (e.g., clicking a button) and we can not enable fullscreen
 * in code.
 *
 * Fullscreen mode can be exited by many keys, e.g., anything window manager related (ALT-TAB) or ESC. A lot
 * of keys will trigger a browser information popup explaining how fullscreen mode can be exited.
 *
 * The following keys are "whitelisted" in fullscreen mode and will not trigger such a browser popup:
 *
 *  * left arrow, right arrow, up arrow, down arrow
 *  * space
 *  * shift, control, alt
 *  * page up, page down
 *  * home, end, tab, meta
 *
 *
 * ### Relevant DOM node ids accessed by this module
 *
 * You can provide your own tags with those ids
 *
 *   * gjs-canvas - the display surface
 *   * gjs-loader - loading bar
 *   * gjs-fullscreen-toggle a clickable element to enable fullscreen
 *   * gjs-canvas-wrapper this wrapper is added when in fullscreen mode
 *
 */

var CANVAS_ID = "gjs-canvas";
var LOADER_ID = "gjs-loader";
var SURFACE = null;

/**
 * Pass this flag to `gamejs.display.setMode(resolution, flags)` to disable
 * pixel smoothing; this is, for example, useful for retro-style, low resolution graphics
 * where you don't want the browser to smooth them when scaling & drawing.
 */
var DISABLE_SMOOTHING = exports.DISABLE_SMOOTHING = 2;
var FULLSCREEN = exports.FULLSCREEN = 4;
var POINTERLOCK = exports.POINTERLOCK = 8;

var _flags = 0;

/**
 * @returns {document.Element} the canvas dom element
 * @ignore
 */
var getCanvas = exports._getCanvas = function() {
   var displayCanvas = document.getElementById(CANVAS_ID);
   if (!displayCanvas) {
      displayCanvas = document.createElement("canvas");
      displayCanvas.setAttribute("id", CANVAS_ID);
      document.body.appendChild(displayCanvas);
   }
   return displayCanvas;
};


var getFullScreenToggle = function() {
   var fullScreenButton = document.getElementById('gjs-fullscreen-toggle');
   if (!fullScreenButton) {
      // before canvas
      fullScreenButton = document.createElement('button');
      fullScreenButton.innerHTML = 'Fullscreen';
      fullScreenButton.id = 'gjs-fullscreen-toggle';
      var canvas = getCanvas();
      canvas.parentNode.insertBefore(fullScreenButton, canvas);
      canvas.parentNode.insertBefore(document.createElement('br'), canvas);

   }
   return fullScreenButton;
};

var fullScreenChange = function(event) {
   var gjsEvent ={
      type: isFullScreen() ? require('./event').DISPLAY_FULLSCREEN_ENABLED :
                        require('./event').DISPLAY_FULLSCREEN_DISABLED

   };
   if (isFullScreen()) {
      if (_flags & POINTERLOCK) {
         enablePointerLock();
      }
   }
   require('./event')._triggerCallbacks(gjsEvent);
};

exports.hasPointerLock = function() {
   return !!(document.pointerLockElement ||
      document.webkitFullscreenElement ||
      document.mozFullscreenElement ||
      document.mozFullScreenElement);
};

function onResize(event) {
   var canvas = getCanvas();
   SURFACE._canvas.width = canvas.clientWidth;
   SURFACE._canvas.height = canvas.clientHeight;
   require('./event')._triggerCallbacks({
      type: require('./event').DISPLAY_RESIZE
   });
}

/**
 * Create the master Canvas plane.
 * @ignore
 */
exports.init = function() {
   // create canvas element if not yet present
   var canvas = getCanvas();
   if (!canvas.getAttribute('tabindex')) {
      // to be focusable, tabindex must be set
      canvas.setAttribute("tabindex", 1);
      canvas.focus();
   }
   // remove loader if any;
   var $loader = document.getElementById(LOADER_ID);
   if ($loader) {
      $loader.style.display = "none";
   }
   var $displaySurface = document.getElementById(CANVAS_ID);
   if ($displaySurface) {
      $displaySurface.style.display = 'block';
   }
   // hook into resize
   window.addEventListener("resize", onResize, false);
   return;
};

var isFullScreen = exports.isFullscreen = function() {
   return (document.fullScreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.webkitDisplayingFullscreen);
};

/**
 * Switches the display window normal browser mode and fullscreen.
 * @ignore
 * @returns {Boolean} true if operation was successfull, false otherwise
 */
var enableFullScreen = function(event) {
   var wrapper = getCanvas();
   wrapper.requestFullScreen = wrapper.requestFullScreen || wrapper.mozRequestFullScreen || wrapper.webkitRequestFullScreen;
   if (!wrapper.requestFullScreen) {
      return false;
   }
   // @xbrowser chrome allows keboard input onl if ask for it (why oh why?)
   if (Element.ALLOW_KEYBOARD_INPUT) {
      wrapper.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
   } else {
      wrapper.requestFullScreen();
   }
   return true;
};

var enablePointerLock = function() {
   var wrapper = getCanvas();
   wrapper.requestPointerLock = wrapper.requestPointerLock || wrapper.mozRequestPointerLock || wrapper.webkitRequestPointerLock;
   if (wrapper.requestPointerLock) {
      wrapper.requestPointerLock();
   }
};

/** @ignore **/
exports._hasFocus = function() {
   return document.activeElement == getCanvas();
};

/**
 * Set the width and height of the Display. Conviniently this will
 * return the actual display Surface - the same as calling [gamejs.display.getSurface()](#getSurface)
 * later on.
 * @param {Array} dimensions [width, height] of the display surface
 * @param {Number} flags gamejs.display.DISABLE_SMOOTHING | gamejs.display.FULLSCREEN | gamejs.display.POINTERLOCK
 */
exports.setMode = function(dimensions, flags) {
   SURFACE = null;
   var canvas = getCanvas();
   canvas.width = canvas.clientWidth = dimensions[0];
   canvas.height = canvas.clientHeight = dimensions[1];

   _flags = _flags || flags;
   // @ xbrowser firefox allows pointerlock only if fullscreen
   if (_flags & POINTERLOCK) {
      _flags = _flags | FULLSCREEN;
   }
   if (_flags & FULLSCREEN) {
      // attach fullscreen toggle checkbox
      var fullScreenToggle = getFullScreenToggle();
      fullScreenToggle.removeEventListener('click', enableFullScreen, false);
      fullScreenToggle.addEventListener('click', enableFullScreen, false);
      // @@ xbrowser
      document.removeEventListener('fullScreenchange',fullScreenChange, false);
      document.removeEventListener('webkitfullscreenchange',fullScreenChange, false);
      document.removeEventListener('mozfullscreenchange',fullScreenChange, false);
      document.addEventListener('fullscreenchange', fullScreenChange, false);
      document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
      document.addEventListener('mozfullscreenchange', fullScreenChange, false);
   }
   return getSurface(dimensions);
};

/**
 * Set the Caption of the Display (document.title)
 * @param {String} title the title of the app
 * @param {gamejs.Image} icon FIXME implement favicon support
 */
exports.setCaption = function(title, icon) {
   document.title = title;
};

/** @ignore **/
exports._isSmoothingEnabled = function() {
   return !(_flags & DISABLE_SMOOTHING);
};

/**
 * The Display (the canvas element) is most likely not in the top left corner
 * of the browser due to CSS styling. To calculate the mouseposition within the
 * canvas we need this offset.
 * @see gamejs/event
 * @ignore
 *
 * @returns {Array} [x, y] offset of the canvas
 */

exports._getCanvasOffset = function() {
   var boundRect = getCanvas().getBoundingClientRect();
   return [boundRect.left, boundRect.top];
};

/**
 * Drawing on the Surface returned by `getSurface()` will draw on the screen.
 * @returns {gamejs.Surface} the display Surface
 */
var getSurface = exports.getSurface = function(dimensions) {
   if (SURFACE === null) {
      var canvas = getCanvas();
      if (dimensions === undefined) {
         dimensions = [canvas.clientWidth, canvas.clientHeight];
      }
      SURFACE = new Surface(dimensions);
      SURFACE._canvas = canvas;
      SURFACE._canvas.width = dimensions[0];
      SURFACE._canvas.height = dimensions[1];
      SURFACE._context = canvas.getContext('2d');
      if (!(_flags & DISABLE_SMOOTHING)) {
         SURFACE._smooth();
      } else {
         SURFACE._noSmooth();
      }
   }
   return SURFACE;
};

},{"./event":12,"./graphics":14}],12:[function(require,module,exports){
var display = require('./display');
var Callback = require('./utils/callback').Callback;

/**
 * @fileoverview
 * Deal with mouse and keyboard events.
 *
 * You can either handle all events in one callback with `gamejs.event.onEvent()`:
 *
 *     gamejs.onEvent(function(event) {
 *        if (event.type === gamejs.event.MOUSE_UP) {
 *          gamejs.logging.info(event.pos, event.button);
 *        } else if (event.type === gamejs.event.KEY_UP) {
 *          gamejs.logging.info(event.key);
 *        }
 *     });
 *
 * Or recieve more specific callbacks, e.g. only for `KEY\_UP` with  `gamejs.event.onKeyUp()`:
 *
 *     gamejs.onKeyUp(function(event) {
 *          gamejs.logging.info(event.key);
 *     });
 *
 * All events passed to your callback are instances of `gamejs.event.Event` and have a `type` property to help
 * you distinguish between the different events. This `type` property is set to one of those constants:
 *
 *  * gamejs.event.MOUSE\_UP
 *  * gamejs.event.MOUSE\_MOTION
 *  * gamejs.event.MOUSE\_DOWN
 *  * gamejs.event.KEY\_UP
 *  * gamejs.event.KEY\_DOWN
 *  * gamejs.event.DISPLAY\_FULLSCREEN\_ENABLED
 *  * gamejs.event.DISPLAY\_FULLSCREEN\_DISABLED
 *  * gamejs.event.QUIT
 *  * gamejs.event.MOUSE_WHEEL
 *  * gamejs.event.TOUCH\_DOWN
 *  * gamejs.event.TOUCH\_UP
 *  * gamejs.event.TOUCH\_MOTION
 *
 * ### Keyboard constants
 *
 * There are also a lot of keyboard constants for ASCII. Those are all prefixed with `K\_`, e.g. `gamejs.event.K\_a` would be the "a"
 * key and `gamejs.event.K_SPACE` is the spacebar.
 *
 * ## Touch events
 *
 * Touch events do not have a single position but for all `TOUCH\_*` events you get an array of
 * `touches`, which each have their own `pos` attribute and a unique `identifier` for tracking
 * this touch across multiple `TOUCH\_MOTION` events.
 *
 * ## User defined events
 *
 * All user defined events can have the value of `gamejs.event.USEREVENT` or higher.
 * Make sure your custom event ids follow this system.
 *
 * @example
 *     gamejs.onEvent(function(event) {
 *        if (event.type === gamejs.event.MOUSE_UP) {
 *          gamejs.logging.log(event.pos, event.button);
 *        } else if (event.type === gamejs.event.KEY_UP) {
 *          gamejs.logging.log(event.key);
 *        }
 *     });
 *
 */

var _CALLBACKS = [];

/** @ignore **/
var _triggerCallbacks = exports._triggerCallbacks = function() {
  var args = arguments;
  _CALLBACKS.forEach(function(cb) {
    if (cb.type === 'all' || args[0].type === cb.type) {
      cb.callback.apply(cb.scope, args);
    }
  });
};

/*
exports.onQuit(callback)
exports.onVisiblityChange(callback)
*/

/**
 * Pass a callback function to be called when Fullscreen is enabled or disabled.
 * Inspect `event.type` to distinguis between entering and exiting fullscreen.
 *
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onFullscreen = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
   _CALLBACKS.push({
      callback: callback,
      scope: scope,
      type: exports.DISPLAY_FULLSCREEN_ENABLED
   });
   _CALLBACKS.push({
      callback: callback,
      scope: scope,
      type: exports.DISPLAY_FULLSCREEN_DISABLED
   });
};

/**
 * The function passsed to `onEvent` will be called whenever
 * any event (mouse, keyboard, etc) was triggered.
 *
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onEvent = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: 'all'
  });
};


/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onDisplayResize = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   };

  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.DISPLAY_RESIZE
  });
}

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onMouseMotion = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.MOUSE_MOTION
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onMouseUp = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.MOUSE_UP
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onMouseDown = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.MOUSE_DOWN
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onTouchMotion = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.TOUCH_MOTION
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onTouchUp = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.TOUCH_UP
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onTouchDown = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.TOUCH_DOWN
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onKeyDown = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.KEY_DOWN
  });
};

/**
 * @param {Function} callback to be called
 * @param {Object} scope within which the callback should be called. It's `this` during invocation. (optional)
 */
exports.onKeyUp = function(callback, scope) {
   if (typeof(callback) !== 'function') {
      throw new Error('Callback must be a function');
   }
  _CALLBACKS.push({
    callback: callback,
    scope: scope,
    type: exports.KEY_UP
  });
};

// key constants
exports.K_UP = 38;
exports.K_DOWN = 40;
exports.K_RIGHT = 39;
exports.K_LEFT = 37;

exports.K_SPACE = 32;
exports.K_BACKSPACE = 8;
exports.K_TAB = 9;
exports.K_ENTER = 13;
exports.K_SHIFT = 16;
exports.K_CTRL = 17;
exports.K_ALT = 18;
exports.K_ESC = 27;

exports.K_0 = 48;
exports.K_1 = 49;
exports.K_2 = 50;
exports.K_3 = 51;
exports.K_4 = 52;
exports.K_5 = 53;
exports.K_6 = 54;
exports.K_7 = 55;
exports.K_8 = 56;
exports.K_9 = 57;
exports.K_a = 65;
exports.K_b = 66;
exports.K_c = 67;
exports.K_d = 68;
exports.K_e = 69;
exports.K_f = 70;
exports.K_g = 71;
exports.K_h = 72;
exports.K_i = 73;
exports.K_j = 74;
exports.K_k = 75;
exports.K_l = 76;
exports.K_m = 77;
exports.K_n = 78;
exports.K_o = 79;
exports.K_p = 80;
exports.K_q = 81;
exports.K_r = 82;
exports.K_s = 83;
exports.K_t = 84;
exports.K_u = 85;
exports.K_v = 86;
exports.K_w = 87;
exports.K_x = 88;
exports.K_y = 89;
exports.K_z = 90;

exports.K_KP1 = 97;
exports.K_KP2 = 98;
exports.K_KP3 = 99;
exports.K_KP4 = 100;
exports.K_KP5 = 101;
exports.K_KP6 = 102;
exports.K_KP7 = 103;
exports.K_KP8 = 104;
exports.K_KP9 = 105;

// event type constants
exports.NOEVENT = 0;
exports.NUMEVENTS = 32000;

exports.DISPLAY_FULLSCREEN_ENABLED = 300;
exports.DISPLAY_FULLSCREEN_DISABLED = 301;
exports.DISPLAY_RESIZE = 302;

exports.QUIT = 0;
exports.KEY_DOWN = 1;
exports.KEY_UP = 2;
exports.MOUSE_MOTION = 3;
exports.MOUSE_UP = 4;
exports.MOUSE_DOWN = 5;
exports.MOUSE_WHEEL = 6;
exports.TOUCH_UP = 7;
exports.TOUCH_DOWN = 8;
exports.TOUCH_MOTION = 9;
exports.USEREVENT = 2000;



/**
 * Properties of the `event` object argument passed to the callbacks.
 * @class
 */

exports.Event = function() {
    /**
     * The type of the event. e.g., gamejs.event.QUIT, KEYDOWN, MOUSEUP.
     */
    this.type = null;
    /**
     * key the keyCode of the key. compare with gamejs.event.K_a, gamejs.event.K_b,...
     */
    this.key = null;
    /**
     * relative movement for a mousemove event
     */
    this.rel = null;
    /**
     * the number of the mousebutton pressed
     */
    this.button = null;
    /**
     * pos the position of the event for mouse events
     */
    this.pos = null;
};

/**
 * @ignore
 */
exports.init = function() {

   var lastPos = [];

   // anonymous functions as event handlers = memory leak, see MDC:elementAddEventListener

   function onMouseDown (ev) {
      var canvasOffset = display._getCanvasOffset();
      _triggerCallbacks({
         'type': exports.MOUSE_DOWN,
         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
         'button': ev.button,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onMouseUp (ev) {
      var canvasOffset = display._getCanvasOffset();
      _triggerCallbacks({
         'type':exports.MOUSE_UP,
         'pos': [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
         'button': ev.button,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onKeyDown (ev) {
      var key = ev.keyCode || ev.which;
      _triggerCallbacks({
         'type': exports.KEY_DOWN,
         'key': key,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });

      // if the display has focus, we surpress default action
      // for most keys
      if (display._hasFocus() && (!ev.ctrlKey && !ev.metaKey &&
         ((key >= exports.K_LEFT && key <= exports.K_DOWN) ||
         (key >= exports.K_0    && key <= exports.K_z) ||
         (key >= exports.K_KP1  && key <= exports.K_KP9) ||
         key === exports.K_SPACE ||
         key === exports.K_TAB ||
         key === exports.K_ENTER)) ||
         key === exports.K_ALT ||
         key === exports.K_BACKSPACE) {
        ev.preventDefault();
      }
   }

   function onKeyUp (ev) {
      _triggerCallbacks({
         'type': exports.KEY_UP,
         'key': ev.keyCode,
         'shiftKey': ev.shiftKey,
         'ctrlKey': ev.ctrlKey,
         'metaKey': ev.metaKey
      });
   }

   function onMouseMove (ev) {
      var canvasOffset = display._getCanvasOffset();
      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
      var relativePos = [];
      if (lastPos.length) {
         relativePos = [
            lastPos[0] - currentPos[0],
            lastPos[1] - currentPos[1]
         ];
      }
      _triggerCallbacks({
         'type': exports.MOUSE_MOTION,
         'pos': currentPos,
         'rel': relativePos,
         'buttons': null, // FIXME, fixable?
         'timestamp': ev.timeStamp,
         'movement': [ev.movementX       ||
                      ev.mozMovementX    ||
                      ev.webkitMovementX || 0,
                      ev.movementY       ||
                      ev.mozMovementY    ||
                      ev.webkitMovementY || 0
                      ]
      });
      lastPos = currentPos;
      return;
   }

   function onMouseScroll(ev) {
      var canvasOffset = display._getCanvasOffset();
      var currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
      _triggerCallbacks({
         type: exports.MOUSE_WHEEL,
         pos: currentPos,
         delta: ev.detail || (- ev.wheelDeltaY / 40)
      });
      return;
   }

   function onBeforeUnload (ev) {
      _triggerCallbacks({
         'type': exports.QUIT
      });
      return;
   };

   // convert a w3c touch event into gamejs event
   function w3cTouchConvert(touchList) {
      var canvasOffset = display._getCanvasOffset();
      var tList = [];
      for (var i = 0; i < touchList.length; i++) {
         var touchEvent = touchList.item(i);
         tList.push({
            identifier: touchEvent.identifier,
            pos: [touchEvent.clientX - canvasOffset[0], touchEvent.clientY - canvasOffset[1]]
         });
      }
      return tList;
   }

   function onTouchDown(ev) {
      var canvasOffset = display._getCanvasOffset();
      var changedTouches = w3cTouchConvert(ev.changedTouches);
      _triggerCallbacks({
         'type': exports.TOUCH_DOWN,
         'touches': changedTouches
      });
   };

   function onTouchUp(ev) {
      var changedTouches = w3cTouchConvert(ev.changedTouches);
      _triggerCallbacks({
         'type': exports.TOUCH_UP,
         'touches': changedTouches,
      });
   }
   function onTouchMotion(ev) {
      var changedTouches = w3cTouchConvert(ev.changedTouches);
      _triggerCallbacks({
         'type': exports.TOUCH_MOTION,
         'touches': changedTouches
      });
      ev.preventDefault();
   }

   // IE does not support addEventListener on document itself
   // FX events don't reach body if mouse outside window or on menubar
   var canvas = display._getCanvas();
   document.addEventListener('mousedown', onMouseDown, false);
   document.addEventListener('mouseup', onMouseUp, false);
   document.addEventListener('keydown', onKeyDown, false);
   document.addEventListener('keyup', onKeyUp, false);
   document.addEventListener('mousemove', onMouseMove, false);
   canvas.addEventListener('mousewheel', onMouseScroll, false);
   // MOZFIX
   // https://developer.mozilla.org/en/Code_snippets/Miscellaneous#Detecting_mouse_wheel_events
   canvas.addEventListener('DOMMouseScroll', onMouseScroll, false);
   canvas.addEventListener('beforeunload', onBeforeUnload, false);
   // touchs
   canvas.addEventListener("touchstart", onTouchDown, false);
   canvas.addEventListener("touchend", onTouchUp, false);
   canvas.addEventListener("touchcancel", onTouchUp, false);
   canvas.addEventListener("touchleave", onTouchUp, false);
   canvas.addEventListener("touchmove", onTouchMotion, false);

};

},{"./display":11,"./utils/callback":31}],13:[function(require,module,exports){
var Surface = require('./graphics').Surface;
var objects = require('./utils/objects');

/**
 * @fileoverview Methods for creating Font objects which can render text
 * to a Surface.
 *
 * @example
 * var font = new Font('20px monospace');
 * // render text - this returns a surface with the text written on it.
 * var helloSurface = font.render('Hello World')
 */

/**
 * Create a Font to draw on the screen. The Font allows you to
 * `render()` text. Rendering text returns a Surface which
 * in turn can be put on screen.
 *
 * @constructor
 * @property {Number} fontHeight the line height of this Font
 *
 * @param {String} fontSettings a css font definition, e.g., "20px monospace"
 * @param {STring} backgroundColor valid #rgb string, "#ff00cc"
 */
var Font = exports.Font = function(fontSettings, backgroundColor) {
    /**
     * @ignore
     */
   this.sampleSurface = new Surface([10,10]);
   this.sampleSurface.context.font = fontSettings;
   this.sampleSurface.context.textAlign = 'start';
   // http://diveintohtml5.org/canvas.html#text
   this.sampleSurface.context.textBaseline = 'bottom';
   this.backgroundColor = backgroundColor || false;
   return this;
};

/**
 * Returns a Surface with the given text on it.
 * @param {String} text the text to render
 * @param {String} color a valid #RGB String, "#ffcc00"
 * @returns {gamejs.Surface} Surface with the rendered text on it.
 */
Font.prototype.render = function(text, color) {
   var dims = this.size(text);
   var surface = new Surface(dims);
   var ctx = surface.context;
   ctx.save();
   if ( this.backgroundColor ) {
       ctx.fillStyle = this.backgroundColor;
       ctx.fillRect(0, 0, surface.rect.width, surface.rect.height);
   }
   ctx.font = this.sampleSurface.context.font;
   ctx.textBaseline = this.sampleSurface.context.textBaseline;
   ctx.textAlign = this.sampleSurface.context.textAlign;
   ctx.fillStyle = ctx.strokeStyle = color || "#000000";
   ctx.fillText(text, 0, surface.rect.height, surface.rect.width);
   ctx.restore();
   return surface;
};

/**
 * Determine the width and height of the given text if rendered
 * with this Font.
 * @param {String} text the text to measure
 * @returns {Array} the [width, height] of the text if rendered with this Font
 */
Font.prototype.size = function(text) {
   var metrics = this.sampleSurface.context.measureText(text);
   // FIXME measuretext is buggy, make extra wide
   return [metrics.width, this.fontHeight];
};

/**
 * Height of the font in pixels.
 */
objects.accessors(Font.prototype, {
   'fontHeight': {
      get: function() {
         // Returns an approximate line height of the text
         // »This version of the specification does not provide a way to obtain
         // the bounding box dimensions of the text.«
         // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-measuretext
         return this.sampleSurface.context.measureText('M').width * 1.5;
      }
   }

});

},{"./graphics":14,"./utils/objects":32}],14:[function(require,module,exports){
/**
 * @fileoverview
 * This module holds the important `Surface` class which is the general container for image data.
 *
 *     var surface = new gamejs.graphics.Surface([width, height]);
 *
 * The functions
 * to draw geometric lines like circles, lines, rectangles, etc. are also all in this module:
 *
 *     gamejs.graphics.line(surface, '#ff0000', centerPoint, radius);
 *
 * Each Surface instance has methods to create *a new* rotated, flipped, scaled, etc. instance of itself:
 *
 *     // the original `surface` remains untouched by the
 *     // filp operation. A new Surface instance
 *     // is returned by `flip()`.
 *     var horizontalFlippedSurface = surface.flip(true);
 *
 * If you want to put images (png, jpg) on the screen, also see the `gamejs.image` module and `gamejs.preload()`.
 *
 * There are several ways to specify colors. Whenever the docs says "valid #RGB string"
 * you can pass in any of the following formats: `"#ff00ff"`, `"rgb(255, 0, 255)"` or `"rgba(255, 0, 255, 1)"`.
 *
 * @see gamejs/image
 */
var gamejs = require('../gamejs');
var Rect = gamejs.Rect;
var objects = require('./utils/objects');

/**
 * transform functions
 */
var matrix = require('./math/matrix');
var vectors = require('./math/vectors');

/**
 * A Surface represents a bitmap image with a fixed width and height. The
 * most important feature of a Surface is that they can be `blitted`
 * onto each other.
 *
 * @example
 * new gamejs.graphics.Surface([width, height]);
 * new gamejs.graphics.Surface(width, height);
 * new gamejs.graphics.Surface(rect);
 * @constructor
 *
 * @param {Array} dimensions Array holding width and height
 */
var Surface = exports.Surface = function() {
   var args = gamejs.normalizeRectArguments.apply(this, arguments);
   var width = args.left;
   var height = args.top;
   // unless argument is rect:
   if (arguments.length == 1 && arguments[0] instanceof Rect) {
      width = args.width;
      height = args.height;
   }
   // only for rotatation & scale
   /** @ignore */
   this._matrix = matrix.identity();
   /** @ignore */
    this._canvas = document.createElement("canvas");
    this._canvas.width = width;
    this._canvas.height = height;
    /** @ignore */
    this._blitAlpha = 1.0;

   /** @ignore */
   this._context = this._canvas.getContext('2d');
   // using exports is weird but avoids circular require
   if (gamejs.display._isSmoothingEnabled()) {
      this._smooth();
   } else {
      this._noSmooth();
   }
   return this;
};

/** @ignore */
Surface.prototype._noSmooth = function() {
    // disable image scaling
    // see https://developer.mozilla.org/en/Canvas_tutorial/Using_images#Controlling_image_scaling_behavior
    // and https://github.com/jbuck/processing-js/commit/65de16a8340c694cee471a2db7634733370b941c
    this.context.mozImageSmoothingEnabled = false;
  this.context.webkitImageSmoothingEnabled = false;
   return;
};
/** @ignore */
Surface.prototype._smooth = function() {
  this.context.mozImageSmoothingEnabled = true;
  this.context.webkitImageSmoothingEnabled = true;

};

/**
 * Blits another Surface on this Surface. The destination where to blit to
 * can be given (or it defaults to the top left corner) as well as the
 * Area from the Surface which should be blitted (e.g., for cutting out parts of
 * a Surface).
 *
 * @example
 * // blit flower in top left corner of display
 * displaySurface.blit(flowerSurface);
 *
 * // position flower at 10/10 of display
 * displaySurface.blit(flowerSurface, [10, 10])
 *
 * // ... `dest` can also be a rect whose topleft position is taken:
 * displaySurface.blit(flowerSurface, new gamejs.Rect([10, 10]);
 *
 * // only blit half of the flower onto the display
 * var flowerRect = flowerSurface.rect;
 * flowerRect = new gamejs.Rect([0,0], [flowerRect.width/2, flowerRect.height/2])
 * displaySurface.blit(flowerSurface, [0,0], flowerRect);
 *
 * @param {gamejs.graphics.Surface} src The Surface which will be blitted onto this one
 * @param {gamejs.Rect|Array} dst the Destination x, y position in this Surface.
 *            If a Rect is given, it's top and left values are taken. If this argument
 *            is not supplied the blit happens at [0,0].
 * @param {gamesjs.Rect|Array} area the Area from the passed Surface which
 *            should be blitted onto this Surface.
 * @param {Number} compositionOperation how the source and target surfaces are composited together; one of: source-atop, source-in, source-out, source-over (default), destination-atop, destination-in, destination-out, destination-over, lighter, copy, xor; for an explanation of these values see: http://dev.w3.org/html5/2dcontext/#dom-context-2d-globalcompositeoperation
 * @returns {gamejs.Rect} Rect actually repainted FIXME actually return something?
 */
Surface.prototype.blit = function(src, dest, area, compositeOperation) {

   var rDest, rArea;

   if (dest instanceof Rect) {
      rDest = dest.clone();
      var srcSize = src.getSize();
      if (!rDest.width) {
         rDest.width = srcSize[0];
      }
      if (!rDest.height) {
         rDest.height = srcSize[1];
      }
    } else if (dest && dest instanceof Array && dest.length == 2) {
      rDest = new Rect(dest, src.getSize());
    } else {
      rDest = new Rect([0,0], src.getSize());
    }
   compositeOperation = compositeOperation || 'source-over';

   // area within src to be drawn
   if (area instanceof Rect) {
      rArea = area;
   } else if (area && area instanceof Array && area.length == 2) {
      var size = src.getSize();
      rArea = new Rect(area, [size[0] - area[0], size[1] - area[1]]);
   } else {
      rArea = new Rect([0,0], src.getSize());
   }

   if (isNaN(rDest.left) || isNaN(rDest.top) || isNaN(rDest.width) || isNaN(rDest.height)) {
      throw new Error('[blit] bad parameters, destination is ' + rDest);
   }

   this.context.save();
   this.context.globalCompositeOperation = compositeOperation;
   this.context.globalAlpha = src._blitAlpha;
   this.context.drawImage(src.canvas, rArea.left, rArea.top, rArea.width, rArea.height, rDest.left, rDest.top, rDest.width, rDest.height);
   this.context.restore();
   return;
};

/**
 * @returns {Number[]} the width and height of the Surface
 */
Surface.prototype.getSize = function() {
   return [this.canvas.width, this.canvas.height];
};

/**
 * Obsolte, only here for compatibility.
 * @deprecated
 * @ignore
 * @returns {gamejs.Rect} a Rect of the size of this Surface
 */
Surface.prototype.getRect = function() {
   return new Rect([0,0], this.getSize());
};

/**
 * Fills the whole Surface with a color. Usefull for erasing a Surface.
 * @param {String} CSS color string, e.g. '#0d120a' or '#0f0' or 'rgba(255, 0, 0, 0.5)'
 * @param {gamejs.Rect} a Rect of the area to fill (defauts to entire surface if not specified)
 */
Surface.prototype.fill = function(color, rect) {
   this.context.save();
   this.context.fillStyle = color || "#000000";
   if (rect === undefined) {
       rect = new Rect(0, 0, this.canvas.width, this.canvas.height);
    }

   this.context.fillRect(rect.left, rect.top, rect.width, rect.height);
   this.context.restore();
   return;
};

/**
 * Clear the surface.
 */
Surface.prototype.clear = function(rect) {
   var size = this.getSize();
   rect = rect || new Rect(0, 0, size[0], size[1]);
   this.context.clearRect(rect.left, rect.top, rect.width, rect.height);
   return;
};

objects.accessors(Surface.prototype, {
   /**
    * @type gamejs.Rect
    */
   'rect': {
      get: function() {
         return this.getRect();
      }
   },
   /**
    * @ignore
    */
   'context': {
      get: function() {
         return this._context;
      }
   },
   'canvas': {
      get: function() {
         return this._canvas;
      }
   }
});

/**
 * @returns {gamejs.graphics.Surface} a clone of this surface
 */
Surface.prototype.clone = function() {
  var newSurface = new Surface(this.getRect());
  newSurface.blit(this);
  return newSurface;
};

/**
 * @returns {Number} current alpha value
 */
Surface.prototype.getAlpha = function() {
   return (1 - this._blitAlpha);
};

/**
 * Set the alpha value for the whole Surface. When blitting the Surface on
 * a destination, the pixels will be drawn slightly transparent.
 * @param {Number} alpha value in range 0.0 - 1.0
 * @returns {Number} current alpha value
 */
Surface.prototype.setAlpha = function(alpha) {
   if (isNaN(alpha) || alpha < 0 || alpha > 1) {
      return;
   }

   this._blitAlpha = (1 - alpha);
   return (1 - this._blitAlpha);
};

/**
 * The data must be represented in left-to-right order, row by row top to bottom,
 * starting with the top left, with each pixel's red, green, blue, and alpha components
 * being given in that order for each pixel.
 * @see http://dev.w3.org/html5/2dcontext/#canvaspixelarray
 * @returns {ImageData} an object holding the pixel image data {data, width, height}
 */
Surface.prototype.getImageData = function() {
   var size = this.getSize();
   return this.context.getImageData(0, 0, size[0], size[1]);
};



// FIXME all draw functions must return a minimal rect containing the drawn shape

/**
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] position of line start
 * @param {Array} endPos [x, y] position of line end
 * @param {Number} width of the line, defaults to 1
 */
exports.line = function(surface, color, startPos, endPos, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.lineTo(endPos[0], endPos[1]);
   ctx.stroke();
   ctx.restore();
   return;
};

/**
 * Draw connected lines. Use this instead of indiviudal line() calls for
 * better performance
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB string, "#ff0000"
 * @param {Boolean} closed if true the last and first point are connected
 * @param {Array} pointlist holding array [x,y] arrays of points
 * @param {Number} width width of the lines, defaults to 1
 */
exports.lines = function(surface, color, closed, pointlist, width) {
   closed = closed || false;
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.lineWidth = width || 1;
   pointlist.forEach(function(point, idx) {
      if (idx === 0) {
         ctx.moveTo(point[0], point[1]);
      } else {
         ctx.lineTo(point[0], point[1]);
      }
   });
   if (closed) {
      ctx.lineTo(pointlist[0][0], pointlist[0][1]);
   }
   ctx.stroke();
   ctx.restore();
   return;
};

/**
 * Draw a circle on Surface
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pos [x, y] position of the circle center
 * @param {Number} radius of the circle
 * @param {Number} width width of the circle, if not given or 0 the circle is filled
 */
exports.circle = function(surface, color, pos, radius, width) {
   if (isNaN(radius)) {
      throw new Error('[circle] radius required argument');
   }
   if (!pos || !(pos instanceof Array)) {
      throw new Error('[circle] pos must be given & array' + pos);
   }

   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.lineWidth = width || 1;
   ctx.arc(pos[0], pos[1], radius, 0, 2*Math.PI, true);
   if (width === undefined || width === 0) {
      ctx.fill();
   } else {
      ctx.stroke();
   }
   ctx.restore();
   return;
};

/**
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {gamejs.Rect} rect the position and dimension attributes of this Rect will be used
 * @param {Number} width the width of line drawing the Rect, if 0 or not given the Rect is filled.
 */
exports.rect = function(surface, color, rect, width) {
   var ctx =surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   if (isNaN(width) || width === 0) {
      ctx.fillRect(rect.left, rect.top, rect.width, rect.height);
   } else {
      ctx.lineWidth = width || 1;
      ctx.strokeRect(rect.left, rect.top, rect.width, rect.height);
   }
   ctx.restore();
};

/**
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pos [x, y] position of the circle center
 * @param {Number} startAngle, both angles in radians
 * @param {Number} stopAngle
 * @param {Number} radius
 * @param {Number} width the width of line, if 0 or not given the arc is filled.
 */
exports.arc= function(surface, color, pos, startAngle, stopAngle, radius, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.beginPath();
   ctx.strokeStyle = ctx.fillStyle = color;
   ctx.arc(pos[0], pos[1],
            radius,
            startAngle, stopAngle,
            false
         );
   if (isNaN(width) || width === 0) {
      ctx.fill();
   } else {
      ctx.lineWidth = width || 1;
      ctx.stroke();
   }
   ctx.restore();
};

/**
 * Draw a polygon on the surface. The pointlist argument are the vertices
 * for the polygon.
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color a valid #RGB String, #ff00cc
 * @param {Array} pointlist array of vertices [x, y] of the polygon
 * @param {Number} width the width of line, if 0 or not given the polygon is filled.
 */
exports.polygon = function(surface, color, pointlist, width) {
   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.beginPath();
   pointlist.forEach(function(point, idx) {
      if (idx === 0) {
         ctx.moveTo(point[0], point[1]);
      } else {
         ctx.lineTo(point[0], point[1]);
      }
   });
   ctx.closePath();
   if (isNaN(width) || width === 0) {
      ctx.fill();
   } else {
      ctx.lineWidth = width || 1;
      ctx.stroke();
   }
   ctx.restore();
};

/**
 * Draw a quadratic curve with one control point on the surface.
 * The control point position defines the shape of the quadratic curve.
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] the start position for the quadratic curve
 * @param {Array} endPos [x, y] the end position for the quadratic curve
 * @param {Array} controlPos [x, y] position of the control point
 * @param {Number} width of the quadratic curve, defaults to 1
 */
exports.quadraticCurve = function(surface, color, startPos, endPos, controlPos, width) {
   if (!startPos || !(startPos instanceof Array)) {
      throw new Error('[quadratic_curve] startPos must be defined!');
   }
   if (!endPos || !(endPos instanceof Array)) {
      throw new Error('[quadratic_curve] endPos must be defined!');
   }
   if (!controlPos || !(controlPos instanceof Array)) {
      throw new Error('[quadratic_curve] controlPos must be defined!');
   }

   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;

   ctx.beginPath();
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.quadraticCurveTo(controlPos[0], controlPos[1], endPos[0], endPos[1]);
   ctx.stroke();

   ctx.restore();
};

/**
 * Draw a bezier curve with two control points on the surface.
 * The control point positions define the shape of the bezier curve.
 *
 * @param {gamejs.graphics.Surface} surface the Surface to draw on
 * @param {String} color valid #RGB string, e.g., "#ff0000"
 * @param {Array} startPos [x, y] the start position for the bezier curve
 * @param {Array} endPos [x, y] the end position for the bezier curve
 * @param {Array} ct1Pos [x, y] position of the first control point
 * @param {Array} ct2Pos [x, y] position of the second control point
 * @param {Number} width of the bezier curve, defaults to 1
 */
exports.bezierCurve = function(surface, color, startPos, endPos, ct1Pos, ct2Pos, width) {
   if (!startPos || !(startPos instanceof Array)) {
      throw new Error('[bezier_curve] startPos must be defined!');
   }
   if (!endPos || !(endPos instanceof Array)) {
      throw new Error('[bezier_curve] endPos must be defined!');
   }
   if (!ct1Pos || !(ct1Pos instanceof Array)) {
      throw new Error('[bezier_curve] ct1Pos must be defined!');
   }
   if (!ct2Pos || !(ct2Pos instanceof Array)) {
      throw new Error('[bezier_curve] ct2Pos must be defined!');
   }
   var ctx = surface.context;
   ctx.save();
   ctx.fillStyle = ctx.strokeStyle = color;
   ctx.lineWidth = width || 1;

   ctx.beginPath();
   ctx.moveTo(startPos[0], startPos[1]);
   ctx.bezierCurveTo(ct1Pos[0], ct1Pos[1], ct2Pos[0], ct2Pos[1], endPos[0], endPos[1]);
   ctx.stroke();

   ctx.restore();
};

/**
 * Returns a new surface which holds this surface rotate by angle degrees.
 * Unless rotating by 90 degree increments, the image will be padded larger to hold the new size.
 * @param {angel} angle Clockwise angle by which to rotate
 * @returns {Surface} new, rotated surface
 */
Surface.prototype.rotate = function (angle) {
   var origSize = this.getSize();
   var radians = (angle * Math.PI / 180);
   var newSize = origSize;
   // find new bounding box
   if (angle % 360 !== 0) {
      var rect = this.getRect();
      var points = [
         [-rect.width/2, rect.height/2],
         [rect.width/2, rect.height/2],
         [-rect.width/2, -rect.height/2],
         [rect.width/2, -rect.height/2]
      ];
      var rotPoints = points.map(function(p) {
         return vectors.rotate(p, radians);
      });
      var xs = rotPoints.map(function(p) { return p[0]; });
      var ys = rotPoints.map(function(p) { return p[1]; });
      var left = Math.min.apply(Math, xs);
      var right = Math.max.apply(Math, xs);
      var bottom = Math.min.apply(Math, ys);
      var top = Math.max.apply(Math, ys);
      newSize = [right-left, top-bottom];
   }
   var newSurface = new Surface(newSize);
   var m = matrix.translate(this._matrix, origSize[0]/2, origSize[1]/2);
   m = matrix.rotate(m, radians);
   m = matrix.translate(m, -origSize[0]/2, -origSize[1]/2);
   var offset = [(newSize[0] - origSize[0]) / 2, (newSize[1] - origSize[1]) / 2];
   newSurface.context.save();
   newSurface.context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
   newSurface.blit(this, offset);
   newSurface.context.restore();
   return newSurface;
};

/**
 * Returns a new surface holding the scaled surface.
 * @param {Array} dimensions new [width, height] of surface after scaling
 * @returns {Surface} new, scaled surface
 */
Surface.prototype.scale = function(dims) {
   var width = dims[0];
   var height = dims[1];
   if (width <= 0 || height <= 0) {
      throw new Error('[gamejs.transform.scale] Invalid arguments for height and width', [width, height]);
   }
   var oldDims = this.getSize();
   var ws = width / oldDims[0];
   var hs = height / oldDims[1];
   var newSurface = new Surface([width, height]);
   var originalMatrix = this._matrix.slice(0);
   var m = matrix.scale(matrix.identity(), [ws, hs]);
   newSurface.context.save();
   newSurface.context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
   newSurface.blit(this);
   newSurface.context.restore();
   return newSurface;
};

/**
 * Flip a Surface either vertically, horizontally or both. This returns
 * a new Surface (i.e: nondestructive).
 * @param {Boolean} flipHorizontal
 * @param {Boolean} flipVertical
 * @returns {Surface} new, flipped surface
 */
Surface.prototype.flip = function(flipHorizontal, flipVertical) {
   var dims = this.getSize();
   var newSurface = new Surface(dims);
   var scaleX = 1;
   var scaleY = 1;
   var xPos = 0;
   var yPos = 0;
   if (flipHorizontal === true) {
      scaleX = -1;
      xPos = -dims[0];
   }
   if (flipVertical === true) {
      scaleY = -1;
      yPos = -dims[1];
   }
   newSurface.context.save();
   newSurface.context.scale(scaleX, scaleY);
   newSurface.context.drawImage(this.canvas, xPos, yPos);
   newSurface.context.restore();
   return newSurface;
};


/**
 * Directly copy values from an array into a Surface.
 *
 * This is faster than blitting the `surface` property on a SurfaceArray
 *
 * The array must be the same dimensions as the Surface and will completely
 * replace all pixel values.
 * @param {gamejs.graphics.Surface} surface
 * @param {gamejs.graphics.Surfacearray.SurfaceArray} surfaceArray
 */
exports.blitArray = function(surface, surfaceArray) {
   surface.context.putImageData(surfaceArray.imageData, 0, 0);
   return;
};

/**
 * Fast pixel access. The SurfaceArray can be constructed with a surface whose values
 * are then used to initialize the pixel array.
 *
 * The surface passed as argument is not modified by the SurfaceArray.
 *
 * If an array is used to construct SurfaceArray, the array must describe
 * the dimensions of the SurfaceArray [width, height].
 *
 * @example
 *
 *   // create array from display surface
 *   var srfArray = new SurfaceArray(display);
 *   // direct pixel access
 *   srfArray.set(50, 100, [255, 0, 0, 100]);
 *   console.log(srfArray.get(30, 50));
 *   // blit modified array back to display surface
 *   blitArray(display, srfArray);
 *
 * @param {gamejs.graphics.Surface|Array} surfaceOrDimensions
 * @see http://dev.w3.org/html5/2dcontext/#pixel-manipulation
 */
var SurfaceArray = exports.SurfaceArray = function(surfaceOrDimensions) {
   var size = null;
   var data = null;
   var imageData = null;

   /**
    * Set rgba value at position x, y.
    *
    * For performance reasons this function has only one signature
    * being Number, Number, Array[4].
    *
    * @param {Number} x x position of pixel
    * @param {Number} y y position of pixel
    * @param {Array} rgba [red, green, blue, alpha] values [255, 255, 255, 255] (alpha, the last argument defaults to 255)
    * @throws Error if x, y out of range
    */
   this.set = function(x, y, rgba) {
      var offset = (x * 4) + (y * size[0] * 4);
      /** faster without
      if (offset + 3 >= data.length || x < 0 || y < 0) {
         throw new Error('x, y out of range', x, y);
      }
      **/
      data[offset] = rgba[0];
      data[offset+1] = rgba[1];
      data[offset+2] = rgba[2];
      data[offset+3] = rgba[3] === undefined ? 255 : rgba[3];
      return;
   };

   /**
    * Get rgba value at position xy,
    * @param {Number} x
    * @param {Number} y
    * @returns {Array} [red, green, blue, alpha]
    */
   this.get = function(x, y) {
      var offset = (x * 4) + (y * size[0] * 4);
      return [
         data[offset],
         data[offset+1],
         data[offset+2],
         data[offset+3]
      ];
   };

   /**
    * a new gamejs.graphics.Surface on every access, representing
    * the current state of the SurfaceArray.
    * @type {gamejs.graphics.Surface}
    */
   // for jsdoc only
   this.surface = null;

   objects.accessors(this, {
      surface: {
         get: function() {
            var s = new gamejs.graphics.Surface(size);
            s.context.putImageData(imageData, 0, 0);
            return s;
         }
      },
      imageData: {
         get: function() {
            return imageData;
         }
      }
   });

   this.getSize = function() {
      return size;
   };

   /**
    * constructor
    */
   if (surfaceOrDimensions instanceof Array) {
      size = surfaceOrDimensions;
      imageData = gamejs.display.getSurface().context.createImageData(size[0], size[1]);
      data = imageData.data;
   } else {
      size = surfaceOrDimensions.getSize();
      imageData = surfaceOrDimensions.getImageData(0, 0, size[0], size[1]);
      data = imageData.data;
   }
   return this;
};

},{"../gamejs":8,"./math/matrix":20,"./math/vectors":23,"./utils/objects":32}],15:[function(require,module,exports){
/**
 * @fileoverview Make synchronous http requests to your game's serverside component.
 *
 * If you configure a ajax base URL you can make http requests to your
 * server using those functions.

 * The most high-level functions are `load()` and `save()` which take
 * and return a JavaScript object, which they will send to / recieve from
 * the server-side in JSON format.
 *
 *
 */

/**
 * Response object returned by http functions `get` and `post`. This
 * class is not instantiable.
 *
 * @param{String} responseText
 * @param {String} responseXML
 * @param {Number} status
 * @param {String} statusText
 */
exports.Response = function() {
   /**
    * @param {String} header
    */
   this.getResponseHeader = function(header)  {
   };
   throw new Error('response class not instantiable');
};

/**
 * Make http request to server-side
 * @param {String} method http method
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @return {Response} response
 */
var ajax = exports.ajax = function(method, url, data, type) {
   data = data || null;
   var response = new XMLHttpRequest();
   response.open(method, url, false);
   if (type) {
      response.setRequestHeader("Accept", type);
   }
   if (data instanceof Object) {
      data = JSON.stringify(data);
      response.setRequestHeader('Content-Type', 'application/json');
   }
   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
   response.send(data);
   return response;
};

/**
 * Make http GET request to server-side
 * @param {String} url
 */
var get = exports.get = function(url) {
   return ajax('GET', url);
};

/**
 * Make http POST request to server-side
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @returns {Response}
 */
var post = exports.post = function(url, data, type) {
   return ajax('POST', url, data, type);
};

function stringify(response) {
   /* jshint ignore:start */
   return eval('(' + response.responseText + ')');
   /* jshint ignore:end */
}

function ajaxBaseHref() {
    return (window.$g && window.$g.ajaxBaseHref) || './';
}

/**
 * Load an object from the server-side.
 * @param {String} url
 * @return {Object} the object loaded from the server
 */
exports.load = function(url) {
   return stringify(get(ajaxBaseHref() + url));
};

/**
 * Send an object to a server-side function.
 * @param {String} url
 * @param {String|Object} data
 * @param {String|Object} type "Accept" header value
 * @returns {Object} the response object
 */
exports.save = function(url, data, type) {
   return stringify(post(ajaxBaseHref() + url, {payload: data}, type));
};

},{}],16:[function(require,module,exports){
var gamejs = require('../gamejs');

/**
 * @fileoverview Load images as Surfaces.
 *
 * Sounds & Images are loaded relative to your game's html page
 * (the html which includes the GameJs code) or relative to the
 * property `window.$g.resourceBaseHref`
 * if it is set.
 *
 *
 */

var CACHE = {};

/**
 * need to export preloading status for require
 * @ignore
 */
var _PRELOADING = false;

/**
 * Load image and return it on a Surface.
 *
 * All images must be preloaded before they can be used.
 * @example

 *     gamejs.preload(["./images/ship.png", "./images/sunflower.png"]);
 *     // ...later...
 *     display.blit(gamejs.image.load('images/ship.png'))
 *
 * @param {String|dom.Image} uriOrImage resource uri for image
 * @returns {gamejs.graphics.Surface} surface with the image on it.
 */
exports.load = function(key) {
   var img;
   if (typeof key === 'string') {
      img = CACHE[key];
      if (!img) {
			throw new Error('Missing "' + key + '", gamejs.preload() all images before trying to load them.');
      }
   } else {
      img = key;
   }
   var canvas = document.createElement('canvas');
   // IEFIX missing html5 feature naturalWidth/Height
   canvas.width = img.naturalWidth || img.width;
   canvas.height = img.naturalHeight || img.height;
   var context = canvas.getContext('2d');
   context.drawImage(img, 0, 0);
   img.getSize = function() { return [img.naturalWidth, img.naturalHeight]; };
   var surface = new gamejs.graphics.Surface(img.getSize());
   // NOTE hack setting protected _canvas directly
   surface._canvas = canvas;
   surface._context = context;
   return surface;
};


/**
 * add all images on the currrent page into cache
 * @ignore
 */
exports.init = function() {
   return;
};

/**
 * preload the given img URIs
 * @returns {Function} which returns 0-1 for preload progress
 * @ignore
 */
exports.preload = function(imgIdents) {

   var countLoaded = 0;
   var countTotal = 0;

   function incrementLoaded() {
      countLoaded++;
      if (countLoaded == countTotal) {
         _PRELOADING = false;
      }
      if (countLoaded % 10 === 0) {
         gamejs.logging.debug('gamejs.image: preloaded  ' + countLoaded + ' of ' + countTotal);
      }
   }

   function getProgress() {
      return countTotal > 0 ? countLoaded / countTotal : 1;
   }

   function successHandler() {
      addToCache(this);
      incrementLoaded();
   }
   function errorHandler() {
      incrementLoaded();
      throw new Error('Error loading ' + this.src);
   }

   var key;
   for (key in imgIdents) {
      var lowerKey = key.toLowerCase();
      if (lowerKey.indexOf('.png') == -1 &&
            lowerKey.indexOf('.jpg') == -1 &&
            lowerKey.indexOf('.jpeg') == -1 &&
            lowerKey.indexOf('.svg') == -1 &&
            lowerKey.indexOf('.gif') == -1) {
         continue;
      }
      var img = new Image();
      img.addEventListener('load', successHandler, true);
      img.addEventListener('error', errorHandler, true);
      img.src = imgIdents[key];
      img.gamejsKey = key;
      countTotal++;
   }
   if (countTotal > 0) {
      _PRELOADING = true;
   }
   return getProgress;
};

/**
 * add the given <img> dom elements into the cache.
 * @private
 */
var addToCache = function(img) {
   CACHE[img.gamejsKey] = img;
   return;
};

},{"../gamejs":8}],17:[function(require,module,exports){

/**
 * @fileoverview Static methods for logging and setting the log level. All logging functions (`info()`, `debug()`, etc.) take
 * any number of arguments and will print them in one line.
 *
 */

var DEBUG_LEVELS = ['debug', 'info', 'warn', 'error', 'fatal'];
var debugLevel = 2;
var gamejs = require('../gamejs');

/**
 * set logLevel as string or number
 *   * 0 = info
 *   * 1 = warn
 *   * 2 = error
 *   * 3 = fatal
 *
 * @example
 * gamejs.setLogLevel(0); // debug
 * gamejs.setLogLevel('error'); // equal to setLogLevel(2)
 */
exports.setLogLevel = function(logLevel) {
   if (typeof logLevel === 'string' && DEBUG_LEVELS.indexOf(logLevel)) {
      debugLevel = DEBUG_LEVELS.indexOf(logLevel);
   } else if (typeof logLevel === 'number') {
      debugLevel = logLevel;
   } else {
      throw new Error('invalid logLevel ', logLevel, ' Must be one of: ', DEBUG_LEVELS);
   }
   return debugLevel;
};

/**
 * Log a msg to the console if console is enable
 * @param {String} message,... the msg to log
 */
var log = exports.log = function() {

   if (gamejs.thread.inWorker === true) {
      gamejs.thread._logMessage.apply(null, arguments);
      return;
   }

   // IEFIX can't call apply on console
   var args = Array.prototype.slice.apply(arguments, [0]);
   args.unshift(Date.now());
   if (window.console !== undefined && console.log.apply) {
      console.log.apply(console, args);
   }
};
/**
 * @param {String} message,... to log
 */
exports.debug = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('debug')) {
      log.apply(this, arguments);
   }
};
/**
 * @param {String} message,... to log
 */
exports.info = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('info')) {
      log.apply(this, arguments);
   }
};
/**
 * @param {String} message,... to log
 */
exports.warn = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('warn')) {
      log.apply(this, arguments);
   }
};
/**
 * @param {String} message,... to log
 */
exports.error = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('error')) {
      log.apply(this, arguments);
   }
};
/**
 * @param {String} message to log
 */
exports.fatal = function() {
   if (debugLevel <= DEBUG_LEVELS.indexOf('fatal')) {
      log.apply(this, arguments);
   }
};

},{"../gamejs":8}],18:[function(require,module,exports){
/**
 * @fileoverview Degrees and radians.
 *
 */

/**
 *
 * absolute angle to relative angle, in degrees
 * @param {Number} absolute angle in degrees
 * @returns {Number} relative angle in degrees
 */
exports.normaliseDegrees=function(degrees){
    degrees=degrees % 360;
    if(degrees<0) {
        degrees+=360;
    }
    return degrees;
};

/**
 *
 * absolute angle to relative angle, in radians
 * @param {Number} absolute angle in radians
 * @returns {Number} relative angle in radians
 */
exports.normaliseRadians=function(radians){
    radians=radians % (2*Math.PI);
    if(radians<0) {
        radians+=(2*Math.PI);
    }
    return radians;
};

/**
 *
 * convert radians to degrees
 * @param {Number} radians
 * @returns {Number} degrees
 */
exports.degrees=function(radians) {
    return radians*(180/Math.PI);
};

/**
 *
 * convert degrees to radians
 * @param {Number} degrees
 * @returns {Number} radians
 */
exports.radians=function(degrees) {
    return degrees*(Math.PI/180);
};

},{}],19:[function(require,module,exports){
/**
 * @fileoverview Binary Heap implementation from Eloquent JavaScript
 *
 * @see http://eloquentjavascript.net/appendix2.html
 */
var BinaryHeap = exports.BinaryHeap = function(scoreFunction){
   /**
    * @ignore
    */
   this.content = [];
   /**
    * @ignore
    */
   this.scoreFunction = scoreFunction;
   return this;
};

/**
 * Add element to heap.
 * @param {Object} element
 */
BinaryHeap.prototype.push = function(element) {
   this.content.push(element);
   this.sinkDown(this.content.length - 1);
   return;
};

/**
 * Return first element from heap.
 * @param {Object} element
 * @returns {Object} element
 */
BinaryHeap.prototype.pop = function() {
   // Store the first element so we can return it later.
   var result = this.content[0];
   // Get the element at the end of the array.
   var end = this.content.pop();
   // If there are any elements left, put the end element at the
   // start, and let it bubble up.
   if (this.content.length > 0) {
      this.content[0] = end;
      this.bubbleUp(0);
   }
   return result;
};

/**
 * Remove the given element from the heap.
 * @param {Object} element
 * @throws {Error} if node not found
 * @returns true if the node was round and removed or fals otherwise
 */
BinaryHeap.prototype.remove = function(node) {
   // To remove a value, we must search through the array to find
   // it.
   var isFound = this.content.some(function(cNode, idx) {
      if (cNode == node) {
         var end = this.content.pop();
         if (idx != this.content.length) {
            this.content[idx] = end;
            if (this.scoreFunction(end) < this.scoreFunction(node)) {
               this.sinkDown(idx);
            } else {
               this.bubbleUp(idx);
            }
         }
         return true;
      }
      return false;
   }, this);
   return isFound;
};

/**
 * Number of elements in heap.
 */
BinaryHeap.prototype.size = function() {
   return this.content.length;
};

/**
 * @ignore
 */
BinaryHeap.prototype.sinkDown = function(idx) {
   // Fetch the element that has to be sunk
   var element = this.content[idx];
   // When at 0, an element can not sink any further.
   while (idx > 0) {
      // Compute the parent element's index, and fetch it.
      var parentIdx = Math.floor((idx + 1) / 2) - 1;
      var parent = this.content[parentIdx];
      // Swap the elements if the parent is greater.
      if (this.scoreFunction(element) < this.scoreFunction(parent)) {
         this.content[parentIdx] = element;
         this.content[idx] = parent;
         // Update 'n' to continue at the new position.
         idx = parentIdx;
      // Found a parent that is less, no need to sink any further.
      } else {
         break;
      }
   }
   return;
};

/**
 * @ignore
 */
BinaryHeap.prototype.bubbleUp = function(idx) {
   // Look up the target element and its score.
   var length = this.content.length;
   var element = this.content[idx];
   var elemScore = this.scoreFunction(element);

   while(true) {
      // Compute the indices of the child elements.
      var child2Idx = (idx + 1) * 2;
      var child1Idx= child2Idx - 1;
      // This is used to store the new position of the element,
      // if any.
      var swapIdx = null;
      // If the first child exists (is inside the array)...
      var child1Score;
      if (child1Idx < length) {
         // Look it up and compute its score.
         var child1 = this.content[child1Idx];
         child1Score = this.scoreFunction(child1);
         // If the score is less than our element's, we need to swap.
         if (child1Score < elemScore) {
            swapIdx = child1Idx;
         }
      }
      // Do the same checks for the other child.
      if (child2Idx < length) {
         var child2 = this.content[child2Idx];
         var child2Score = this.scoreFunction(child2);
         if (child2Score < (swapIdx === null ? elemScore : child1Score)) {
            swapIdx = child2Idx;
         }
      }

      // If the element needs to be moved, swap it, and continue.
      if (swapIdx !== null) {
         this.content[idx] = this.content[swapIdx];
         this.content[swapIdx] = element;
         idx = swapIdx;
      // Otherwise, we are done.
      } else {
         break;
      }
   }
   return;
};

},{}],20:[function(require,module,exports){
/**
 * @fileoverview Matrix manipulation, used by GameJs itself. You
 * probably do not need this unless you manipulate a Context's transformation
 * matrix yourself.
 */

// correct way to do scale, rotate, translate
// *  gamejs.utils.matrix will be used in gamejs.transforms, modifing the surfaces.matrix
// * this matrix must be applied to the context in Surface.draw()

/**
 * @returns {Array} [1, 0, 0, 1, 0, 0]
 */
var identiy = exports.identity = function () {
   return [1, 0, 0, 1, 0, 0];
};

/**
 * @param {Array} matrix
 * @param {Array} matrix
 * @returns {Array} matrix sum
 */
var add = exports.add = function(m1, m2) {
   return [
      m1[0] + m2[0],
      m1[1] + m2[1],
      m1[2] + m2[2],
      m1[3] + m2[3],
      m1[4] + m2[4],
      m1[5] + m2[5],
      m1[6] + m2[6]
   ];
};

/**
 * @param {Array} matrix A
 * @param {Array} matrix B
 * @returns {Array} matrix product
 */
var multiply = exports.multiply = function(m1, m2) {
   return [
      m1[0] * m2[0] + m1[2] * m2[1],
      m1[1] * m2[0] + m1[3] * m2[1],
      m1[0] * m2[2] + m1[2] * m2[3],
      m1[1] * m2[2] + m1[3] * m2[3],
      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
   ];
};

/**
 * @param {Array} matrix
 * @param {Number} dx
 * @param {Number} dy
 * @returns {Array} translated matrix
 */
var translate = exports.translate = function(m1, dx, dy) {
   return multiply(m1, [1, 0, 0, 1, dx, dy]);
};

/**
 * @param {Array} matrix
 * @param {Number} angle in radians
 * @returns {Array} rotated matrix
 */
var rotate = exports.rotate = function(m1, angle) {
   // radians
   var sin = Math.sin(angle);
   var cos = Math.cos(angle);
   return multiply(m1, [cos, sin, -sin, cos, 0, 0]);
};

/**
 * @param {Array} matrix
 * @returns {Number} rotation in radians
 */
var rotation = exports.rotation = function(m1) {
      return Math.atan2(m1[1], m1[0]);
};

/**
 * @param {Array} matrix
 * @param {Array} vector [a, b]
 * @returns {Array} scaled matrix
 */
var scale = exports.scale = function(m1, svec) {
   var sx = svec[0];
   var sy = svec[1];
   return multiply(m1, [sx, 0, 0, sy, 0, 0]);
};

},{}],21:[function(require,module,exports){
/**
 * @fileoverview
 * A noise generator comparable to Perlin noise, which is useful
 * for generating procedural content.
 *
 * This implementation provides 2D and 3D noise:
 *
 *    var simplex = new Simplex();
 *    simplex.get(2, 4);
 *    simple.get3d(1, 2, 4);
 *
 * You can optionally
 * pass a seedable pseudo-random number generator to its constructor. This
 * generator object is assumed to have a `random()` method; `Math` is used
 * per default:
 *
 *     var Alea = require('gamejs/math/random').Alea;
 *     var simplex = new Simplex(new Alea());
 *
 * Also see `gamejs/math/random` for a seedable pseudo random number generator
 *
 * @see gamejs/utils/prng
 */

// Ported to JS by by zz85 <https://github.com/zz85> from Stefan
// Gustavson's java implementation
// <http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf>
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com

/**
 * @param {Object} randomNumberGenerator the random number generator to use; most provide `random()` method
 * @usage
 *  var simplex = new gamejs.noise.Simplex();
 *  simplex.get(x, y);
 *  // or for 3d noise
 *  simple.get(x, y, y);
 */

var Simplex = exports.Simplex = function(r) {
  if (r === undefined) {
    r = Math;
  }
  /** @ignore */
  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
               [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
               [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
  /** @ignore */
  this.p = [];
  var i;
  for (i=0; i<256; i++) {
   this.p[i] = Math.floor(r.random()*256);
  }
  // To remove the need for index wrapping, double the permutation table length
  /** @ignore */
  this.perm = [];
  for(i=0; i<512; i++) {
    this.perm[i]=this.p[i & 255];
  }

  // A lookup table to traverse the simplex around a given point in 4D.
  // Details can be found where this table is used, in the 4D noise method.
  /** @ignore */
  this.simplex = [
    [0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],
    [0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],
    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],
    [1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],
    [1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],
    [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],
    [2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],
    [2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];
};

/** @ignore */
Simplex.prototype.dot = function(g, x, y) {
   return g[0]*x + g[1]*y;
};

/**
 * @param {Number} x
 * @param {Number} y
 * @returns {Number} noise for given position, in range [-1, 1]
 */
Simplex.prototype.get = function(xin, yin) {
  var n0, n1, n2; // Noise contributions from the three corners
  // Skew the input space to determine which simplex cell we're in
  var F2 = 0.5*(Math.sqrt(3.0)-1.0);
  var s = (xin+yin)*F2; // Hairy factor for 2D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var G2 = (3.0-Math.sqrt(3.0))/6.0;
  var t = (i+j)*G2;
  var X0 = i-t; // Unskew the cell origin back to (x,y) space
  var Y0 = j-t;
  var x0 = xin-X0; // The x,y distances from the cell origin
  var y0 = yin-Y0;
  // For the 2D case, the simplex shape is an equilateral triangle.
  // Determine which simplex we are in.
  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
  else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)
  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
  // c = (3-sqrt(3))/6
  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
  var y1 = y0 - j1 + G2;
  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
  var y2 = y0 - 1.0 + 2.0 * G2;
  // Work out the hashed gradient indices of the three simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var gi0 = this.perm[ii+this.perm[jj]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
  // Calculate the contribution from the three corners
  var t0 = 0.5 - x0*x0-y0*y0;
  if(t0<0) {
    n0 = 0.0;
  } else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
  }
  var t1 = 0.5 - x1*x1-y1*y1;
  if(t1<0) {
    n1 = 0.0;
  } else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
  }
  var t2 = 0.5 - x2*x2-y2*y2;
  if(t2<0) {
    n2 = 0.0;
  } else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to return values in the interval [-1,1].
  return 70.0 * (n0 + n1 + n2);
};


/**
 * @param {Number} x
 * @param {Number} y
 * @param {Number} y
 * @returns {Number} noise for given position, in range [-1, 1]
 */
Simplex.prototype.get3d = function(xin, yin, zin) {
  var n0, n1, n2, n3; // Noise contributions from the four corners
  // Skew the input space to determine which simplex cell we're in
  var F3 = 1.0/3.0;
  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var k = Math.floor(zin+s);
  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too
  var t = (i+j+k)*G3;
  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space
  var Y0 = j-t;
  var Z0 = k-t;
  var x0 = xin-X0; // The x,y,z distances from the cell origin
  var y0 = yin-Y0;
  var z0 = zin-Z0;
  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
  // Determine which simplex we are in.
  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
  if(x0>=y0) {
    if(y0>=z0)
      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order
      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order
      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order
    }
  else { // x0<y0
    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order
    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order
    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order
  }
  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
  // c = 1/6.
  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
  var y1 = y0 - j1 + G3;
  var z1 = z0 - k1 + G3;
  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords
  var y2 = y0 - j2 + 2.0*G3;
  var z2 = z0 - k2 + 2.0*G3;
  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords
  var y3 = y0 - 1.0 + 3.0*G3;
  var z3 = z0 - 1.0 + 3.0*G3;
  // Work out the hashed gradient indices of the four simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var kk = k & 255;
  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12;
  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12;
  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12;
  // Calculate the contribution from the four corners
  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
  if(t0<0) {
    n0 = 0.0;
  } else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
  }
  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
  if(t1<0) {
    n1 = 0.0;
  } else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
  }
  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
  if(t2<0) {
    n2 = 0.0;
  } else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
  }
  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
  if(t3<0) {
    n3 = 0.0;
  } else {
    t3 *= t3;
    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to stay just inside [-1,1]
  return 32.0*(n0 + n1 + n2 + n3);
};

},{}],22:[function(require,module,exports){
/**
 * @fileoverview A seedable random-number generator.
 *
 * A generator is initialized by GameJs and can be used with the
 * static functions of this module:
 *
 *    gamejs.random.choose([1,2,4]);
 *    // integet between and including 2 and 5
 *    gamejs.random.integer(2, 5);
 *
 * You can re-initialize this generator with a different seed by
 * calling `gamejs.utils.prng.init(seed)` after which the static
 * functions in this module will use the new seed.
 *
 * @usage
 *  var prng = require('gamejs/math/random');
 *  prng.random(); // 0.6765871671959758
 *  prng.integer(2, 10); // 5
 *  prng.choose([1,2,3,4,5]); // 3
 */
// From http://baagoe.com/en/RandomMusings/javascript/
// Johannes Baagøe <baagoe@baagoe.com>, 2010
// API modified by Simon Oberhammer <simon@nekapuzer.at>, 2012
// discussion of the used algorithms <http://baagoe.org/en/w/index.php/Better_random_numbers_for_javascript>


/** @ignore **/
var Mash = function Mash() {
  var n = 0xefc8249d;
  this.hash = function(data) {
    data = data.toString();
    var i;
    for (i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  this.version = 'Mash 0.9';
  return this;
};

/**
 * A seedable pseudo-random number generator.
 * @param {Number|String} seed the seed for generating the numbers
 *
 * @usage
 *  var prng = require('gamejs/math/random');
 *  var seed = 'gamejs';
 *  var alea = new prng.Alea(seed);
 *  alea.random(); // 0.6765871671959758
 *  alea.random(); // 0.15881546027958393
 *
 *  // generator with the same seed will generate the same sequence
 *  // of numbers:
 *  var aleaTwo = new prng.Alea(seed);
 *  aleaTwo.random(); // 0.6765871671959758
 *  aleaTwo.random(); // 0.15881546027958393
 */
var Alea = exports.Alea = function Alea() {
   var args = Array.prototype.slice.call(arguments);
   var s0 = 0;
   var s1 = 0;
   var s2 = 0;
   var c = 1;
   if (args.length === 0 || !args[0]) {
     args = [Date.now()];
   }
   var mash = new Mash();
   s0 = mash.hash(' ');
   s1 = mash.hash(' ');
   s2 = mash.hash(' ');

   var i;
   for (i = 0; i < args.length; i++) {
     s0 -= mash.hash(args[i]);
     if (s0 < 0) {
       s0 += 1;
     }
     s1 -= mash.hash(args[i]);
     if (s1 < 0) {
       s1 += 1;
     }
     s2 -= mash.hash(args[i]);
     if (s2 < 0) {
       s2 += 1;
     }
   }
   mash = null;

   /**
    * @returns {Number} the next random number as determined by the seed
    */
   this.random = function() {
     var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
     s0 = s1;
     s1 = s2;
     s2 = t - (c = t | 0);
     return s2;
   };
   this.integer = function(min, max) {
     return min + parseInt(this.random() * (max-min+1), 10);
   };
   this.vector = function(min, max) {
      return [this.integer(min[0], max[0]), this.integer(min[1], max[1])];
   };
   this.choose = function(items) {
      return items[this.integer(0, items.length-1)];
   };
   return this;
};

// alea instance per gamejs instance
var alea = null;

/**
 * @param {Number} min
 * @param {Number} max
 * @returns {Number} random integer between min and max
 */
var integer = exports.integer = function(min, max){
    return alea.integer(min, max);
};

/**
 * @param {Array} minVector 2 integers, the minimum vector
 * @param {Array} maxVector 2 integers, the maximum vector
 * @returns {Array} a random vector [min[0]<=x<=max[0], min[1]<=y<=max[1]]
 */
exports.vector = function(min, max){
    return alea.vector(min, max);
};

/**
 * @param {Array} items
 * @returns {Object} random item from items list
 */
exports.choose = function(items){
    return alea.choose(items);
};

/**
 * @returns {Number} next random float between 0 and 1
 */
exports.random = function() {
  return alea.random();
};

/**
 * Re-initialize the per instance random number generator used
 * in the static functions on this module (e.g. vector())
 * @param {Number|String} seed
 */
exports.init = function(seed) {
  alea = new Alea(seed);
};
},{}],23:[function(require,module,exports){
/**
 * Vector operations.

 */
var angles = require('./angles');

/**
 * @param {Array} origin point [b0, b1]
 * @param {Array} target point [b0, b1]
 * @returns {Number} distance between two points
 */
exports.distance = function(a, b) {
   return len(subtract(a, b));
};

/**
 * subtracts vectors [a0, a1] - [a0, a1]
 * @param {Array} a
 * @param {Array} b
 * @returns {Array} vector
 */
var subtract = exports.subtract = function(a, b) {
   return [a[0] - b[0], a[1] - b[1]];
};

/**
 * adds vectors [a0, a1] - [a0, a1]
 * @param {Array} a vector
 * @param {Array} b vector
 * @returns {Array} vector
 */
var add = exports.add = function(a, b) {
   return [a[0] + b[0], a[1] + b[1]];
};

/**
 * multiply vector with scalar or other vector
 * @param {Array} vector [v0, v1]
 * @param {Number|Array} vector or number
 * @returns {Number|Array} result
 */
var multiply = exports.multiply = function(a, s) {
   if (typeof s === 'number') {
      return [a[0] * s, a[1] * s];
   }

   return [a[0] * s[0], a[1] * s[1]];
};

/**
 * @param {Array} a vector
 * @param {Number} s
 */
exports.divide = function(a, s) {
   if (typeof s === 'number') {
      return [a[0] / s, a[1] / s];
   }
   throw new Error('only divide by scalar supported');
};

/**
 * @param {Array} vector [v0, v1]
 * @returns {Number} length of vector
 */
var len = exports.len = function(v) {
   return Math.sqrt(v[0]*v[0] + v[1]*v[1]);
};

/**
 *
 * normalize vector to unit vector
 * @param {Array} vector [v0, v1]
 * @returns {Array} unit vector [v0, v1]
 */
var unit = exports.unit = function(v) {
   var l = len(v);
   if(l) {
      return [v[0] / l, v[1] / l];
   }
   return [0, 0];
};

/**
 *
 * rotate vector
 * @param {Array} vector [v0, v1]
 * @param {Number} angle to rotate vector by, radians. can be negative
 * @returns {Array} rotated vector [v0, v1]
 */
exports.rotate=function(v, angle){
   angle=angles.normaliseRadians(angle);
   return [v[0]* Math.cos(angle)-v[1]*Math.sin(angle),
           v[0]* Math.sin(angle)+v[1]*Math.cos(angle)];

};

/**
 *
 * calculate vector dot product
 * @param {Array} vector [v0, v1]
 * @param {Array} vector [v0, v1]
 * @returns {Number} dot product of v1 and v2
 */
var dot = exports.dot=function(v1, v2){
   return (v1[0] * v2[0]) + (v1[1] * v2[1]);
};

/**
 *
 * calculate angle between vectors
 * @param {Array} vector [v0, v1]
 * @param {Array} vector [v0, v1]
 * @returns {Number} angle between v1 and v2 in radians
 */
exports.angle=function(v1, v2){
   var perpDot = v1[0] * v2[1] - v1[1] * v2[0];
   return Math.atan2(perpDot, dot(v1,v2));
};

/**
 * @returns {Array} vector with max length as specified.
 */
exports.truncate = function(v, maxLength) {
   if (len(v) > maxLength) {
      return multiply(unit(v), maxLength);
   }
   return v;
};


/**
 * @returns the center of multipled 2d points
 * @param {Array} first point
 * @param {Array} second point
 * @param {Array} ...
 */
exports.centroid = function() {
   var args = Array.prototype.slice.apply(arguments, [0]);
   var c = [0,0];
   args.forEach(function(p) {
      c[0] += parseInt(p[0], 10);
      c[1] += parseInt(p[1], 10);
   });
   var len = args.length;
   return [
      c[0] / len,
      c[1] / len
   ];
};

},{"./angles":18}],24:[function(require,module,exports){
/**
 * @fileoverview
 * A* path finding algorithm
 *
 * Use the `findRoute(map, from, to, [timeout])` function to get the linked list
 * leading `from` a point `to` another on the given `map`.
 *
 * The map must implement the interface `gamejs.pathfinding.Map`. This
 * class already holds an example implementation for debugging use.
 *
 * Optionally, the search is cancelled after `timeout` in millseconds.
 *
 * If there is no route `null` is returned.
 *
 * @see http://en.wikipedia.org/wiki/A*_search_algorithm
 * @see http://eloquentjavascript.net/chapter7.html
 */
var BinaryHeap = require('./math/binaryheap').BinaryHeap;

/**
 * helper function for A*
 */
function ReachedList(hashFn) {
   var list = {};

   this.store = function(point, route) {
      list[hashFn(point)] = route;
      return;
   };

   this.find = function(point) {
      return list[hashFn(point)];
   };
   return this;
}


/** A* search function.
 *
 * This function expects a `Map` implementation and the origin and destination
 * points given. If there is a path between the two it will return the optimal
 * path as a linked list. If there is no path it will return null.
 *
 * The linked list is in reverse order: the first item is the destination and
 * the path to the origin follows.
 *
 * @param {Map} map map instance, must follow interface defined in {Map}
 * @param {Array} origin
 * @param {Array} destination
 * @param {Number} timeout milliseconds after which search should be canceled
 * @returns {Object} the linked list leading from `to` to `from` (sic!).
 **/
exports.findRoute = function(map, from, to, timeout) {
   var open = new BinaryHeap(routeScore);
   var hashFn = typeof map.hash === 'function' ? map.hash : defaultHash;
   var reached = new ReachedList(hashFn);

   function routeScore(route) {
      if (route.score === undefined) {
         route.score = map.estimatedDistance(route.point, to) + route.length;
      }
      return route.score;
   }
   function addOpenRoute(route) {
      open.push(route);
      reached.store(route.point, route);
   }

   function processNewPoints(direction) {
      var known = reached.find(direction);
      var newLength = route.length + map.actualDistance(route.point, direction);
      if (!known || known.length > newLength){
         if (known) {
            open.remove(known);
         }
         addOpenRoute({
            point: direction,
            from: route,
            length: newLength
         });
      }
   }
   var startMs = Date.now();
   var route = null;
   addOpenRoute({
      point: from,
      from: null,
      length: 0
   });
   var equalsFn = typeof map.equals === 'function' ? map.equals : defaultEquals;
   while (open.size() > 0 && (!timeout || Date.now() - startMs < timeout)) {
      route = open.pop();
      if (equalsFn(to, route.point)) {
         return route;
      }
      map.adjacent(route.point).forEach(processNewPoints);
   } // end while
   return null;
};

var defaultEquals = function(a, b) {
   return a[0] === b[0] && a[1] === b[1];
};

var defaultHash = function(a) {
   return a[0] + '-' + a[1];
};

/**
 * This is the interface for a Map that can be passed to the `findRoute()`
 * function. `Map` is not instantiable - see the unit tests for an example
 * implementation of Map.
 */
var Map = exports.Map = function() {
   throw new Error('not instantiable, this is an interface');
};

/**
 * @param {Array} origin
 * @returns {Array} list of points accessible from given Point
 */
Map.prototype.adjacent = function(origin) {
};

/**
 * @param {Object} a one of the points ot test for equality
 * @param {Object} b ... the other point
 * @returns Wheter the two points are equal.
 */
Map.prototype.equals = defaultEquals;

/**
 * @param {Object} a point
 * @returns {String} hash for the point
 */
Map.prototype.hash = defaultHash;

/**
 * Estimated lower bound distance between two points.
 * @param {Object} pointA
 * @param {Object} pointB
 * @returns {Number} the estimated distance between two points
 */
Map.prototype.estimatedDistance = function(pointA, pointB) {
   return 1;
};

/**
 * Actual distance between two points.
 * @param {Object} pointA
 * @param {Object} pointB
 * @returns {Number} the actual distance between two points
 */
Map.prototype.actualDistance = function(pointA, pointB) {
   return 1;
};

},{"./math/binaryheap":19}],25:[function(require,module,exports){
var gamejs = require('../gamejs');
var objects = require('./utils/objects');

/**
 * @fileoverview Image mask. Usefull for pixel perfect collision detection:
 *
 * @example
 * var unitMask = new Maks(unitSurface, collisionThresholdAlphaValue);
 * var spearMask = new Maks(unitSurface, collisionThresholdAlphaValue);
 * var collide = unitMask.overlap(spearMask);
 */


/**
 * Creates an image mask from the given Surface. The alpha of each pixel is checked
 * to see if it is greater than the given threshold. If it is greater then
 * that pixel is set as not colliding.
 *
 * @param {Surface} surface used for image mask
 * @param {Number} threshold 0 to 255. defaults to: 255, fully transparent
 *
 */
var Mask = exports.Mask = function(surface, threshold) {
   /**
    * @ignore
    */
   this._bits = [];

   threshold = (threshold && (255 - threshold)) || 255;
   var imgData = surface.getImageData().data;
   var dims = surface.getSize();
   /**
    * @ignore
    */
   this.width = dims[0];
   /**
    * @ignore
    */
   this.height = dims[1];

   var i,j;
   for (i=0;i<this.width;i++) {
      this._bits[i] = [];
      for (j=0;j<this.height;j++) {
         this._bits[i][j] = false;
      }
   }
   for (i=0;i<imgData.length;i += 4) {
      // y: pixel # / width
      var y = parseInt((i / 4) / dims[0], 10);
      // x: pixel # % width
      var x = parseInt((i / 4) % dims[0], 10);
      var alpha = imgData[i+3];
      if (alpha >= threshold) {
         this.setAt(x, y);
      }
   }
   return;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns the overlapping rectangle or null if there is no overlap;
 */
Mask.prototype.overlapRect = function(otherMask, offset) {
   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }
   // bounding box intersect
   if (!brect.collideRect(arect)) {
      return null;
   }
   var xStart = Math.max(arect.left, brect.left);
   var xEnd = Math.min(arect.right, brect.right);

   var yStart = Math.max(arect.top, brect.top);
   var yEnd = Math.min(arect.bottom, brect.bottom);

   return new gamejs.Rect([xStart, yStart], [xEnd - xStart, yEnd - yStart]);
};

/**
 *
 * @returns True if the otherMask overlaps with this map.
 * @param {Mask} otherMask
 * @param {Array} offset
 */
Mask.prototype.overlap = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return false;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var count = 0;
   var x,y;
   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             return true;
         }
      }
   }
   // NOTE this should not happen because either we bailed out
   // long ago because the rects do not overlap or there is an
   // overlap and we should not have gotten this far.
   // throw new Error("Maks.overlap: overlap detected but could not create mask for it.");
   return false;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns the number of overlapping pixels
 */
Mask.prototype.overlapArea = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return 0;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var count = 0;
   var x,y;
   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             count++;
         }
      }
   }
   return count;
};

/**
 * @param {gamejs.mask.Mask} otherMask
 * @param {Array} offset [x,y]
 * @returns a mask of the overlapping pixels
 */
Mask.prototype.overlapMask = function(otherMask, offset) {
   var overlapRect = this.overlapRect(otherMask, offset);
   if (overlapRect === null) {
      return 0;
   }

   var arect = this.rect;
   var brect = otherMask.rect;
   if (offset) {
      brect.moveIp(offset);
   }

   var mask = new Mask(new gamejs.graphics.Surface([overlapRect.width, overlapRect.height]));
   var x,y;
   for (y=overlapRect.top; y<=overlapRect.bottom; y++) {
      for (x=overlapRect.left; x<=overlapRect.right; x++) {
         if (this.getAt(x - arect.left, y - arect.top) &&
             otherMask.getAt(x - brect.left, y - brect.top)) {
             mask.setAt(x, y);
         }
      }
   }
   return mask;
};

/**
 * Set bit at position.
 * @param {Number} x
 * @param {Number} y
 */
Mask.prototype.setAt = function(x, y) {
   this._bits[x][y] = true;
};

/**
 * Get bit at position.
 *
 * @param {Number} x
 * @param {Number} y
 */
Mask.prototype.getAt = function(x, y) {
   x = parseInt(x, 10);
   y = parseInt(y, 10);
   if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
      return false;
   }
   return this._bits[x][y];
};


/**
 * Flip the bits in this map.
 */
Mask.prototype.invert = function() {
   this._bits = this._bits.map(function(row) {
      return row.map(function(b) {
         return !b;
      });
   });
};

/**
 * @returns {Array} the dimensions of the map
 */
Mask.prototype.getSize = function() {
   return [this.width, this.height];
};

objects.accessors(Mask.prototype, {
   /**
    * Rect of this Mask.
    */
   'rect': {
      get: function() {
         return new gamejs.Rect([0, 0], [this.width, this.height]);
      }
   },
   /**
    * @returns {Number} number of set pixels in this mask.
    */
   'length': {
      get: function() {
         var c = 0;
         this._bits.forEach(function(row) {
            row.forEach(function(b) {
               if (b) {
                  c++;
               }
            });
         });
         return c;
      }
   }
});

},{"../gamejs":8,"./utils/objects":32}],26:[function(require,module,exports){
var gamejs = require('../gamejs');
var uri = require('./utils/uri');
var Callback = require('./utils/callback').Callback;

/**
 * ignore
 */
var _EVENTS = exports._EVENTS = {
   RESULT: 1001,
   ALIVE: 1002,
   LOG: 1004
};

/**
 * @fileoverview
 *
 * gamejs.worker makes it more convinient to work with W3C WebWorkers by providing a way to run
 * CommonJs modules inside of them. GameJs also provides the typically `gamejs.ready()` and
 * event loop to facilitate communication between workers and the main application.
 *
 * See the `examples/workers` directory for a running example.
 *
 * Create a worker with the main module "foo-worker" (see below for how the worker's module looks like):
 *
 *     var fooWorker = new Worker('./foo-worker');
 *     // Send a message to your worker.
 *     // The Message doesn't have to be a string but it
 *     // must be `JSON.stringify()`-able
 *     fooWorker.post("foobar");
 *
 * You can also recieve messages from the worker:
 *
 *     // recieve events from the worker
 *     fooWorker.onEvent(function(event) {
 *         if(event.timestamp > ...)
 *      });
 *
 * And this is how the above referenced "foo-worker" module would looke like. As usual, we need a
 * `gamejs.ready()` to get started and within that we bind an event handler:
 *
 *     var gamejs = require('gamejs');
 *     gamejs.ready(function() {
 *         gamejs.event.onEvent(function(event) {
 *              var plaintext = fastCrack(event.password)
 *              ....
 *          });
 *     });
 *
 * Our event worker could do expensive calculations (seperate and not blocking the main game) when
 * recieving an event. Once the result is caculated, it can be sent back to the main application
 * with `gamejs.thread.post()`:
 *
 *     gamejs.thread.post({
 *        info: "important message from worker",
 *        timestamp: 12232435234
 *      });
 *
 * The main application would in turn recieve an event posted like this from `fooWorker.onEvent`, as seen above.
 *
 * This module is useful for expensive algorithms where the result does not have to available instantiously
 * (e.g., path-finding) or for continous logic which can be
 * calculated seperately from the rendering loop, and which only needs to feed back into the model of the rendering every
 * now and then (e.g. physics) The main draw back of the `Worker` model is that
 * you can only communicate with them via text messages (typically JSON.stringify()ed messages).
 */

/**
 * true if this GameJs instance is being executed within a WebWorker
 * @type Boolean
 */
var inWorker = exports.inWorker = (this.importScripts !== undefined);

/**
 * executed in scope of worker
 * @ignore
 */
exports._ready = function() {
   self.onmessage = function(event) {
      gamejs.event._triggerCallbacks(event.data);
   };
   self.postMessage({
     type: _EVENTS.ALIVE
   });
};

/**
 * Send an event back to the main script.
 * @param {Object} data to be sent back to main script
 */
exports.post = function(data) {
  if (inWorker) {
    self.postMessage({
       type: _EVENTS.RESULT,
       data: data
    });
  } else {
    throw new Error('gamejs.postMessage only available in a thread/worker module');
  }
};

/**
 * Send message to main context for logging
 * @ignore
 **/
exports._logMessage = function() {
   var args = [];
   Array.prototype.forEach.call(arguments, function(a) {
     args.push(a);
   });
   self.postMessage({
      type: _EVENTS.LOG,
      arguments: args
   });
};


/**
  * executed in scope of worker before user's main module
  * @ignore
  */
var workerPrefix = function workerPrefix() {
   __scripts.forEach(function(script) {
      try {
         importScripts(script);
      } catch (e) {
         // can't help the worker
      }
   });
};

/**
 * Setup a worker which has `require()` defined
 * @ignore
 **/
var create = function(workerModuleId) {
   var moduleRoot = uri.resolve(document.location.href, window.require.getModuleRoot());
   var initialScripts = [];
   Array.prototype.slice.apply(document.getElementsByTagName('script'), [0]).forEach(function(script) {
      if (script.src) {
         initialScripts.push(script.src);
      }
   });

   var URL = window.URL || window.webkitURL;
   var prefixString = workerPrefix.toString();
   // don't be afraid...
   prefixString = prefixString.substring(prefixString.indexOf("{") + 1, prefixString.lastIndexOf("}"));
   var blob = new Blob([
      'var __scripts = ["' + initialScripts.join('","') + '"];',
      prefixString,
      ';self.require.setModuleRoot("' + moduleRoot + '");',
      'self.require.run("'+ workerModuleId +'");'
   ], {type: 'application\/javascript'});

   var blobURL = URL.createObjectURL(blob);
   return new Worker(blobURL);
};

/**
 * The `Worker` constructor takes only one argument: a module id. This module
 * will be executed inside the newly created Worker. It is effectively the
 * main module of the Worker.
 *
 * Inside a Worker, you can use `require()` to import other scripts or
 * GameJs modules.
 *
 * **Note:** A Worker does not have access to the browser's `document`. So
 * a lot of GameJs modules - everything related to drawing to the canvas -
 * do not work in the Worker.
 *
 * You can use `gamejs.time.*`, `gamejs.utils.*`, `gamejs.event.*` and probably others
 * (as well as any module you write yourself for this purpose, of course).
 *
 * @param {String} moduleId The Worker's main module id. The main module will be executed in the worker
 */
exports.Worker = function(moduleId) {
   // FIXME id should be unchangeable
   /**
    * Unique id of this worker
    * @property {Number}
    */
   var id = this.id = guid(moduleId);
   var worker = create(moduleId);
   var deadQueue = [];
   var alive = false;
   var self  = this;
   var _CALLBACKS = [];
   var _ERROR_CALLBACKS = [];

   function triggerCallbacks(callbacks, event) {
      callbacks.forEach(function(c) {
         c.trigger(event);
      });
   }

   worker.onmessage = function(event) {
      if (event.data.type === _EVENTS.ALIVE) {
         // if worker says he is alive -> send him the event queue so far
         alive = true;
         deadQueue.forEach(function(data) {
            self.post(data);
         });
      } else if (event.data.type === _EVENTS.LOG) {
         gamejs.logging.log.apply(null, [id].concat(event.data.arguments));
      } else {
         triggerCallbacks(_CALLBACKS, event.data.data);
      }
   };
   worker.onerror = function(event) {
      gamejs.logging.error('Error in worker "' + id + '" line ' + event.lineno + ': ', event.message);
      triggerCallbacks(_ERROR_CALLBACKS, {
         data: event.data,
         worker: self,
         event: event
      });
   };

   this.onEvent = function(fn, scope) {
      _CALLBACKS.push(new Callback(fn, scope));
   };

   this.onError = function(fn, scope) {
      _ERROR_CALLBACKS.push(new Callback(fn, scope));
   };

   /**
    * Send a message to the worker
    *
    * @param {Object} data Payload object which gets sent to the Worker
    */
   this.post = function(data) {
      if (alive) {
         worker.postMessage(data);
      } else {
         deadQueue.push(data);
      }
   };
   return this;
};

/**
 * not a real GUID
 * @ignore
 */
function guid(moduleId) {
   var S4 = function() {
      return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
   };
   return moduleId + '@' + (S4()+S4());
}
},{"../gamejs":8,"./utils/callback":31,"./utils/uri":34}],27:[function(require,module,exports){
var gamejs = require('../gamejs');
var objects = require('./utils/objects');
var xml = require('./utils/xml');
var base64 = require('./utils/base64');
var uri = require('./utils/uri');

/**
 * @fileoverview
 * This is a loader for the general purpose tile map editor "Tiled".
 *
 * This module can load all ".tmx" files even if additionally base64 encoded
 * (can be configured in Tiled).
 *
 * This module loads the whole map definition, including the TileSets with
 * all necessary images. For an example on how to render a map loaded with
 * this module, see `examples/tiledmap`.
 *
 * You will typically create a Map instance with `Map(url)` and deal
 * with the layers, tilesets, etc. through the Map instance
 * instead of loading & creating them yourself.
 *
 * Only orthogonol maps are supported (no isometric maps).
 *
 * @see http://www.mapeditor.org/
 * @see https://github.com/bjorn/tiled/wiki/TMX-Map-Format
 */

/**
 * My code is inspired by:
 *   * https://bitbucket.org/maikg/tiled2cocos/
 *   * https://github.com/obiot/melonJS/
 *
 */

/**
 * A Tiled Map holds all layers defined in the tmx file as well
 * as the necessary tiles to render the map.
 * @param {String} url Relative or absolute URL to the tmx file
 */
var Map = exports.Map = function(url) {

   url = uri.resolve(document.location.href, url);
   var xmlDoc = xml.Document.fromURL(url);
   var mapNode = xmlDoc.element('map');

   /**
    * Width of a single tile in pixels
    * @type Number
    */
   this.tileWidth = mapNode.attribute('tilewidth');
   /**
    * Height of a single tile in pixels
    * @type Number
    */
   this.tileHeight = mapNode.attribute('tileheight');
   /**
    * Width of the map in tiles
    * @type Number
    */
   this.width = mapNode.attribute('width');
   /**
    * Height of the map in tiles
    * @type Number
    */
   this.height = mapNode.attribute('height');

   var orientation = mapNode.attribute('orientation');
   if (orientation !== 'orthogonal') {
      throw new Error('only orthogonol maps supported');
   }

   /**
    * Custom properties of the map
    */
   this.properties = {};
   setProperties(this.properties, mapNode);

   /**
    * All tiles of this map.
    * @type {TileSet}
    */
   this.tiles = new TileSets(mapNode, url);
   this.layers = loadLayers(mapNode);
   return this;
};

/**
 * A Tile. Can not be instantiated. Get a Tile by calling `getTile(gid)`
 * on a `TileSets` instance.
 */
var Tile = exports.Tile = function() {
   /**
    * @type {gamejs.graphics.Surface}
    */
   this.surface = null;
   /**
    * @type {Object}
    */
   this.properties = null;
   throw new Error('Can not be instantiated.');
};

/**
 * A TileSets instance holds all tilesets of a map. This class
 * makes it easy to get the image for a certain tile ID. You usually
 * don't care about in which specific TileSet an image is so this
 * class holds them all and deals with the lookup.
 *
 * You don't usually create a `TileSets` instance yourself, instead
 * it is automatically created and attached to a `Map`.
 */
var TileSets = exports.TileSets = function(mapNode, mapUrl) {
   var tileSets = [];

   /**
    * Retrieve the image for a tile ID (gid).
    *
    * @param {Number} gid global tile id to retrieve
    * @returns {gamejs.graphics.Surface} the Surface for the gid
    */
   this.getSurface = function(gid) {
      var tile = this.getTile(gid);
      return tile && tile.surface || null;
   };

   /**
    * @param {Number} gid global tile id
    * @returns {Object} the custom properties of this tile
    */
   this.getProperties = function(gid) {
      var tile = this.getTile(gid);
      return tile && tile.properties || {};
   };

   /**
    * @param {Number} gid global tile id
    * @returns {Object} the Tile object for this gid
    */
   this.getTile = function(gid) {
      var tile = null;
      tileSets.some(function(tileSet, idx) {
         if (tileSet.firstGid <= gid) {
            tile = tileSet.tiles[gid - tileSet.firstGid];
            return true;
         }
         return false;
      }, this);
      return tile;
   };

   var loadTileSet = function(tileSetNode) {
      var tiles = [];
      var tileWidth = tileSetNode.attribute('tilewidth');
      var tileHeight = tileSetNode.attribute('tileheight');
      var spacing = tileSetNode.attribute('spacing') || 0;
      // broken in tiled?
      var margin = 0;

      var imageNode = tileSetNode.element('image');
      var imageAtlasFile = imageNode.attribute('source');
      var imageUrl = uri.makeRelative(uri.resolve(mapUrl, imageAtlasFile));
      var atlas = gamejs.image.load(imageUrl);
      // FIXME set transparency if imageNode.attribute('trans') is set

      var tileNodes = tileSetNode.elements('tile');
      var dims = atlas.getSize();
      var imgSize = new gamejs.Rect([0,0], [tileWidth, tileHeight]);
      var idx = 0;
      var y = 0;
      while (y + tileHeight <= dims[1]) {
         var x = 0;
         while (x + tileWidth <= dims[0]) {
            var tileImage = new gamejs.graphics.Surface(tileWidth, tileHeight);
            var rect = new gamejs.Rect([x, y], [tileWidth, tileHeight]);
            tileImage.blit(atlas, imgSize, rect);
            var tileProperties = {};
            /* jshint ignore:start */
            // function within loop
            tileNodes.some(function(tileNode) {
               if (tileNode.attribute('id') === idx) {
                  setProperties(tileProperties, tileNode);
                  return true;
               }
            }, this);
            /* jshint ignore:end */
            tiles.push({
               surface: tileImage,
               properties: tileProperties
            });
            x += tileWidth + spacing;
            idx++;
         }
         y += tileHeight + spacing;
      }
      return tiles;
   };

   /**
    *
    * constructor
    **/
   mapNode.elements('tileset').forEach(function(tileSetNode) {
      var firstGid = tileSetNode.attribute('firstgid');
      var externalSource = tileSetNode.attribute('source');
      if (externalSource) {
         var tileSetDocument = xml.Document.fromURL(uri.resolve(mapUrl, externalSource));
         tileSetNode = tileSetDocument.element('tileset');
      }
      tileSets.push({
         tiles: loadTileSet(tileSetNode),
         firstGid: firstGid
      });
   });
   tileSets.reverse();

   return this;
};

/**
 * loadLayers
 */
var H_FLIP = 0x80000000;
var V_FLIP = 0x40000000;
var loadLayers = function(mapNode) {
   var layers = [];

   var getGids = function(layerNode) {
      var dataNode = layerNode.element('data');
      var encoding = dataNode.attribute('encoding');
      var compression = dataNode.attribute('compression');
      var data = "";
      dataNode.children().forEach(function(textNode) {
         data += textNode.value();
      });
      var byteData = [];
      if (encoding === 'base64') {
         if (compression) {
            throw new Error('Compression of map data unsupported');
         }
         byteData = base64.decodeAsArray(data, 4);
      } else if (encoding === 'csv') {
         data.trim().split('\n').forEach(function(row) {
            row.split(',', width).forEach(function(entry) {
               byteData.push(parseInt(entry, 10));
            });
         });
      } else {
         // FIXME individual XML tile elements
         throw new Error('individual tile format not supported');
      }
      return byteData;
   };

   var width = mapNode.attribute('width');
   var height = mapNode.attribute('height');
   mapNode.elements('layer').forEach(function(layerNode) {
      // create empty gid matrix
      var gidMatrix = [];
      var i = height;
      while (i-->0) {
         var j = width;
         gidMatrix[i] = [];
         while (j-->0) {
            gidMatrix[i][j] = 0;
         }
      }

      getGids(layerNode).forEach(function(gid, idx) {
         // FIXME flipX/Y currently ignored
         var flipX = gid & H_FLIP;
         var flipY = gid & V_FLIP;
         // clear flags
         gid &= ~(H_FLIP | V_FLIP);
         gidMatrix[parseInt(idx / width, 10)][parseInt(idx % width, 10)] = gid;
      });
      layers.push({
         gids: gidMatrix,
         opacity: layerNode.attribute('opacity'),
         visible: layerNode.attribute('visible'),
         properties: setProperties({}, layerNode)
      });
   });
   return layers;
};

/**
 * set generic <properties><property name="" value="">... on given object
 */
var setProperties = function(object, node) {
   var props = node.element('properties');
   if (!props) {
      return;
   }
   props.elements('property').forEach(function(propertyNode) {
      var name = propertyNode.attribute('name');
      var value = propertyNode.attribute('value');
      object[name] = value;
   });
   return object;
};


/**
 * FIXME explain viewRect (change it to sroll!) and image, mapImage and how to update, redraw
 */
var MapView = exports.MapView = function(map) {

    this.timeout = 0;

    this.layerViews = map.layers.map(function(layer) {
      return new LayerView(layer, {
         tileWidth: map.tileWidth,
         tileHeight: map.tileHeight,
         width: map.width,
         height: map.height,
         tiles: map.tiles
      });
    });
    this.viewRect = new gamejs.Rect([0,0], [map.width * map.tileWidth, map.height*map.tileWidth]);
    this.image = new gamejs.graphics.Surface([this.viewRect.width, this.viewRect.height]);
    this.mapImage = this.image.clone();
    this.redraw();
    return this;
};

MapView.prototype.redraw = function() {
    this.layerViews.forEach(function(layer) {
        layer.draw(this.mapImage);
    }, this);
};

MapView.prototype.draw = function(display, offset) {
  display.blit(this.mapImage, offset || [0,0], this.viewRect);
};



/**
 * LayerView
 * Renders the layer to a big surface.
 */
var LayerView = exports.LayerView = function(layer, opts) {

   this.draw = function(display) {
      display.blit(this.surface);
   };
   /**
    * constructor
    */
   this.surface = new gamejs.graphics.Surface(opts.width * opts.tileWidth, opts.height * opts.tileHeight);
   this.surface.setAlpha(layer.opacity);

   /**
    * Note how below we look up the "gid" of the tile images in the TileSet from the Map
    * ('opt.tiles') to get the actual Surfaces.
    */
   layer.gids.forEach(function(row, i) {
      row.forEach(function(gid, j) {
         if (gid ===0) {
            return;
         }

         var tileSurface = opts.tiles.getSurface(gid);
         if (tileSurface) {
            this.surface.blit(tileSurface,
               new gamejs.Rect([j * opts.tileWidth, i * opts.tileHeight], [opts.tileWidth, opts.tileHeight])
            );
         } else {
            gamejs.log('no gid ', gid, i, j, 'layer', i);
         }
      }, this);
   }, this);
   return this;
};


},{"../gamejs":8,"./utils/base64":30,"./utils/objects":32,"./utils/uri":34,"./utils/xml":35}],28:[function(require,module,exports){
/**
 * @fileoverview
 * Only used by GameJs internally to provide a game loop.
 * @ignore
 */

var Callback = require('./utils/callback').Callback;

var TIMER_LASTCALL = null;
var STARTTIME = null;

/** @ignore **/
var _CALLBACKS = exports._CALLBACKS = [];
// `window` is not accessible in webworker (would lead to TypeError)
// @@ this cross-browser fuckery has to go away ASAP.
var reqAnimationFrame = typeof(window) != 'undefined' ?
                        window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        null : null;

var reqAniFrameRecursive = function() {
   perInterval();
   reqAnimationFrame(reqAniFrameRecursive);
};

var triggerCallbacks = function(msDuration) {
   _CALLBACKS.forEach(function(c) {
      c.trigger(msDuration);
   });
};

/**
 * @ignore
 */
exports.init = function() {
   STARTTIME = Date.now();

   if (reqAnimationFrame) {
      reqAnimationFrame(reqAniFrameRecursive);
   } else {
      setInterval(perInterval, 10);
   }
   return;
};

var perInterval = function() {
   var msNow = Date.now();
   triggerCallbacks(msNow - (TIMER_LASTCALL || msNow));
   TIMER_LASTCALL = msNow;
   return;
};

},{"./utils/callback":31}],29:[function(require,module,exports){
/**
 * @fileoverview Utility functions for working with Obiects
 * @param {Object} item
 * @param {Array} array
 * @param {Object} returns removed item or null
 */

exports.remove = function(item, array) {
   var index = array.indexOf(item);
   if (index !== -1) {
      return array.splice(array.indexOf(item), 1);
   }
   return null;
};

/**
 * Shuffles the array *in place*.
 * @see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
 */
exports.shuffle = function(array) {
    var len = array.length -1;
    for (var i = len; i > 0; i--) {
        var idx = parseInt(Math.random() * (i + 1), 10);
        var item = array[i];
        array[i] = array[idx];
        array[idx] = item;
    }
    return array;
};

},{}],30:[function(require,module,exports){
/**
 * @fileoverview
 * Base64 encode / decode
 * @author http://www.webtoolkit.info
 */


var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * Decodes a base64 encoded string to a string.
 */
var decode = exports.decode = function(input) {
   var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
   input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

   while (i < input.length) {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));

      chr1 = (enc1 << 2) | (enc2 >> 4);
      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      chr3 = ((enc3 & 3) << 6) | enc4;

      output.push(String.fromCharCode(chr1));

      if (enc3 != 64) {
         output.push(String.fromCharCode(chr2));
      }
      if (enc4 != 64) {
         output.push(String.fromCharCode(chr3));
      }
   }

   output = output.join('');
   return output;
};

/**
 * Decodes a base64 encoded string into a byte array
 * @param {String} input
 * @param {Array} bytes bytes per character, defaults to 1
 */
exports.decodeAsArray = function(input, bytes) {
   bytes = bytes || 1;
   var decoded = decode(input);
   var len = decoded.length / bytes;
   var array = [];
   var i,j;
   for (i=0; i< len; i++) {
      array[i] = 0;
      for (j = bytes - 1; j >=0; --j) {
         array[i] += decoded.charCodeAt((i * bytes) + j) << (j <<3 );
      }
   }
   return array;
}
;
},{}],31:[function(require,module,exports){
/**
 * @fileoverview
 * Manage a callback with invocation scope. This is used internally by GameJs but might be useful for others.
 */

/**
 * @param {Function} callback
 * @param {Object} scope with which the callback will be triggered
 */
var Callback = exports.Callback = function(fn, scope) {
	this.fn = fn;
	this.fnScope = scope || {};
	return this;
};
/**
 * Any arguments passed to `trigger` will be passed to the callback.
 */
Callback.prototype.trigger = function() {
	this.fn.apply(this.fnScope, arguments);
};
},{}],32:[function(require,module,exports){
/**
 * @fileoverview Utility functions for working with Objects
 */

/**
 * Put a prototype into the prototype chain of another prototype.
 * @param {Object} subClass
 * @param {Object} superClass
 */
exports.extend = function(subClass, superClass) {
   if (subClass === undefined) {
      throw new Error('unknown subClass');
   }
   if (superClass === undefined) {
      throw new Error('unknown superClass');
   }
   var F;
   /* jshint ignore:start */
   F = new Function();
   /* jshint ignore:start */
   F.prototype = superClass.prototype;
   /* jshint ignore:end */
   subClass.prototype = new F();
   subClass.prototype.constructor = subClass;
   subClass.superClass = superClass.prototype;
   subClass.superConstructor = superClass;
   return;
};

/**
 * Creates a new object as the as the keywise union of the provided objects.
 * Whenever a key exists in a later object that already existed in an earlier
 * object, the according value of the earlier object takes precedence.
 * @param {Object} obj... The objects to merge
 */
exports.merge = function() {
   var result = {};
   var i, property;
      for (i = arguments.length; i > 0; --i) {
         var obj = arguments[i - 1];
         for (property in obj) {
            result[property] = obj[property];
         }
      }
   return result;
};

/**
 * fallback for Object.keys
 * @param {Object} obj
 * @returns {Array} list of own properties
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
 */
var keys = exports.keys = function(obj) {
   if (Object.keys) {
      return Object.keys(obj);
   }

   var ret=[],p;
   for (p in obj) {
      if(Object.prototype.hasOwnProperty.call(obj, p)) {
         ret.push(p);
      }
   }
   return ret;
};

/**
 * Create object accessors
 * @param {Object} object The object on which to define the property
 * @param {String} name name of the property
 * @param {Function} get
 * @param {Function} set
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperty
 */
var accessor = exports.accessor = function(object, name, get, set) {
   // ECMA5
   if (Object.defineProperty !== undefined) {
      Object.defineProperty(object, name, {
         get: get,
         set: set
      });
   // non-standard
   } else if (Object.prototype.__defineGetter__ !== undefined) {
      object.__defineGetter__(name, get);
      if (set) {
         object.__defineSetter__(name, set);
      }
   }
	return;
};

/**
 * @param {Object} object The object on which to define or modify properties.
 * @param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.
 * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/defineProperties
 */
exports.accessors = function(object, props) {
   keys(props).forEach(function(propKey) {
      accessor(object, propKey, props[propKey].get, props[propKey].set);
   });
   return;
};

},{}],33:[function(require,module,exports){
/**
 * @fileoverview Working with strings
 */

/**
 * Get the longest common segment that two strings
 * have in common, starting at the beginning of the string
 * @param {String} str1 a string
 * @param {String} str2 another string
 * @returns {String} the longest common segment
 */
exports.getCommonPrefix = function getCommonPrefix(str1, str2) {
    if (str1 === null || str2 === null) {
        return null;
    } else if (str1.length > str2.length && str1.indexOf(str2) === 0) {
        return str2;
    } else if (str2.length > str1.length && str2.indexOf(str1) === 0) {
        return str1;
    }
    var length = Math.min(str1.length, str2.length);
    var i;
    for (i = 0; i < length; i++) {
        if (str1[i] != str2[i]) {
            return str1.slice(0, i);
        }
    }
    return str1.slice(0, length);
};
},{}],34:[function(require,module,exports){
/**
 * @fileoverview Utilies for URI handling.
 *
 */

var URI_REGEX = new RegExp(
    '^' +
    '(?:' +
      '([^:/?#.]+)' +                     // scheme - ignore special characters
                                          // used by other URL parts such as :,
                                          // ?, /, #, and .
    ':)?' +
    '(?://' +
      '(?:([^/?#]*)@)?' +                 // userInfo
      '([\\w\\d\\-\\u0100-\\uffff.%]*)' + // domain - restrict to letters,
                                          // digits, dashes, dots, percent
                                          // escapes, and unicode characters.
      '(?::([0-9]+))?' +                  // port
    ')?' +
    '([^?#]+)?' +                         // path
    '(?:\\?([^#]*))?' +                   // query
    '(?:#(.*))?' +                        // fragment
    '$');

/**
 * Resolve path against URI.
 *
 * @param {String} uri
 * @param {String} path to resolve
 */
var resolve = exports.resolve = function(uri, path) {
   var m = match(uri);
   var n = match(path);
   var host = m[1] + '://' + m[3];
   if (n[1]) {
      return path;
   }
   if (m[4]) {
      host = host + ":" + m[4];
   }
   var absolutePath = m[5];
   if (path.charAt(0) !== '/') {
      var lastSlashIndex = absolutePath.lastIndexOf('/');
      absolutePath = absolutePath.substr(0, lastSlashIndex + 1) + path;
   } else {
      absolutePath = path;
   }
   return host + removeDotSegments(absolutePath);

};

/**
 * Try to match an URI against a regex returning the following
 * capture groups:
 *     $1 = http              scheme
 *     $2 = <undefined>       userInfo -\
 *     $3 = www.ics.uci.edu   domain     | authority
 *     $4 = <undefined>       port     -/
 *     $5 = /pub/ietf/uri/    path
 *     $6 = <undefined>       query without ?
 *     $7 = Related           fragment without #
 *
 * @param {String} uri
 */
var match = exports.match = function(uri) {
   return uri.match(URI_REGEX);
};

/**
 * Make an absolute URI relative to document.location.href
 * @param {String} uri
 * @returns The relative URI or the unchanged URI if it's not
 * possible to make it relative to the path of document.location.href.
 */
var makeRelative = exports.makeRelative = function(uri) {
   var docLocPath = resolve(document.location.href, './');
   if (uri.indexOf(docLocPath) === 0) {
      uri = './' + uri.substring(docLocPath.length);
   }
   return uri;
};

/**
 * Removes dot segments in given path component
 */
var removeDotSegments = function(path) {
   if (path == '..' || path == '.') {
      return '';
   }
   var leadingSlash = path.indexOf('/') > -1;

   var segments = path.split('/');
   var out = [];

   var pos;
   for (pos = 0; pos < segments.length; ) {
      var segment = segments[pos++];

      if (segment == '.') {
         if (leadingSlash && pos == segments.length) {
            out.push('');
         }
      } else if (segment == '..') {
         if (out.length > 1 || out.length !== 1 && out[0] !== '') {
            out.pop();
         }
         if (leadingSlash && pos == segments.length) {
            out.push('');
         }
      } else {
         out.push(segment);
         leadingSlash = true;
      }
   }
   return out.join('/');
};

},{}],35:[function(require,module,exports){
/**
 * @fileoverview
 *
 * Provides facilities for parsing a xml String.
 *
 * You will typically get a `gamejs.xml.Document` instance
 * by loading the data with one of the two static
 * `Document.fromString(string)` or `Document.fromUrl(url)`.

 * Querying for `elements(name)` or `children()` will return a
 * new `gamejs.xml.Document` matching your result (or null).
 *
 * Use `attributes(name)` and `value()` to get the data stored
 * in the XML Document.
 */

/**
 * XMLParser
 */
var Parser = exports.Parser = function() {

   var xmlDoc = null;
   var parser = new DOMParser();

   this.parseFromString = function(xmlString) {
      xmlDoc = parser.parseFromString(xmlString, 'text/xml');
      return xmlDoc;
   };

   return this;
};

/**
 * Instantiate with the static functions `Document.fromString()` and `fromURL()`.
 */
var Document = exports.Document = function(xmlDocument) {
   if (!xmlDocument || (!xmlDocument instanceof XMLDocument) ) {
      throw new Error('Need a valid xmlDocument.');
   }
   /** @ignore **/
   this._xmlDocument = xmlDocument;
   return this;
};

/**
 * Returns the first element in the current document whose tag-name matches
 * the given 'name'.
 * @returns gamejs.xml.Document
 */
Document.prototype.element = function(name) {
   var elem = this._xmlDocument.getElementsByTagName(name)[0];
   return elem && new Document(elem) || null;
};

/**
 * Returns all elements in the current document whose tag-name matches
 * the given 'name'.
 * @returns an Array of gamejs.xml.Document
 */
Document.prototype.elements = function(name) {
   var elems = this._xmlDocument.getElementsByTagName(name);
   return Array.prototype.slice.apply(elems, [0]).map(function(elem) {
      return new Document(elem);
   });
};

/**
 * Returns the attribute value of this document.
 *
 * @returns String
 */
Document.prototype.attribute = function(name) {
   var attributeValue = this._xmlDocument.getAttribute(name);
   attributeValue = attributeValue ? attributeValue.trim() : null;
   if (attributeValue === null) {
      return null;
   }
   if (attributeValue.toLowerCase() === 'true') {
      return true;
   }
   if (attributeValue.toLowerCase() === 'false') {
      return false;
   }
   var attributeIntValue = parseInt(attributeValue, 10);
   var attributeFloatValue = parseFloat(attributeValue, 10);
   if (!isNaN(attributeIntValue)) {
      if (attributeFloatValue !== attributeIntValue) {
         return attributeFloatValue;
      }
      return attributeIntValue;
   }
   return attributeValue;
};

/**
 * Returns the nodevalue of the current xml document
 * @returns String
 */
Document.prototype.value = function() {
   return this._xmlDocument.nodeValue;
};

/**
 * Returns all children of this xml document
 * @returns Array of gamejs.xml.Document
 */
Document.prototype.children = function() {
   return Array.prototype.slice.apply(this._xmlDocument.childNodes, [0]).map(function(cNode) {
      return new Document(cNode);
   });
};

/**
 * @returns gamejs.xml.Document
 */
Document.fromString = function(xmlString) {
   var parser = new DOMParser();
   var xmlDoc = parser.parseFromString(xmlString, 'text/xml');
   return new Document(xmlDoc);
};

/**
 * @returns gamejs.xml.Document
 */
Document.fromURL = function(url) {
   var response = new XMLHttpRequest();
   response.open('GET', url, false);
   response.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
   response.setRequestHeader('Content-Type', 'text/xml');
   response.overrideMimeType('text/xml');
   response.send();
   return new Document(response.responseXML);
};

},{}]},{},[3])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWt0b3IvRG9jdW1lbnRzL0RldmVsb3BtZW50L0pTL2dhbWUvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9hcHAvY29uZmlnLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9hcHAvY29udHJvbHMuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL2FwcC9mYWtlXzI4NjcyOGNiLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9hcHAvaGVscGVycy9zdHJpbmcuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL2FwcC9vYmplY3RzL21hbi5qcyIsIi9Vc2Vycy92aWt0b3IvRG9jdW1lbnRzL0RldmVsb3BtZW50L0pTL2dhbWUvYXBwL29iamVjdHMvbWFuL3N0YXRlcy5qcyIsIi9Vc2Vycy92aWt0b3IvRG9jdW1lbnRzL0RldmVsb3BtZW50L0pTL2dhbWUvYXBwL29iamVjdHMvbWFwLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9ub2RlX21vZHVsZXMvZ2FtZWpzL3NyYy9nYW1lanMuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy9hbmltYXRlLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9ub2RlX21vZHVsZXMvZ2FtZWpzL3NyYy9nYW1lanMvYXVkaW8uanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy9kaXNwbGF5LmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9ub2RlX21vZHVsZXMvZ2FtZWpzL3NyYy9nYW1lanMvZXZlbnQuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy9mb250LmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9ub2RlX21vZHVsZXMvZ2FtZWpzL3NyYy9nYW1lanMvZ3JhcGhpY3MuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy9odHRwLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9ub2RlX21vZHVsZXMvZ2FtZWpzL3NyYy9nYW1lanMvaW1hZ2UuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy9sb2dnaW5nLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9ub2RlX21vZHVsZXMvZ2FtZWpzL3NyYy9nYW1lanMvbWF0aC9hbmdsZXMuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy9tYXRoL2JpbmFyeWhlYXAuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy9tYXRoL21hdHJpeC5qcyIsIi9Vc2Vycy92aWt0b3IvRG9jdW1lbnRzL0RldmVsb3BtZW50L0pTL2dhbWUvbm9kZV9tb2R1bGVzL2dhbWVqcy9zcmMvZ2FtZWpzL21hdGgvbm9pc2UuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy9tYXRoL3JhbmRvbS5qcyIsIi9Vc2Vycy92aWt0b3IvRG9jdW1lbnRzL0RldmVsb3BtZW50L0pTL2dhbWUvbm9kZV9tb2R1bGVzL2dhbWVqcy9zcmMvZ2FtZWpzL21hdGgvdmVjdG9ycy5qcyIsIi9Vc2Vycy92aWt0b3IvRG9jdW1lbnRzL0RldmVsb3BtZW50L0pTL2dhbWUvbm9kZV9tb2R1bGVzL2dhbWVqcy9zcmMvZ2FtZWpzL3BhdGhmaW5kaW5nLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9ub2RlX21vZHVsZXMvZ2FtZWpzL3NyYy9nYW1lanMvcGl4ZWxjb2xsaXNpb24uanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy90aHJlYWQuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy90aWxlZG1hcC5qcyIsIi9Vc2Vycy92aWt0b3IvRG9jdW1lbnRzL0RldmVsb3BtZW50L0pTL2dhbWUvbm9kZV9tb2R1bGVzL2dhbWVqcy9zcmMvZ2FtZWpzL3RpbWUuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy91dGlscy9hcnJheXMuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy91dGlscy9iYXNlNjQuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy91dGlscy9jYWxsYmFjay5qcyIsIi9Vc2Vycy92aWt0b3IvRG9jdW1lbnRzL0RldmVsb3BtZW50L0pTL2dhbWUvbm9kZV9tb2R1bGVzL2dhbWVqcy9zcmMvZ2FtZWpzL3V0aWxzL29iamVjdHMuanMiLCIvVXNlcnMvdmlrdG9yL0RvY3VtZW50cy9EZXZlbG9wbWVudC9KUy9nYW1lL25vZGVfbW9kdWxlcy9nYW1lanMvc3JjL2dhbWVqcy91dGlscy9zdHJpbmdzLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9ub2RlX21vZHVsZXMvZ2FtZWpzL3NyYy9nYW1lanMvdXRpbHMvdXJpLmpzIiwiL1VzZXJzL3Zpa3Rvci9Eb2N1bWVudHMvRGV2ZWxvcG1lbnQvSlMvZ2FtZS9ub2RlX21vZHVsZXMvZ2FtZWpzL3NyYy9nYW1lanMvdXRpbHMveG1sLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZnVsbFNjcmVlbjogZmFsc2UsIC8vIEBUT0RPOiBpbXBsZW1lbnQgZnVsbCBzY3JlZW4gZWRpdGluZ1xuICAgIGltYWdlczoge1xuICAgICAgICBtYW46ICcuL2Fzc2V0cy9pbWFnZXMvY293Ym95LnBuZycsXG4gICAgICAgIG1hcDogJy4vYXNzZXRzL2ltYWdlcy90aWxlc2hlZXQucG5nJ1xuICAgIH0sXG4gICAgbWFwOiAnLi9hc3NldHMvaW1hZ2VzL2V4YW1wbGUudG14JyxcbiAgICBzaXplOiBbODAwLCA2MDBdLFxuICAgIHN0ZXA6IDFcbn07IiwidmFyIGdhbWVqcyA9IHJlcXVpcmUoJ2dhbWVqcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBDb250cm9scyhzdGVwKSB7XG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIENvbnRyb2xzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoa2V5LCBzdGF0ZSkge1xuXG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlIGdhbWVqcy5ldmVudC5LX1VQOlxuICAgICAgICAgICAgY2FzZSBnYW1lanMuZXZlbnQuS193OlxuICAgICAgICAgICAgICAgIHRoaXMudXAgPSBzdGF0ZTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnYW1lanMuZXZlbnQuS19SSUdIVDpcbiAgICAgICAgICAgIGNhc2UgZ2FtZWpzLmV2ZW50LktfZDpcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0gc3RhdGU7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZ2FtZWpzLmV2ZW50LktfRE9XTjpcbiAgICAgICAgICAgIGNhc2UgZ2FtZWpzLmV2ZW50LktfczpcbiAgICAgICAgICAgICAgICB0aGlzLmRvd24gPSBzdGF0ZTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnYW1lanMuZXZlbnQuS19MRUZUOlxuICAgICAgICAgICAgY2FzZSBnYW1lanMuZXZlbnQuS19hOlxuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IHN0YXRlO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENvbnRyb2xzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlZnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAnZG93bic7XG4gICAgICAgIHRoaXMubW92ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBDb250cm9scy5wcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy51cCAmJiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnRvcCA9IC10aGlzLnN0ZXAvMjtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ubGVmdCA9IHRoaXMuc3RlcC8yO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAnVXBSaWdodCc7XG4gICAgICAgICAgICB0aGlzLm1vdmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudXAgJiYgdGhpcy5sZWZ0KSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnRvcCA9IC10aGlzLnN0ZXAvMjtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ubGVmdCA9IC10aGlzLnN0ZXAvMjtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ1VwTGVmdCc7XG4gICAgICAgICAgICB0aGlzLm1vdmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZG93biAmJiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnRvcCA9IHRoaXMuc3RlcC8yO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5sZWZ0ID0gdGhpcy5zdGVwLzI7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICdEb3duUmlnaHQnO1xuICAgICAgICAgICAgdGhpcy5tb3ZlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRvd24gJiYgdGhpcy5sZWZ0KSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnRvcCA9IHRoaXMuc3RlcC8yO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5sZWZ0ID0gLXRoaXMuc3RlcC8yO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAnRG93bkxlZnQnO1xuICAgICAgICAgICAgdGhpcy5tb3ZlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnVwKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnRvcCA9IC10aGlzLnN0ZXA7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICdVcCc7XG4gICAgICAgICAgICB0aGlzLm1vdmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ubGVmdCA9IHRoaXMuc3RlcDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ1JpZ2h0JztcbiAgICAgICAgICAgIHRoaXMubW92ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kb3duKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnRvcCA9IHRoaXMuc3RlcDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ0Rvd24nO1xuICAgICAgICAgICAgdGhpcy5tb3ZlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxlZnQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ubGVmdCA9IC10aGlzLnN0ZXA7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICdMZWZ0JztcbiAgICAgICAgICAgIHRoaXMubW92ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbnRyb2xzO1xufSkoKTsiLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKSxcbiAgICBnYW1lanMgPSByZXF1aXJlKCdnYW1lanMnKSxcbiAgICBpbWFnZXMgPSBbXSxcbiAgICBDb250cm9scyA9IHJlcXVpcmUoJy4vY29udHJvbHMnKSxcbiAgICBNYW4gPSByZXF1aXJlKCcuL29iamVjdHMvbWFuJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9vYmplY3RzL21hcCcpO1xuXG5mb3IgKHZhciBrZXkgaW4gY29uZmlnLmltYWdlcykge1xuICAgIGlmIChjb25maWcuaW1hZ2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaW1hZ2VzLnB1c2goY29uZmlnLmltYWdlc1trZXldKTtcbiAgICB9XG59XG5nYW1lanMucHJlbG9hZChpbWFnZXMpO1xuXG5nYW1lanMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXNwbGF5ID0gZ2FtZWpzLmRpc3BsYXkuZ2V0U3VyZmFjZSgpLFxuICAgICAgICBjb250cm9scyA9IG5ldyBDb250cm9scyhjb25maWcuc3RlcCksXG4gICAgICAgIGNvd2JveSA9IG5ldyBNYW4oZ2FtZWpzLmltYWdlLmxvYWQoY29uZmlnLmltYWdlcy5tYW4pLCBjb25maWcuc2l6ZSksXG4gICAgICAgIG1hcCA9IG5ldyBNYXAoY29uZmlnLm1hcCwgY29uZmlnLnNpemUpO1xuXG4gICAgZ2FtZWpzLmRpc3BsYXkuc2V0TW9kZShjb25maWcuc2l6ZSk7XG5cbiAgICBnYW1lanMuZXZlbnQub25LZXlEb3duKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjb250cm9scy51cGRhdGUoZXZlbnQua2V5LCB0cnVlKTtcbiAgICB9KTtcbiAgICBnYW1lanMuZXZlbnQub25LZXlVcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgY29udHJvbHMudXBkYXRlKGV2ZW50LmtleSwgZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgZ2FtZWpzLm9uVGljayhmdW5jdGlvbiAobXNEdXJhdGlvbikge1xuICAgICAgICB2YXIgaXNNYXBQb3NpdGlvbkNoYW5nZWQ7XG5cbiAgICAgICAgZGlzcGxheS5jbGVhcigpO1xuICAgICAgICBjb250cm9scy5jYWxjdWxhdGUoKTtcbiAgICAgICAgaXNNYXBQb3NpdGlvbkNoYW5nZWQgPSBtYXAubW92ZShjb250cm9scylcbiAgICAgICAgICAgIC5kcmF3KGRpc3BsYXkpO1xuICAgICAgICBjb3dib3kubW92ZShjb250cm9scywgaXNNYXBQb3NpdGlvbkNoYW5nZWQsIG1zRHVyYXRpb24pXG4gICAgICAgICAgICAuZHJhdyhkaXNwbGF5KTtcbiAgICB9KTtcbn0pOyIsIm1vZHVsZS5leHBvcnRzLmZpcnN0VG9Mb3dlckNhc2UgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn07IiwidmFyIGdhbWVqcyA9IHJlcXVpcmUoJ2dhbWVqcycpLFxuICAgIHN0YXRlcyA9IHJlcXVpcmUoJy4vbWFuL3N0YXRlcycpLFxuICAgIHN0cmluZyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3RyaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGZ1bmN0aW9uIE1hbihpbWFnZSwgY2FudmFzU2l6ZSkge1xuICAgICAgICB0aGlzLmhlaWdodCA9IDUwO1xuICAgICAgICB0aGlzLndpZHRoID0gNTA7XG4gICAgICAgIHRoaXMuc3ByaXRlID0gbmV3IGdhbWVqcy5hbmltYXRlLlNwcml0ZVNoZWV0KGltYWdlLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IDEyMCxcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBzY2FsZVRvOiBbXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHNwYWNpbmc6IDhcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBnYW1lanMuYW5pbWF0ZS5BbmltYXRpb24odGhpcy5zcHJpdGUsICdkb3duJywgdGhpcy5zdGF0ZXMpO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IHtcbiAgICAgICAgICAgIGhlaWdodDogY2FudmFzU2l6ZVsxXSxcbiAgICAgICAgICAgIHdpZHRoOiBjYW52YXNTaXplWzBdXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQFRPRE86IGltcGxlbWVudCBjb2xsaXNpb24gbWFza1xuICAgICAgICAgKi9cbiAgICAgICAgLy90aGlzLm1hc2sgPSBuZXcgZ2FtZWpzLnBpeGVsY29sbGlzaW9uLk1hc2sodGhpcy5pbWFnZSk7XG4gICAgfVxuXG4gICAgTWFuLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGNvbnRyb2xzLCBpc01hcFBvc2l0aW9uQ2hhbmdlZCwgbXNEdXJhdGlvbikge1xuICAgICAgICB2YXIgZGlyZWN0aW9uO1xuXG4gICAgICAgIGlmICghY29udHJvbHMuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAnZG93bic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjb250cm9scy5tb3ZlID8gJ21vdmUnICsgY29udHJvbHMuZGlyZWN0aW9uIDogc3RyaW5nLmZpcnN0VG9Mb3dlckNhc2UoY29udHJvbHMuZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGlvbi5zZXRTdGF0ZShkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi51cGRhdGUobXNEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKCFpc01hcFBvc2l0aW9uQ2hhbmdlZC50b3ApIHtcbiAgICAgICAgICAgIHRoaXMudG9wID0gTWF0aC5tYXgoMCwgdGhpcy50b3AgKyBjb250cm9scy5wb3NpdGlvbi50b3ApO1xuICAgICAgICAgICAgdGhpcy50b3AgPSBNYXRoLm1pbih0aGlzLnRvcCwgdGhpcy5jYW52YXMuaGVpZ2h0IC0gMy8yKnRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNNYXBQb3NpdGlvbkNoYW5nZWQubGVmdCkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gTWF0aC5tYXgoMCwgdGhpcy5sZWZ0ICsgY29udHJvbHMucG9zaXRpb24ubGVmdCk7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBNYXRoLm1pbih0aGlzLmxlZnQsIHRoaXMuY2FudmFzLndpZHRoIC0gMy8yKnRoaXMud2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIE1hbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICAgIGRpc3BsYXkuYmxpdCh0aGlzLmFuaW1hdGlvbi5pbWFnZSwgW3RoaXMubGVmdCwgdGhpcy50b3BdKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgTWFuLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLmNhbnZhcy5oZWlnaHQvMiAtIHRoaXMuaGVpZ2h0LzI7XG4gICAgICAgIHRoaXMubGVmdCA9IHRoaXMuY2FudmFzLndpZHRoLzIgLSB0aGlzLndpZHRoLzI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBNYW47XG59KSgpOyIsInZhciBSQVRFID0gMTA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHVwOiB7XG4gICAgICAgIGZyYW1lczogWzcwXSxcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgcmF0ZTogUkFURVxuICAgIH0sXG4gICAgbW92ZVVwOiB7XG4gICAgICAgIGZyYW1lczogWzcxLCA3MiwgNzMsIDc0LCA3NSwgNzYsIDc3LCA3OF0sXG4gICAgICAgIGxvb3A6IHRydWUsXG4gICAgICAgIHJhdGU6IFJBVEVcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICAgIGZyYW1lczogWzQyXSxcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgcmF0ZTogUkFURVxuICAgIH0sXG4gICAgbW92ZVJpZ2h0OiB7XG4gICAgICAgIGZyYW1lczogWzQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MF0sXG4gICAgICAgIGxvb3A6IHRydWUsXG4gICAgICAgIHJhdGU6IFJBVEVcbiAgICB9LFxuICAgIGRvd246IHtcbiAgICAgICAgZnJhbWVzOiBbMTI2XSxcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgcmF0ZTogUkFURVxuICAgIH0sXG4gICAgbW92ZURvd246IHtcbiAgICAgICAgZnJhbWVzOiBbMTI3LCAxMjgsIDEyOSwgMTMwLCAxMzEsIDEzMiwgMTMzLCAxMzRdLFxuICAgICAgICBsb29wOiB0cnVlLFxuICAgICAgICByYXRlOiBSQVRFXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICAgIGZyYW1lczogWzk4XSxcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgcmF0ZTogUkFURVxuICAgIH0sXG4gICAgbW92ZUxlZnQ6IHtcbiAgICAgICAgZnJhbWVzOiBbOTksIDEwMCwgMTAxLCAxMDIsIDEwMywgMTA0LCAxMDUsIDEwNl0sXG4gICAgICAgIGxvb3A6IHRydWUsXG4gICAgICAgIHJhdGU6IFJBVEVcbiAgICB9LFxuICAgIHVwUmlnaHQ6IHtcbiAgICAgICAgZnJhbWVzOiBbNTZdLFxuICAgICAgICBsb29wOiB0cnVlLFxuICAgICAgICByYXRlOiBSQVRFXG4gICAgfSxcbiAgICBtb3ZlVXBSaWdodDoge1xuICAgICAgICBmcmFtZXM6IFs1NywgNTgsIDU5LCA2MCwgNjEsIDYyLCA2MywgNjRdLFxuICAgICAgICBsb29wOiB0cnVlLFxuICAgICAgICByYXRlOiBSQVRFXG4gICAgfSxcbiAgICBkb3duUmlnaHQ6IHtcbiAgICAgICAgZnJhbWVzOiBbMjhdLFxuICAgICAgICBsb29wOiB0cnVlLFxuICAgICAgICByYXRlOiBSQVRFXG4gICAgfSxcbiAgICBtb3ZlRG93blJpZ2h0OiB7XG4gICAgICAgIGZyYW1lczogWzI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNl0sXG4gICAgICAgIGxvb3A6IHRydWUsXG4gICAgICAgIHJhdGU6IFJBVEVcbiAgICB9LFxuICAgIHVwTGVmdDoge1xuICAgICAgICBmcmFtZXM6IFs4NF0sXG4gICAgICAgIGxvb3A6IHRydWUsXG4gICAgICAgIHJhdGU6IFJBVEVcbiAgICB9LFxuICAgIG1vdmVVcExlZnQ6IHtcbiAgICAgICAgZnJhbWVzOiBbODUsIDg2LCA4NywgODgsIDg5LCA5MCwgOTEsIDkyXSxcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgcmF0ZTogUkFURVxuICAgIH0sXG4gICAgZG93bkxlZnQ6IHtcbiAgICAgICAgZnJhbWVzOiBbMTEyXSxcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgcmF0ZTogUkFURVxuICAgIH0sXG4gICAgbW92ZURvd25MZWZ0OiB7XG4gICAgICAgIGZyYW1lczogWzExMywgMTE0LCAxMTUsIDExNiwgMTE3LCAxMTgsIDExOSwgMTIwXSxcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgcmF0ZTogUkFURVxuICAgIH1cbn07IiwidmFyIGdhbWVqcyA9IHJlcXVpcmUoJ2dhbWVqcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBNYXAodXJsLCBjYW52YXNTaXplKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IGdhbWVqcy50aWxlZG1hcC5NYXAodXJsKTtcbiAgICAgICAgdGhpcy5tYXBWaWV3ID0gbmV3IGdhbWVqcy50aWxlZG1hcC5NYXBWaWV3KHRoaXMubWFwKTtcbiAgICAgICAgdGhpcy5pc01vdmluZyA9IHtcbiAgICAgICAgICAgIHRvcDogdHJ1ZSxcbiAgICAgICAgICAgIGxlZnQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vdmVySGVpZ2h0ID0gdGhpcy5tYXBWaWV3LnZpZXdSZWN0LmhlaWdodCAtIGNhbnZhc1NpemVbMV07XG4gICAgICAgIHRoaXMub3ZlcldpZHRoID0gdGhpcy5tYXBWaWV3LnZpZXdSZWN0LndpZHRoIC0gY2FudmFzU2l6ZVswXTtcbiAgICB9XG5cbiAgICBNYXAucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoY29udHJvbHMpIHtcbiAgICAgICAgdmFyIHRvcCA9IE1hdGgubWluKHRoaXMubWFwVmlldy52aWV3UmVjdC50b3AgKyBjb250cm9scy5wb3NpdGlvbi50b3AsIHRoaXMub3ZlckhlaWdodCksXG4gICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4odGhpcy5tYXBWaWV3LnZpZXdSZWN0LmxlZnQgKyBjb250cm9scy5wb3NpdGlvbi5sZWZ0LCB0aGlzLm92ZXJXaWR0aCk7XG5cbiAgICAgICAgdGhpcy5tYXBWaWV3LnZpZXdSZWN0LnRvcCA9IE1hdGgubWF4KDAsIHRvcCk7XG4gICAgICAgIHRoaXMubWFwVmlldy52aWV3UmVjdC5sZWZ0ID0gTWF0aC5tYXgoMCwgbGVmdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICAgIHRoaXMubWFwVmlldy5kcmF3KGRpc3BsYXksIFswLCAwXSk7XG4gICAgICAgIHRoaXMuaXNNb3ZpbmcgPSB7XG4gICAgICAgICAgICB0b3A6IHRydWUsXG4gICAgICAgICAgICBsZWZ0OiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF0aGlzLm1hcFZpZXcudmlld1JlY3QudG9wIHx8IHRoaXMubWFwVmlldy52aWV3UmVjdC50b3AgPj0gdGhpcy5vdmVySGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmlzTW92aW5nLnRvcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMubWFwVmlldy52aWV3UmVjdC5sZWZ0IHx8IHRoaXMubWFwVmlldy52aWV3UmVjdC5sZWZ0ID49IHRoaXMub3ZlcldpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLmlzTW92aW5nLmxlZnQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmlzTW92aW5nO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFwO1xufSkoKTsiLCJ2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi9nYW1lanMvbWF0aC9tYXRyaXgnKTtcbnZhciBvYmplY3RzID0gcmVxdWlyZSgnLi9nYW1lanMvdXRpbHMvb2JqZWN0cycpO1xudmFyIENhbGxiYWNrID0gcmVxdWlyZSgnLi9nYW1lanMvdXRpbHMvY2FsbGJhY2snKS5DYWxsYmFjaztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBgZ2FtZWpzLnJlYWR5KClgIGlzIG1heWJlIHRoZSBtb3N0IGltcG9ydGFudCBmdW5jdGlvbiBhcyBpdCBraWNrc3RhcnRzIHlvdXIgYXBwOlxuICpcbiAqICAgICB2YXIgZ2FtZWpzID0gcmVxdWlyZSgnZ2FtZWpzJyk7XG4gKiAgICAgcmVhZHkoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGdhbWVqcy5sb2dnaW5nLmluZm8oJ0kgYW0gcmVhZHkhJylcbiAqICAgICB9KTtcbiAqXG4gKiBJZiB5b3UgdXNlIGltYWdlcyBvciBzb3VuZHMgcHJlbG9hZCBhbGwgYXNzZXRzIHdpdGggYGdhbWVqcy5wcmVsb2FkKFsnLi9maWxlcy9mb28ucG5nJ10pYCBiZWZvcmUgY2FsbGluZyBgcmVhZHkoKWAuXG4gKlxuICogQWxzbyBpbiB0aGlzIG1vZHVsZSBpcyB0aGUgYFJlY3RgIGNsYXNzIHdoaWNoIGlzIGdlbmVyYWxseSB1c2VmdWwgd2hlbiBkZWFsaW5nIHdpdGggU3VyZmFjZXMgYW5kIHNpbXBsZSByZWN0YW5nbGVzIChlLmcuIGZvciBjb2xsaXNpb25zKS5cbiAqL1xuLy8gcHJlbG9hZGluZyBzdHVmZlxudmFyIGdhbWVqcyA9IGV4cG9ydHM7XG52YXIgUkVTT1VSQ0VTID0ge307XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy50aHJlYWQgPSByZXF1aXJlKCcuL2dhbWVqcy90aHJlYWQnKTtcblxuXG4vKipcbiAqIFJlYWR5Rm4gaXMgY2FsbGVkIG9uY2UgYWxsIG1vZHVsZXMgYW5kIGFzc2V0cyBhcmUgbG9hZGVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tGdW5jdGlvbiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgZ2FtZWpzIGZpbmlzaGVkIGxvYWRpbmdcbiAqIEBuYW1lIHJlYWR5XG4gKi9cbmlmIChnYW1lanMudGhyZWFkLmluV29ya2VyID09PSB0cnVlKSB7XG4gICBleHBvcnRzLnJlYWR5ID0gZnVuY3Rpb24ocmVhZHlGbikge1xuICAgICAgcmVxdWlyZSgnLi9nYW1lanMvdGhyZWFkJykuX3JlYWR5KCk7XG4gICAgICBnYW1lanMuaW5pdCgpO1xuICAgICAgcmVhZHlGbigpO1xuICAgfTtcbn0gZWxzZSB7XG4gICBleHBvcnRzLnJlYWR5ID0gZnVuY3Rpb24ocmVhZHlGbikge1xuXG4gICAgICB2YXIgZ2V0TWl4ZXJQcm9ncmVzcyA9IG51bGw7XG4gICAgICB2YXIgZ2V0SW1hZ2VQcm9ncmVzcyA9IG51bGw7XG5cbiAgICAgIC8vIGluaXQgdGltZSBpbnN0YW50bHkgLSB3ZSBuZWVkIGl0IGZvciBwcmVsb2FkZXJzXG4gICAgICBnYW1lanMudGltZS5pbml0KCk7XG5cbiAgICAgIC8vIDIuXG4gICAgICBmdW5jdGlvbiBfcmVhZHkoKSB7XG4gICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChfcmVhZHksIDUwKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGdldEltYWdlUHJvZ3Jlc3MgPSBnYW1lanMuaW1hZ2UucHJlbG9hZChSRVNPVVJDRVMpO1xuICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdldE1peGVyUHJvZ3Jlc3MgPSBnYW1lanMuYXVkaW8ucHJlbG9hZChSRVNPVVJDRVMpO1xuICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZ2FtZWpzLmRlYnVnKCdFcnJvciBsb2FkaW5nIGF1ZGlvIGZpbGVzICcsIGUpO1xuICAgICAgICAgfVxuICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoX3JlYWR5UmVzb3VyY2VzLCA1MCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDMuXG4gICAgICBmdW5jdGlvbiBfcmVhZHlSZXNvdXJjZXMoKSB7XG4gICAgICAgICBpZiAoZ2V0SW1hZ2VQcm9ncmVzcygpIDwgMSB8fCBnZXRNaXhlclByb2dyZXNzKCkgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoX3JlYWR5UmVzb3VyY2VzLCAxMDApO1xuICAgICAgICAgfVxuICAgICAgICAgZ2FtZWpzLmRpc3BsYXkuaW5pdCgpO1xuICAgICAgICAgZ2FtZWpzLmltYWdlLmluaXQoKTtcbiAgICAgICAgIGdhbWVqcy5hdWRpby5pbml0KCk7XG4gICAgICAgICBnYW1lanMuZXZlbnQuaW5pdCgpO1xuICAgICAgICAgZ2FtZWpzLm1hdGgucmFuZG9tLmluaXQoKTtcbiAgICAgICAgIHJlYWR5Rm4oKTtcbiAgICAgIH1cblxuICAgICAgLy8gMS5cbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KF9yZWFkeSwgMTMpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRMb2FkUHJvZ3Jlc3MoKSB7XG4gICAgICAgICBpZiAoZ2V0SW1hZ2VQcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuICgwLjUgKiBnZXRJbWFnZVByb2dyZXNzKCkpICsgKDAuNSAqIGdldE1peGVyUHJvZ3Jlc3MoKSk7XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gMC4xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0TG9hZFByb2dyZXNzO1xuICAgfTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGFsbCBnYW1lanMgbW9kdWxlcy4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZFxuICogYnkgYGdhbWVqcy5yZWFkeSgpYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgb2JqZWN0ZSBhcmUgdGhlIG1vZHVsZUlkcyB0aGF0IGZhaWxlZCwgdGhleSB2YWx1ZSBhcmUgdGhlIGV4Y2VwdGlvbnNcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgZXJyb3JNb2R1bGVzID0ge307XG4gICBbJ3RpbWUnLCAnZGlzcGxheScsICdpbWFnZScsICdhdWRpbycsICdldmVudCddLmZvckVhY2goZnVuY3Rpb24obW9kdWxlTmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgIGdhbWVqc1ttb2R1bGVOYW1lXS5pbml0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICBlcnJvck1vZHVsZXNbbW9kdWxlTmFtZV0gPSBlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICB9KTtcbiAgIHJldHVybiBlcnJvck1vZHVsZXM7XG59O1xuXG52YXIgcmVzb3VyY2VCYXNlSHJlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAod2luZG93LiRnICYmIHdpbmRvdy4kZy5yZXNvdXJjZUJhc2VIcmVmKSB8fCBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xufTtcblxuLyoqXG4gKiBQcmVsb2FkIHJlc291cmNlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IHJlc291cmNlcyBsaXN0IG9mIHJlc291cmNlcyBwYXRoc1xuICogQG5hbWUgcHJlbG9hZFxuICovXG52YXIgcHJlbG9hZCA9IGV4cG9ydHMucHJlbG9hZCA9IGZ1bmN0aW9uKHJlc291cmNlcykge1xuICAgdmFyIHVyaSA9IHJlcXVpcmUoJy4vZ2FtZWpzL3V0aWxzL3VyaScpO1xuICAgdmFyIGJhc2VIcmVmID0gcmVzb3VyY2VCYXNlSHJlZigpO1xuICAgcmVzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24ocmVzKSB7XG4gICAgICBSRVNPVVJDRVNbcmVzXSA9IHVyaS5yZXNvbHZlKGJhc2VIcmVmLCByZXMpO1xuICAgfSwgdGhpcyk7XG4gICByZXR1cm47XG59O1xuXG4vKipcbiAqIFRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gYG9uVGlja2Agd2lsbCBjb250aW5vdXNseSBiZSBjYWxsZWQgYXQgYVxuICogZnJlcXVlbmN5IGRldGVybWluZWQgYnkgdGhlIGJyb3dzZXIgKHR5cGljYWxseSBiZXR3ZWVuIDEgYW5kIDYwIHRpbWVzIHBlciBzZWNvbmQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tGdW5jdGlvbiB0aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gYmUgY2FsbGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1Njb3BlIG9wdGlvbmFsIHNjb3BlIGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICovXG5leHBvcnRzLm9uVGljayA9IGZ1bmN0aW9uKGZuLCBzY29wZSkge1xuICAvKiogaWdub3JlICoqL1xuICBleHBvcnRzLnRpbWUuX0NBTExCQUNLUy5wdXNoKG5ldyBDYWxsYmFjayhmbiwgc2NvcGUpKTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHZhcmlvdXMgd2F5cyB0byBzcGVjaWZ5IGEgUmVjdCBpbnRvIHtsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9IGZvcm0uXG4gKiBAaWdub3JlXG4gKlxuICovXG52YXIgbm9ybWFsaXplUmVjdEFyZ3VtZW50cyA9IGV4cG9ydHMubm9ybWFsaXplUmVjdEFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgIHZhciBsZWZ0ID0gMDtcbiAgIHZhciB0b3AgPSAwO1xuICAgdmFyIHdpZHRoID0gMDtcbiAgIHZhciBoZWlnaHQgPSAwO1xuXG4gICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICBsZWZ0ID0gYXJndW1lbnRzWzBdWzBdO1xuICAgICAgICAgdG9wID0gYXJndW1lbnRzWzBdWzFdO1xuICAgICAgICAgd2lkdGggPSBhcmd1bWVudHNbMV1bMF07XG4gICAgICAgICBoZWlnaHQgPSBhcmd1bWVudHNbMV1bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgbGVmdCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgIHRvcCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgbGVmdCA9IGFyZ3VtZW50c1swXVswXTtcbiAgICAgIHRvcCA9IGFyZ3VtZW50c1swXVsxXTtcbiAgICAgIHdpZHRoID0gYXJndW1lbnRzWzBdWzJdO1xuICAgICAgaGVpZ2h0ID0gYXJndW1lbnRzWzBdWzNdO1xuICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFJlY3QpIHtcbiAgICAgIGxlZnQgPSBhcmd1bWVudHNbMF0ubGVmdDtcbiAgICAgIHRvcCA9IGFyZ3VtZW50c1swXS50b3A7XG4gICAgICB3aWR0aCA9IGFyZ3VtZW50c1swXS53aWR0aDtcbiAgICAgIGhlaWdodCA9IGFyZ3VtZW50c1swXS5oZWlnaHQ7XG4gICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIGxlZnQgPSBhcmd1bWVudHNbMF07XG4gICAgICB0b3AgPSBhcmd1bWVudHNbMV07XG4gICAgICB3aWR0aCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGhlaWdodCA9IGFyZ3VtZW50c1szXTtcbiAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHZhbGlkIHJlY3RhbmdsZSBzcGVjaWZpY2F0aW9uJyk7XG4gICB9XG4gICByZXR1cm4ge2xlZnQ6IGxlZnQgfHwgMCwgdG9wOiB0b3AgfHwgMCwgd2lkdGg6IHdpZHRoIHx8IDAsIGhlaWdodDogaGVpZ2h0IHx8IDB9O1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWN0LiBSZWN0cyBhcmUgdXNlZCB0byBob2xkIHJlY3Rhbmd1bGFyIGFyZWFzLiBUaGVyZSBhcmUgYSBjb3VwbGVcbiAqIG9mIGNvbnZpbmllbnQgd2F5cyB0byBjcmVhdGUgUmVjdHMgd2l0aCBkaWZmZXJlbnQgYXJndW1lbnRzIGFuZCBkZWZhdWx0cy5cbiAqXG4gKiBBbnkgZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBhIGBnYW1lanMuUmVjdGAgYXJndW1lbnQgYWxzbyBhY2NlcHRzIGFueSBvZiB0aGVcbiAqIGNvbnN0cnVjdG9yIHZhbHVlIGNvbWJpbmF0aW9ucyBgUmVjdGAgYWNjZXB0cy5cbiAqXG4gKiBSZWN0cyBhcmUgdXNlZCBhIGxvdC4gVGhleSBhcmUgZ29vZCBmb3IgY29sbGlzaW9uIGRldGVjdGlvbiwgc3BlY2lmeWluZ1xuICogYW4gYXJlYSBvbiB0aGUgc2NyZWVuIChmb3IgYmxpdHRpbmcpIG9yIGp1c3QgdG8gaG9sZCBhbiBvYmplY3RzIHBvc2l0aW9uLlxuICpcbiAqIFRoZSBSZWN0IG9iamVjdCBoYXMgc2V2ZXJhbCB2aXJ0dWFsIGF0dHJpYnV0ZXMgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbW92ZSBhbmQgYWxpZ24gdGhlIFJlY3Q6XG4gKlxuICogICB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHRcbiAqICAgdG9wbGVmdCwgYm90dG9tbGVmdCwgdG9wcmlnaHQsIGJvdHRvbXJpZ2h0XG4gKiAgIGNlbnRlclxuICogICB3aWR0aCwgaGVpZ2h0XG4gKiAgIHcsaFxuICpcbiAqIEFsbCBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBhc3NpZ25lZCB0by5cbiAqIEFzc2lnbmluZyB0byB3aWR0aCBvciBoZWlnaHQgY2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcmVjdGFuZ2xlOyBhbGwgb3RoZXJcbiAqIGFzc2lnbm1lbnRzIG1vdmUgdGhlIHJlY3RhbmdsZSB3aXRob3V0IHJlc2l6aW5nIGl0LiBOb3RpY2UgdGhhdCBzb21lIGF0dHJpYnV0ZXNcbiAqIGFyZSBOdW1iZXJzIGFuZCBvdGhlcnMgYXJlIHBhaXJzIG9mIE51bWJlcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBSZWN0KFtsZWZ0LCB0b3BdKSAvLyB3aWR0aCAmIGhlaWdodCBkZWZhdWx0IHRvIDBcbiAqIG5ldyBSZWN0KGxlZnQsIHRvcCkgLy8gd2lkdGggJiBoZWlnaHQgZGVmYXVsdCB0byAwXG4gKiBuZXcgUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpXG4gKiBuZXcgUmVjdChbbGVmdCwgdG9wXSwgW3dpZHRoLCBoZWlnaHRdKVxuICogbmV3IFJlY3Qob2xkUmVjdCkgLy8gY2xvbmUgb2Ygb2xkUmVjdCBpcyBjcmVhdGVkXG4gKlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHJpZ2h0XG4gKiBAcHJvcGVydHkge051bWJlcn0gYm90dG9tXG4gKiBAcHJvcGVydHkge051bWJlcn0gY2VudGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl8Z2FtZWpzLlJlY3R9IHBvc2l0aW9uIEFycmF5IGhvbGRpbmcgbGVmdCBhbmQgdG9wIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge0FycmF5fSBkaW1lbnNpb25zIEFycmF5IGhvbGRpbmcgd2lkdGggYW5kIGhlaWdodFxuICovXG52YXIgUmVjdCA9IGV4cG9ydHMuUmVjdCA9IGZ1bmN0aW9uKCkge1xuXG4gICB2YXIgYXJncyA9IG5vcm1hbGl6ZVJlY3RBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgLyoqXG4gICAgKiBMZWZ0LCBYIGNvb3JkaW5hdGVcbiAgICAqIEB0eXBlIE51bWJlclxuICAgICovXG4gICB0aGlzLmxlZnQgPSBhcmdzLmxlZnQ7XG5cbiAgIC8qKlxuICAgICogVG9wLCBZIGNvb3JkaW5hdGVcbiAgICAqIEB0eXBlIE51bWJlclxuICAgICovXG4gICB0aGlzLnRvcCA9IGFyZ3MudG9wO1xuXG4gICAvKipcbiAgICAqIFdpZHRoIG9mIHJlY3RhbmdsZVxuICAgICogQHR5cGUgTnVtYmVyXG4gICAgKi9cbiAgIHRoaXMud2lkdGggPSBhcmdzLndpZHRoO1xuXG4gICAvKipcbiAgICAqIEhlaWdodCBvZiByZWN0YW5nbGVcbiAgICAqIEB0eXBlIE51bWJlclxuICAgICovXG4gICB0aGlzLmhlaWdodCA9IGFyZ3MuaGVpZ2h0O1xuXG4gICByZXR1cm4gdGhpcztcbn07XG5cbm9iamVjdHMuYWNjZXNzb3JzKFJlY3QucHJvdG90eXBlLCB7XG4gICAvKipcbiAgICAqIEJvdHRvbSwgWSBjb29yZGluYXRlXG4gICAgKiBAbmFtZSBSZWN0LnByb3RvdHlwZS5ib3R0b21cbiAgICAqIEB0eXBlIE51bWJlclxuICAgICovXG4gICAnYm90dG9tJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgIHRoaXMudG9wID0gbmV3VmFsdWUgLSB0aGlzLmhlaWdodDtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH0sXG4gICAvKipcbiAgICAqIFJpZ2h0LCBYIGNvb3JkaW5hdGVcbiAgICAqIEBuYW1lIFJlY3QucHJvdG90eXBlLnJpZ2h0XG4gICAgKiBAdHlwZSBOdW1iZXJcbiAgICAqL1xuICAgJ3JpZ2h0Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgIHRoaXMubGVmdCA9IG5ld1ZhbHVlIC0gdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgIH0sXG4gICAvKipcbiAgICAqIENlbnRlciBQb3NpdGlvbi4gWW91IGNhbiBhc3NpZ24gYSByZWN0YW5nbGUgZm9ybS5cbiAgICAqIEBuYW1lIFJlY3QucHJvdG90eXBlLmNlbnRlclxuICAgICogQHR5cGUgQXJyYXlcbiAgICAqL1xuICAgJ2NlbnRlcic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICByZXR1cm4gW3RoaXMubGVmdCArICh0aGlzLndpZHRoIC8gMikgfCAwLFxuICAgICAgICAgICAgICAgICB0aGlzLnRvcCArICh0aGlzLmhlaWdodCAvIDIpIHwgMFxuICAgICAgICAgICAgICAgIF07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHZhciBhcmdzID0gbm9ybWFsaXplUmVjdEFyZ3VtZW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgdGhpcy5sZWZ0ID0gYXJncy5sZWZ0IC0gKHRoaXMud2lkdGggLyAyKSB8IDA7XG4gICAgICAgICB0aGlzLnRvcCA9IGFyZ3MudG9wIC0gKHRoaXMuaGVpZ2h0IC8gMikgfCAwO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgfSxcbiAgIC8qKlxuICAgICogVG9wLWxlZnQgUG9zaXRpb24uIFlvdSBjYW4gYXNzaWduIGEgcmVjdGFuZ2xlIGZvcm0uXG4gICAgKiBAbmFtZSBSZWN0LnByb3RvdHlwZS50b3BsZWZ0XG4gICAgKiBAdHlwZSBBcnJheVxuICAgICovXG4gICAndG9wbGVmdCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICByZXR1cm4gW3RoaXMubGVmdCwgdGhpcy50b3BdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICB2YXIgYXJncyA9IG5vcm1hbGl6ZVJlY3RBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgIHRoaXMubGVmdCA9IGFyZ3MubGVmdDtcbiAgICAgICAgIHRoaXMudG9wID0gYXJncy50b3A7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICB9LFxuICAgLyoqXG4gICAgKiBCb3R0b20tbGVmdCBQb3NpdGlvbi4gWW91IGNhbiBhc3NpZ24gYSByZWN0YW5nbGUgZm9ybS5cbiAgICAqIEBuYW1lIFJlY3QucHJvdG90eXBlLmJvdHRvbWxlZnRcbiAgICAqIEB0eXBlIEFycmF5XG4gICAgKi9cbiAgICdib3R0b21sZWZ0Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHJldHVybiBbdGhpcy5sZWZ0LCB0aGlzLmJvdHRvbV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHZhciBhcmdzID0gbm9ybWFsaXplUmVjdEFyZ3VtZW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgdGhpcy5sZWZ0ID0gYXJncy5sZWZ0O1xuICAgICAgICAgdGhpcy5ib3R0b20gPSBhcmdzLnRvcDtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH0sXG4gICAvKipcbiAgICAqIFRvcC1yaWdodCBQb3NpdGlvbi4gWW91IGNhbiBhc3NpZ24gYSByZWN0YW5nbGUgZm9ybS5cbiAgICAqIEBuYW1lIFJlY3QucHJvdG90eXBlLnRvcHJpZ2h0XG4gICAgKiBAdHlwZSBBcnJheVxuICAgICovXG4gICAndG9wcmlnaHQnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgcmV0dXJuIFt0aGlzLnJpZ2h0LCB0aGlzLnRvcF07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHZhciBhcmdzID0gbm9ybWFsaXplUmVjdEFyZ3VtZW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgdGhpcy5yaWdodCA9IGFyZ3MubGVmdDtcbiAgICAgICAgIHRoaXMudG9wID0gYXJncy50b3A7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICB9LFxuICAgLyoqXG4gICAgKiBCb3R0b20tcmlnaHQgUG9zaXRpb24uIFlvdSBjYW4gYXNzaWduIGEgcmVjdGFuZ2xlIGZvcm0uXG4gICAgKiBAbmFtZSBSZWN0LnByb3RvdHlwZS5ib3R0b21yaWdodFxuICAgICogQHR5cGUgQXJyYXlcbiAgICAqL1xuICAgJ2JvdHRvbXJpZ2h0Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHJldHVybiBbdGhpcy5yaWdodCwgdGhpcy5ib3R0b21dO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICB2YXIgYXJncyA9IG5vcm1hbGl6ZVJlY3RBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgIHRoaXMucmlnaHQgPSBhcmdzLmxlZnQ7XG4gICAgICAgICB0aGlzLmJvdHRvbSA9IGFyZ3MudG9wO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgfSxcbiAgIC8qKlxuICAgICogUG9zaXRpb24geCB2YWx1ZSwgYWxpYXMgZm9yIGBsZWZ0YC5cbiAgICAqIEBuYW1lIFJlY3QucHJvdG90eXBlLnlcbiAgICAqIEB0eXBlIEFycmF5XG4gICAgKi9cbiAgICd4Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmxlZnQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgdGhpcy5sZWZ0ID0gbmV3VmFsdWU7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICB9LFxuICAgLyoqXG4gICAgKiBQb3NpdGlvbiB5IHZhbHVlLCBhbGlhcyBmb3IgYHRvcGAuXG4gICAgKiBAbmFtZSBSZWN0LnByb3RvdHlwZS55XG4gICAgKiBAdHlwZSBBcnJheVxuICAgICovXG4gICAneSc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy50b3A7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgdGhpcy50b3AgPSBuZXdWYWx1ZTtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cbn0pO1xuXG4vKipcbiAqIE1vdmUgcmV0dXJucyBhIG5ldyBSZWN0LCB3aGljaCBpcyBhIHZlcnNpb24gb2YgdGhpcyBSZWN0XG4gKiBtb3ZlZCBieSB0aGUgZ2l2ZW4gYW1vdW50cy4gQWNjZXB0cyBhbnkgcmVjdGFuZ2xlIGZvcm0uXG4gKiBhcyBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxnYW1lanMuUmVjdH0geCBhbW91bnQgdG8gbW92ZSBvbiB4IGF4aXNcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IGFtb3VudCB0byBtb3ZlIG9uIHkgYXhpc1xuICovXG5SZWN0LnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgYXJncyA9IG5vcm1hbGl6ZVJlY3RBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIHJldHVybiBuZXcgUmVjdCh0aGlzLmxlZnQgKyBhcmdzLmxlZnQsIHRoaXMudG9wICsgYXJncy50b3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogTW92ZSB0aGlzIFJlY3QgaW4gcGxhY2UgLSBub3QgcmV0dXJuaW5nIGEgbmV3IFJlY3QgbGlrZSBgbW92ZSh4LCB5KWAgd291bGQuXG4gKlxuICogYG1vdmVJcCh4LHkpYCBvciBgbW92ZUlwKFt4LHldKWBcbiAqXG4gKiBAcGFyYW0ge051bWJlcnxnYW1lanMuUmVjdH0geCBhbW91bnQgdG8gbW92ZSBvbiB4IGF4aXNcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IGFtb3VudCB0byBtb3ZlIG9uIHkgYXhpc1xuICovXG5SZWN0LnByb3RvdHlwZS5tb3ZlSXAgPSBmdW5jdGlvbigpIHtcbiAgIHZhciBhcmdzID0gbm9ybWFsaXplUmVjdEFyZ3VtZW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgdGhpcy5sZWZ0ICs9IGFyZ3MubGVmdDtcbiAgIHRoaXMudG9wICs9IGFyZ3MudG9wO1xuICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGFyZWEgaW4gd2hpY2ggdGhpcyBSZWN0IGFuZCBhcmd1bWVudCBSZWN0IG92ZXJsYXAuXG4gKlxuICogQHBhcmFtIHtnYW1lanMuUmVjdH0gUmVjdCB0byBjbGlwIHRoaXMgb25lIGludG9cbiAqIEByZXR1cm5zIHtnYW1lanMuUmVjdH0gbmV3IFJlY3Qgd2hpY2ggaXMgY29tcGxldGVseSBpbnNpZGUgdGhlIGFyZ3VtZW50IFJlY3QsXG4gKiB6ZXJvIHNpemVkIFJlY3QgaWYgdGhlIHR3byByZWN0YW5nbGVzIGRvIG5vdCBvdmVybGFwXG4gKi9cblJlY3QucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbihyZWN0KSB7XG4gICBpZighdGhpcy5jb2xsaWRlUmVjdChyZWN0KSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWN0KDAsMCwwLDApO1xuICAgfVxuXG4gICB2YXIgeCwgeSwgd2lkdGgsIGhlaWdodDtcblxuICAgLy8gTGVmdFxuICAgaWYgKCh0aGlzLmxlZnQgPj0gcmVjdC5sZWZ0KSAmJiAodGhpcy5sZWZ0IDwgcmVjdC5yaWdodCkpIHtcbiAgICAgIHggPSB0aGlzLmxlZnQ7XG4gICB9IGVsc2UgaWYgKChyZWN0LmxlZnQgPj0gdGhpcy5sZWZ0KSAmJiAocmVjdC5sZWZ0IDwgdGhpcy5yaWdodCkpIHtcbiAgICAgIHggPSByZWN0LmxlZnQ7XG4gICB9XG5cbiAgIC8vIFJpZ2h0XG4gICBpZiAoKHRoaXMucmlnaHQgPiByZWN0LmxlZnQpICYmICh0aGlzLnJpZ2h0IDw9IHJlY3QucmlnaHQpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMucmlnaHQgLSB4O1xuICAgfSBlbHNlIGlmICgocmVjdC5yaWdodCA+IHRoaXMubGVmdCkgJiYgKHJlY3QucmlnaHQgPD0gdGhpcy5yaWdodCkpIHtcbiAgICAgIHdpZHRoID0gcmVjdC5yaWdodCAtIHg7XG4gICB9XG5cbiAgIC8vIFRvcFxuICAgaWYgKCh0aGlzLnRvcCA+PSByZWN0LnRvcCkgJiYgKHRoaXMudG9wIDwgcmVjdC5ib3R0b20pKSB7XG4gICAgICB5ID0gdGhpcy50b3A7XG4gICB9IGVsc2UgaWYgKChyZWN0LnRvcCA+PSB0aGlzLnRvcCkgJiYgKHJlY3QudG9wIDwgdGhpcy5ib3R0b20pKSB7XG4gICAgICB5ID0gcmVjdC50b3A7XG4gICB9XG5cbiAgIC8vIEJvdHRvbVxuICAgaWYgKCh0aGlzLmJvdHRvbSA+IHJlY3QudG9wKSAmJiAodGhpcy5ib3R0b20gPD0gcmVjdC5ib3R0b20pKSB7XG4gICAgIGhlaWdodCA9IHRoaXMuYm90dG9tIC0geTtcbiAgIH0gZWxzZSBpZiAoKHJlY3QuYm90dG9tID4gdGhpcy50b3ApICYmIChyZWN0LmJvdHRvbSA8PSB0aGlzLmJvdHRvbSkpIHtcbiAgICAgaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSB5O1xuICAgfVxuICAgcmV0dXJuIG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xufTtcblxuLyoqXG4gKiBKb2luIHR3byByZWN0YW5nbGVzXG4gKlxuICogQHBhcmFtIHtnYW1lanMuUmVjdH0gdW5pb24gd2l0aCB0aGlzIHJlY3RhbmdsZVxuICogQHJldHVybnMge2dhbWVqcy5SZWN0fSByZWN0YW5nbGUgY29udGFpbmluZyBhcmVhIG9mIGJvdGggcmVjdGFuZ2xlc1xuICovXG5SZWN0LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgIHZhciB4LCB5LCB3aWR0aCwgaGVpZ2h0O1xuXG4gICB4ID0gTWF0aC5taW4odGhpcy5sZWZ0LCByZWN0LmxlZnQpO1xuICAgeSA9IE1hdGgubWluKHRoaXMudG9wLCByZWN0LnRvcCk7XG4gICB3aWR0aCA9IE1hdGgubWF4KHRoaXMucmlnaHQsIHJlY3QucmlnaHQpIC0geDtcbiAgIGhlaWdodCA9IE1hdGgubWF4KHRoaXMuYm90dG9tLCByZWN0LmJvdHRvbSkgLSB5O1xuICAgcmV0dXJuIG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xufTtcblxuLyoqXG4gKiBHcm93IG9yIHNocmluayB0aGUgcmVjdGFuZ2xlIHNpemVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRvIGNoYW5nZSBpbiB0aGUgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdG8gY2hhbmdlIGluIHRoZSBoZWlnaHRcbiAqIEByZXR1cm5zIHtnYW1lanMuUmVjdH0gaW5mbGF0ZWQgcmVjdGFuZ2xlIGNlbnRlcmVkIG9uIHRoZSBvcmlnaW5hbCByZWN0YW5nbGUncyBjZW50ZXJcbiAqL1xuUmVjdC5wcm90b3R5cGUuaW5mbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgY29weSA9IHRoaXMuY2xvbmUoKTtcblxuICAgIGNvcHkuaW5mbGF0ZUlwKHgsIHkpO1xuXG4gICAgcmV0dXJuIGNvcHk7XG59O1xuXG4vKipcbiAqIEdyb3cgb3Igc2hyaW5rIHRoaXMgUmVjdCBpbiBwbGFjZSAtIG5vdCByZXR1cm5pbmcgYSBuZXcgUmVjdCBsaWtlIGBpbmZsYXRlKHgsIHkpYCB3b3VsZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IHRvIGNoYW5nZSBpbiB0aGUgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgdG8gY2hhbmdlIGluIHRoZSBoZWlnaHRcbiAqL1xuUmVjdC5wcm90b3R5cGUuaW5mbGF0ZUlwID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIC8vIFVzZSBNYXRoLmZsb29yIGhlcmUgdG8gZGVhbCB3aXRoIHJvdW5kaW5nIG9mIG5lZ2F0aXZlIG51bWJlcnMgdGhlXG4gICAgLy8gd2F5IHRoaXMgcmVsaWVzIG9uLlxuICAgIHRoaXMubGVmdCAtPSBNYXRoLmZsb29yKHggLyAyKTtcbiAgICB0aGlzLnRvcCAtPSBNYXRoLmZsb29yKHkgLyAyKTtcbiAgICB0aGlzLndpZHRoICs9IHg7XG4gICAgdGhpcy5oZWlnaHQgKz0geTtcbn07XG5cbi8qKlxuICogQ2hlY2sgZm9yIGNvbGxpc2lvbiB3aXRoIGEgcG9pbnQuXG4gKlxuICogYGNvbGxpZGVQb2ludCh4LHkpYCBvciBgY29sbGlkZVBvaW50KFt4LHldKWAgb3IgYGNvbGxpZGVQb2ludChuZXcgUmVjdCh4LHkpKWBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fGdhbWVqcy5SZWN0fSBwb2ludCB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgdG8gdGVzdCBmb3IgY29sbGlzaW9uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgcG9pbnQgY29sbGlkZXMgd2l0aCB0aGlzIFJlY3RcbiAqL1xuUmVjdC5wcm90b3R5cGUuY29sbGlkZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgYXJncyA9IG5vcm1hbGl6ZVJlY3RBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIHJldHVybiAodGhpcy5sZWZ0IDw9IGFyZ3MubGVmdCAmJiBhcmdzLmxlZnQgPD0gdGhpcy5yaWdodCkgJiZcbiAgICAgICAodGhpcy50b3AgPD0gYXJncy50b3AgJiYgYXJncy50b3AgPD0gdGhpcy5ib3R0b20pO1xufTtcblxuLyoqXG4gKiBDaGVjayBmb3IgY29sbGlzaW9uIHdpdGggYSBSZWN0LlxuICogQHBhcmFtIHtnYW1lanMuUmVjdH0gcmVjdCB0aGUgUmVjdCB0byB0ZXN0IGNoZWNrIGZvciBjb2xsaXNpb25cbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiBSZWN0IGNvbGxpZGVzIHdpdGggdGhpcyBSZWN0XG4gKi9cblJlY3QucHJvdG90eXBlLmNvbGxpZGVSZWN0ID0gZnVuY3Rpb24ocmVjdCkge1xuICAgcmV0dXJuICEodGhpcy5sZWZ0ID4gcmVjdC5yaWdodCB8fCB0aGlzLnJpZ2h0IDwgcmVjdC5sZWZ0IHx8XG4gICAgICB0aGlzLnRvcCA+IHJlY3QuYm90dG9tIHx8IHRoaXMuYm90dG9tIDwgcmVjdC50b3ApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludEEgc3RhcnQgcG9pbnQgb2YgdGhlIGxpbmVcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50QiBlbmQgcG9pbnQgb2YgdGhlIGxpbmVcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGxpbmUgaW50ZXJzZWN0cyB3aXRoIHRoZSByZWN0YW5nbGVcbiAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85OTM1My9ob3ctdG8tdGVzdC1pZi1hLWxpbmUtc2VnbWVudC1pbnRlcnNlY3RzLWFuLWF4aXMtYWxpZ25lZC1yZWN0YW5nZS1pbi0yZC8yOTMwNTIjMjkzMDUyXG4gKlxuICovXG5SZWN0LnByb3RvdHlwZS5jb2xsaWRlTGluZSA9IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgdmFyIHgxID0gcDFbMF07XG4gICB2YXIgeTEgPSBwMVsxXTtcbiAgIHZhciB4MiA9IHAyWzBdO1xuICAgdmFyIHkyID0gcDJbMV07XG5cbiAgIGZ1bmN0aW9uIGxpbmVQb3NpdGlvbihwb2ludCkge1xuICAgICAgdmFyIHggPSBwb2ludFswXTtcbiAgICAgIHZhciB5ID0gcG9pbnRbMV07XG4gICAgICByZXR1cm4gKHkyIC0geTEpICogeCArICh4MSAtIHgyKSAqIHkgKyAoeDIgKiB5MSAtIHgxICogeTIpO1xuICAgfVxuXG4gICB2YXIgcmVsUG9zZXMgPSBbW3RoaXMubGVmdCwgdGhpcy50b3BdLFxuICAgICAgICAgICAgICAgICAgIFt0aGlzLmxlZnQsIHRoaXMuYm90dG9tXSxcbiAgICAgICAgICAgICAgICAgICBbdGhpcy5yaWdodCwgdGhpcy50b3BdLFxuICAgICAgICAgICAgICAgICAgIFt0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbV1cbiAgICAgICAgICAgICAgICAgIF0ubWFwKGxpbmVQb3NpdGlvbik7XG5cbiAgIHZhciBub05lZ2F0aXZlID0gdHJ1ZTtcbiAgIHZhciBub1Bvc2l0aXZlID0gdHJ1ZTtcbiAgIHZhciBub1plcm8gPSB0cnVlO1xuICAgcmVsUG9zZXMuZm9yRWFjaChmdW5jdGlvbihyZWxQb3MpIHtcbiAgICAgIGlmIChyZWxQb3MgPiAwKSB7XG4gICAgICAgICBub1Bvc2l0aXZlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHJlbFBvcyA8IDApIHtcbiAgICAgICAgIG5vTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocmVsUG9zID09PSAwKSB7XG4gICAgICAgICBub1plcm8gPSBmYWxzZTtcbiAgICAgIH1cbiAgIH0sIHRoaXMpO1xuXG4gICBpZiAoIChub05lZ2F0aXZlIHx8IG5vUG9zaXRpdmUpICYmIG5vWmVybykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxuICAgcmV0dXJuICEoKHgxID4gdGhpcy5yaWdodCAmJiB4MiA+IHRoaXMucmlnaHQpIHx8XG4gICAgICAgICAgICAoeDEgPCB0aGlzLmxlZnQgJiYgeDIgPCB0aGlzLmxlZnQpIHx8XG4gICAgICAgICAgICAoeTEgPCB0aGlzLnRvcCAmJiB5MiA8IHRoaXMudG9wKSB8fFxuICAgICAgICAgICAgKHkxID4gdGhpcy5ib3R0b20gJiYgeTIgPiB0aGlzLmJvdHRvbSlcbiAgICAgICAgICAgICk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTdHJpbmd9IExpa2UgXCJbeCwgeV1bdywgaF1cIlxuICovXG5SZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIFtcIltcIiwgdGhpcy5sZWZ0LCBcIixcIiwgdGhpcy50b3AsIFwiXVwiLFwiIFtcIix0aGlzLndpZHRoLCBcIixcIiwgdGhpcy5oZWlnaHQsIFwiXVwiXS5qb2luKFwiXCIpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Z2FtZWpzLlJlY3R9IEEgbmV3IGNvcHkgb2YgdGhpcyByZWN0XG4gKi9cblJlY3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gbmV3IFJlY3QodGhpcyk7XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5hbmltYXRlID0gcmVxdWlyZSgnLi9nYW1lanMvYW5pbWF0ZScpO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydHMuZXZlbnQgPSByZXF1aXJlKCcuL2dhbWVqcy9ldmVudCcpO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydHMuZm9udCA9IHJlcXVpcmUoJy4vZ2FtZWpzL2ZvbnQnKTtcbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLmh0dHAgPSByZXF1aXJlKCcuL2dhbWVqcy9odHRwJyk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5pbWFnZSA9IHJlcXVpcmUoJy4vZ2FtZWpzL2ltYWdlJyk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5hdWRpbyA9IHJlcXVpcmUoJy4vZ2FtZWpzL2F1ZGlvJyk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5ncmFwaGljcyA9IHJlcXVpcmUoJy4vZ2FtZWpzL2dyYXBoaWNzJyk7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLmxvZ2dpbmcgPSByZXF1aXJlKCcuL2dhbWVqcy9sb2dnaW5nJyk7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLm1hdGggPSB7XG4gICBtYXRyaXg6IHJlcXVpcmUoJy4vZ2FtZWpzL21hdGgvbWF0cml4JyksXG4gICB2ZWN0b3JzOiByZXF1aXJlKCcuL2dhbWVqcy9tYXRoL3ZlY3RvcnMnKSxcbiAgIGFuZ2xlczogcmVxdWlyZSgnLi9nYW1lanMvbWF0aC9hbmdsZXMnKSxcbiAgIGJpbmFyeWhlYXA6IHJlcXVpcmUoJy4vZ2FtZWpzL21hdGgvYmluYXJ5aGVhcCcpLFxuICAgcmFuZG9tOiByZXF1aXJlKCcuL2dhbWVqcy9tYXRoL3JhbmRvbScpLFxuICAgbm9pc2U6IHJlcXVpcmUoJy4vZ2FtZWpzL21hdGgvbm9pc2UnKSxcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLnV0aWxzID0ge1xuICAgYXJyYXlzOiByZXF1aXJlKCcuL2dhbWVqcy91dGlscy9hcnJheXMnKSxcbiAgIG9iamVjdHM6IHJlcXVpcmUoJy4vZ2FtZWpzL3V0aWxzL29iamVjdHMnKSxcbiAgIHVyaTogcmVxdWlyZSgnLi9nYW1lanMvdXRpbHMvdXJpJyksXG4gICBzdHJpbmdzOiByZXF1aXJlKCcuL2dhbWVqcy91dGlscy9zdHJpbmdzJyksXG4gICB4bWw6IHJlcXVpcmUoJy4vZ2FtZWpzL3V0aWxzL3htbCcpLFxuICAgYmFzZTY0OiByZXF1aXJlKCcuL2dhbWVqcy91dGlscy9iYXNlNjQnKVxufTtcbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLmRpc3BsYXkgPSByZXF1aXJlKCcuL2dhbWVqcy9kaXNwbGF5Jyk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5wYXRoZmluZGluZyA9IHJlcXVpcmUoJy4vZ2FtZWpzL3BhdGhmaW5kaW5nJyk7XG5cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydHMudGlsZWRtYXAgPSByZXF1aXJlKCcuL2dhbWVqcy90aWxlZG1hcCcpO1xuXG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLnRpbWUgPSByZXF1aXJlKCcuL2dhbWVqcy90aW1lJyk7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLnBpeGVsY29sbGlzaW9uID0gcmVxdWlyZSgnLi9nYW1lanMvcGl4ZWxjb2xsaXNpb24nKTsiLCJ2YXIgZ2FtZWpzID0gcmVxdWlyZSgnLi4vZ2FtZWpzJyk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBgQW5pbWF0aW9uc2Agb24gdG9wIG9mIGBTcHJpdGVTaGVldHNgLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgc3ByaXRlU2hlZXQgPSBuZXcgU3ByaXRlU2hlZXQoc2hlZXRTdXJmYWNlLCB7d2lkdGg6IDE2LCBoZWlnaHQ6IDE2fSk7XG4gKiB2YXIgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihzcHJpdGVTaGVldCwge3dhbGs6IFswLDEsMiwzXSwgbG9vcDogdHJ1ZX0pO1xuICogYW5pbWF0aW9uLnNldFN0YXRlKCd3YWxrJyk7XG4gKiAuLi4uXG4gKiBhbmltYXRpb24udXBkYXRlKG1zRHVyYXRpb24pXG4gKiAuLi4uXG4gKiBkaXNwbGF5LmJsaXQoYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSk7XG4gKlxuICovXG5cbi8qKlxuICogVHVybiBhIFN1cmZhY2UgaW50byBhIFNwcml0ZVNoZWV0LiBUaGlzIG1ha2VzIGluZGl2aWR1YWwgaW1hZ2VzIChcInRpbGVzXCIpIHdpdGhpbiB0aGVcbiAqIGxhcmdlciBTdXJmYWNlIHJldHJpZXZhYmxlIHdpdGggdGhlIFNwcml0ZVNoZWV0J3MgYGdldChpbmRleFBvc2l0b24pYCBtZXRob2QuXG4gKlxuICogQXZhaWxhYmxlIG9wdGlvbiBwcm9wZXJ0aWVzIGFyZSAod2lkdGggYW5kIGhlaWdodCBhcmUgcmVxdWlyZWQpOlxuICpcbiAqICAqIGB3aWR0aGAgaW5kaXZpZHVhbCB0aWxlLCBudW1iZXJcbiAqICAqIGBoZWlnaHRgIG9mIGluZGl2aWR1YWwgdGlsZSwgbnVtYmVyXG4gKiAgKiBgc3BhY2luZ2AgYmV0d2VlbiB0d28gdGlsZXMsIG51bWJlclxuICogICogYG1hcmdpbmAgYXQgdGhlIGltYWdlIGJvcmRlciB3aXRob3V0IHRpbGVzLCBudW1iZXJcbiAqICAqIGBzY2FsZVRvYCBbd2lkdGgsaGVpZ2h0XSBzY2FsZSB0aWxlcyB0byB0aGlzIHNpemUgYWZ0ZXIgbG9hZGluZ1xuICogICpcbiAqXG4gKiBAcGFyYW0ge1N1cmZhY2V9IGltYWdlIGNvbnRhaW5pbmcgdGhlIGluZGl2aWR1YWwgdGlsZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGRlc2NyaWJpbmcgdGhlIHRpbGUgZGltZW5zaW9ucywgc2l6ZSwgc3BhY2luZywgZXRjLiAoc2VlIGFib3ZlKVxuICovXG52YXIgU3ByaXRlU2hlZXQgPSBleHBvcnRzLlNwcml0ZVNoZWV0ID0gZnVuY3Rpb24oaW1hZ2UsIG9wdHMpIHtcbiAgICAvKiogQGlnbm9yZSAqKi9cbiAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aDtcbiAgICAvKiogQGlnbm9yZSAqKi9cbiAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIC8qKiBAaWdub3JlICoqL1xuICAgIHRoaXMuc3BhY2luZyA9IG9wdHMuc3BhY2luZyB8fCAwO1xuICAgIC8qKiBAaWdub3JlICoqL1xuICAgIHRoaXMubWFyZ2luID0gb3B0cy5tYXJnaW4gfHwgMDtcbiAgICAvKiogQGlnbm9yZSAqKi9cbiAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG5cbiAgICAvKiogQGlnbm9yZSAqKi9cbiAgICB0aGlzLnN1cmZhY2VDYWNoZSA9IFtdO1xuXG4gICAgdmFyIGltZ1NpemUgPSBuZXcgZ2FtZWpzLlJlY3QoWzAsMF0sW3RoaXMud2lkdGgsdGhpcy5oZWlnaHRdKTtcbiAgICBpZiAob3B0cy5zY2FsZVRvKSB7XG4gICAgICAgIGltZ1NpemUgPSBuZXcgZ2FtZWpzLlJlY3QoWzAsMF0sIG9wdHMuc2NhbGVUbyk7XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCB0aGUgY2VsbHMgZnJvbSB0aGUgc3ByaXRlc2hlZXQgaW1hZ2UuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMubWFyZ2luOyBpIDwgdGhpcy5pbWFnZS5yZWN0LmhlaWdodDsgaSArPSB0aGlzLmhlaWdodCArIHRoaXMuc3BhY2luZykge1xuICAgICAgICBmb3IgKHZhciBqID0gdGhpcy5tYXJnaW47IGogPCB0aGlzLmltYWdlLnJlY3Qud2lkdGg7IGogKz0gdGhpcy53aWR0aCArIHRoaXMuc3BhY2luZykge1xuICAgICAgICAgICAgdmFyIHN1cmZhY2UgPSBuZXcgZ2FtZWpzLmdyYXBoaWNzLlN1cmZhY2UoW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBnYW1lanMuUmVjdChqLCBpLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAvL3N1cmZhY2UuX2NvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzdXJmYWNlLmJsaXQodGhpcy5pbWFnZSwgaW1nU2l6ZSwgcmVjdCk7XG4gICAgICAgICAgICB0aGlzLnN1cmZhY2VDYWNoZS5wdXNoKHN1cmZhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgdGlsZSBhdCBnaXZlbiBpbmRleCBwb3NpdGlvbi4gVGhlIGluZGV4IHBvc2l0aW9uIGNhbiBiZSBjYWxjdWxhdGVkIGFzOlxuXG4gKiAgICBpbmRleCA9IGNvbHVtbiArIHJvdyAqIHJvd0xlbmd0aFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHJldHVybnMge1N1cmZhY2V9IHRoZSB0aWxlIHN1cmZhY2VcbiAqL1xuU3ByaXRlU2hlZXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cmZhY2VDYWNoZVtpbmRleF07XG59O1xuXG4vKipcbiAqIEFuIEFuaW1hdGlvbiBpcyBhIGdhbWVqcy5hbmltYXRlLlNwcml0ZVNoZWV0IHdpdGggYW4gYW5pbWF0aW9uIHNwZWNpZmljYXRpb24gd2hpY2hcbiAqIGV4cGxhaW5zIHdoYXQgc3RhdGVzIHRoZSBhbmltYXRpb24gaGFzIGFuZCB3aGljaCB0aWxlcyBpbiB0aGUgU3ByaXRlU2hlZXQgY29tcG9zZVxuICogdGhvc2Ugc3RhdGVzLlxuICpcbiAqIEFuIGFuaW1hdGlvbiBzcGVjaWZpY2F0aW9uIG1pZ2h0IGxvb2sgbGlrZSB0aGlzOlxuICogICAgICAgdmFyIG5wY0FuaW1hdGlvblNwZWMgPSB7XG4gKiAgICAgICAgICAgaWRsZToge2ZyYW1lczogWzBdLCByYXRlOiA1LCBsb29wOiB0cnVlfSxcbiAqICAgICAgICAgICBtb3ZldXA6IHtmcmFtZXM6IFswLDEsMiwzLDQsNSw2LDcsOF0sIHJhdGU6IHJhdGUsIGxvb3A6IHRydWV9LFxuICogICAgICAgICAgIGRpZToge2ZyYW1lczogWzE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2XSwgcmF0ZTogcmF0ZSwgbG9vcDogdHJ1ZX0sXG4gKiAgICAgICAgICAgLi4uLlxuICogICAgICAgfTtcbiAqXG4gKiAgVGhlIGtleXMgaW4gdGhlIG5wY0FuaW1hdGlvblNwZWMgYXJlIHRoZSBhbmltYXRpb24gc3RhdGUgbmFtZXMgYW5kIGVhY2ggb2JqZWN0XG4gKiBpcyBkZXNjcmliaW5nIG9uIHN1Y2ggc3RhdGU6IGBmcmFtZXNgIGFyZSB0aGUgaW5kZXggcG9zaXRpb25zIG9mIHRoZSB0aWxlcyBpbiB0aGVcbiAqIFNwcml0ZVNoZWV0IG1ha2luZyB1cCB0aGF0IHN0YXRlLiBgcmF0ZWAgaXMgdGhlIGZyZXF1ZW5jZSBwZXIgc2Vjb25kIGF0IHdoaWNoIHRoZVxuICogc3RhdGUgc2hvdWxkIHN3aXRjaCBmcm9tIHRpbGUgdG8gdGlsZSBvZiB0aGUgc3RhdGUgYW5kIGBsb29wYCBkZXNpZ25hdGVzIHdoZXRoZXJcbiAqIHRoZSBzdGF0ZSBzaG9sZCBlbmQgb3IgbG9vcCBlbmRsZXNzbHkuXG4gKlxuICogQHBhcmFtIHtnYW1lanMuYW5pbWF0ZS5TcHJpdGVTaGVldH0gc3ByaXRlU2hlZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbml0aWFsU3RhdGUgbmFtZSBvZiB0aGUgaW5pdGl0YWwgc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbmltYXRpb25TcGVjaWZpY2F0aW9uXG4gKlxuICovXG52YXIgQW5pbWF0aW9uID0gZXhwb3J0cy5BbmltYXRpb24gPSBmdW5jdGlvbihzcHJpdGVTaGVldCwgaW5pdGlhbCwgc3BlYykge1xuICAgIC8qKiBAaWdub3JlICoqL1xuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG5cbiAgICAvKiogVGhlIGN1cnJlbnQgdGlsZSBzdXJmYWNlIG9mIHRoZSBhbmltYXRpb24uIERyYXcgdGhpcyB0byB0aGUgc2NyZWVuLiAqKi9cbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IG51bGw7XG4gICAgLyoqIEBpZ25vcmUgKiovXG4gICAgdGhpcy5jdXJyZW50RnJhbWVEdXJhdGlvbiA9IDA7XG4gICAgLyoqIEBpZ25vcmUgKiovXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gbnVsbDtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHRoaXMuX2lzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAvKiogQGlnbm9yZSAqKi9cbiAgICB0aGlzLnNwcml0ZVNoZWV0ID0gc3ByaXRlU2hlZXQ7XG4gICAgLyoqIEBpZ25vcmUgKiovXG4gICAgdGhpcy5pbWFnZSA9IHNwcml0ZVNoZWV0LmdldCgwKTtcbiAgICB0aGlzLnN0YXJ0KGluaXRpYWwpO1xuXG59O1xuXG4vKiogQGlnbm9yZSAqKi9cbkFuaW1hdGlvbi5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbihmcmFtZSkge1xuICAgIHRoaXMuZnJhbWVJbmRleCA9IGZyYW1lO1xufTtcblxuLyoqIEBpZ25vcmUgKiovXG5BbmltYXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHRoaXMuX2lzRmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNldFN0YXRlKG5hbWUpO1xuICAgIHRoaXMudXBkYXRlKDApO1xuICAgIHJldHVybjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBhbmltYXRpb24gdG8gdGhlIGdpdmVuIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZU5hbWVcbiAqL1xuQW5pbWF0aW9uLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBuYW1lO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5zcGVjW25hbWVdLmZyYW1lc1swXTtcbiAgICB0aGlzLmZyYW1lSW5kZXggPSAwO1xuICAgIHRoaXMuY3VycmVudEZyYW1lRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyB0aGlzLnNwZWNbbmFtZV0ucmF0ZTtcbn07XG5cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIGV2ZXJ5IHRpY2sgdG8gdXBkYXRlIHRoZSBhbmltYXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zRHVyYXRpb24gc2luY2UgbGFzdCB0aWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBhbmltYXRpb24gaW1hZ2UgaGFzIGNoYW5nZWQgZHVyaW5nIHRoaXMgdXBkYXRlXG4gKi9cbkFuaW1hdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24obXNEdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYW5pbWF0aW9uIHN0YXJ0ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50RnJhbWVEdXJhdGlvbiArPSBtc0R1cmF0aW9uO1xuICAgIGlmICh0aGlzLmN1cnJlbnRGcmFtZUR1cmF0aW9uID49IHRoaXMuZnJhbWVEdXJhdGlvbiAmJiB0aGlzLl9pc0ZpbmlzaGVkID09PSBmYWxzZSl7XG4gICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLnNwZWNbdGhpcy5jdXJyZW50QW5pbWF0aW9uXS5mcmFtZXM7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZXNbdGhpcy5mcmFtZUluZGV4KytdO1xuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZUR1cmF0aW9uID0gMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5zcGVjW3RoaXMuY3VycmVudEFuaW1hdGlvbl0uZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lSW5kZXggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWNbdGhpcy5jdXJyZW50QW5pbWF0aW9uXS5sb29wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lc1t0aGlzLmZyYW1lSW5kZXhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lSW5kZXgtLTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lc1t0aGlzLmZyYW1lSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1hZ2UgPSB0aGlzLnNwcml0ZVNoZWV0LmdldCh0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogV2hldGhlciB0aGUgYW5pbWF0aW9uIGhhcyBlbmRlZC4gTG9vcGluZyBhbmltYXRpb25zIG5ldmVyIGVuZC5cbiAqL1xuQW5pbWF0aW9uLnByb3RvdHlwZS5pc0ZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzRmluaXNoZWQ7XG59O1xuIiwidmFyIGdhbWVqcyA9IHJlcXVpcmUoJy4uL2dhbWVqcycpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUGxheWluZyBzb3VuZHMgd2l0aCB0aGUgaHRtbDUgYXVkaW8gdGFnLiBBdWRpbyBmaWxlcyBtdXN0IGJlIHByZWxvYWRlZFxuICogd2l0aCB0aGUgdXN1YWwgYGdhbWVqcy5wcmVsb2FkKClgIGZ1bmN0aW9uLiBPZ2csIHdhdiBhbmQgd2VibSBzdXBwb3J0ZWQuXG4gKlxuICovXG5cbnZhciBDQUNIRSA9IHt9O1xuXG4vKipcbiAqIG5lZWQgdG8gZXhwb3J0IHByZWxvYWRpbmcgc3RhdHVzIGZvciByZXF1aXJlXG4gKiBAaWdub3JlXG4gKi9cbnZhciBfUFJFTE9BRElORyA9IGZhbHNlO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xudmFyIE5VTV9DSEFOTkVMUyA9IDg7XG5cbi8qKlxuICogU2V0cyB0aGUgbnVtYmVyIG9mIGF2YWlsYWJsZSBjaGFubmVscyBmb3IgdGhlIG1peGVyLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA4LlxuICovXG5leHBvcnRzLnNldE51bUNoYW5uZWxzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgIE5VTV9DSEFOTkVMUyA9IHBhcnNlSW50KGNvdW50LCAxMCkgfHwgTlVNX0NIQU5ORUxTO1xufTtcblxuZXhwb3J0cy5nZXROdW1DaGFubmVscyA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIE5VTV9DSEFOTkVMUztcbn07XG5cbi8qKlxuICogcHV0IGFsbCBhdWRpb3Mgb24gcGFnZSBpbiBjYWNoZVxuICogaWYgc2FtZSBkb21haW4gYXMgY3VycmVudCBwYWdlLCByZW1vdmUgY29tbW9uIGhyZWYtcHJlZml4XG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgdmFyIGF1ZGlvcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYXVkaW9cIiksIDApO1xuICAgYWRkVG9DYWNoZShhdWRpb3MpO1xuICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBQcmVsb2FkIHRoZSBhdWRpb3MgaW50byBjYWNoZVxuICogQHBhcmFtIHtTdHJpbmdbXX0gTGlzdCBvZiBhdWRpbyBVUklzIHRvIGxvYWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd2hpY2ggcmV0dXJucyAwLTEgZm9yIHByZWxvYWQgcHJvZ3Jlc3NcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5wcmVsb2FkID0gZnVuY3Rpb24oYXVkaW9VcmxzLCBzaG93UHJvZ3Jlc3NPckltYWdlKSB7XG4gICB2YXIgY291bnRUb3RhbCA9IDA7XG4gICB2YXIgY291bnRMb2FkZWQgPSAwO1xuXG4gICBmdW5jdGlvbiBpbmNyZW1lbnRMb2FkZWQoKSB7XG4gICAgICBjb3VudExvYWRlZCsrO1xuICAgICAgaWYgKGNvdW50TG9hZGVkID09IGNvdW50VG90YWwpIHtcbiAgICAgICAgIF9QUkVMT0FESU5HID0gZmFsc2U7XG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGdldFByb2dyZXNzKCkge1xuICAgICAgcmV0dXJuIGNvdW50VG90YWwgPiAwID8gY291bnRMb2FkZWQgLyBjb3VudFRvdGFsIDogMTtcbiAgIH1cblxuICAgZnVuY3Rpb24gc3VjY2Vzc0hhbmRsZXIoKSB7XG4gICAgICBhZGRUb0NhY2hlKHRoaXMpO1xuICAgICAgaW5jcmVtZW50TG9hZGVkKCk7XG4gICB9XG4gICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoKSB7XG4gICAgICBpbmNyZW1lbnRMb2FkZWQoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgbG9hZGluZyAnICsgdGhpcy5zcmMpO1xuICAgfVxuXG4gICBmb3IgKHZhciBrZXkgaW4gYXVkaW9VcmxzKSB7XG4gICAgICBpZiAoa2V5LmluZGV4T2YoJ3dhdicpID09IC0xICYmIGtleS5pbmRleE9mKCdvZ2cnKSA9PSAtMSAmJiBrZXkuaW5kZXhPZignd2VibScpID09IC0xKSB7XG4gICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvdW50VG90YWwrKztcbiAgICAgIHZhciBhdWRpbyA9IG5ldyBBdWRpbygpO1xuICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIHN1Y2Nlc3NIYW5kbGVyLCB0cnVlKTtcbiAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyLCB0cnVlKTtcbiAgICAgIGF1ZGlvLnNyYyA9IGF1ZGlvVXJsc1trZXldO1xuICAgICAgYXVkaW8uZ2FtZWpzS2V5ID0ga2V5O1xuICAgICAgYXVkaW8ubG9hZCgpO1xuICAgfVxuICAgaWYgKGNvdW50VG90YWwgPiAwKSB7XG4gICAgICBfUFJFTE9BRElORyA9IHRydWU7XG4gICB9XG4gICByZXR1cm4gZ2V0UHJvZ3Jlc3M7XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5pc1ByZWxvYWRpbmcgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBfUFJFTE9BRElORztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtkb20uSW1nRWxlbWVudH0gYXVkaW9zIHRoZSA8YXVkaW8+IGVsZW1lbnRzIHRvIHB1dCBpbnRvIGNhY2hlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGFkZFRvQ2FjaGUoYXVkaW9zKSB7XG4gICBpZiAoIShhdWRpb3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIGF1ZGlvcyA9IFthdWRpb3NdO1xuICAgfVxuXG4gICB2YXIgZG9jTG9jID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgIGF1ZGlvcy5mb3JFYWNoKGZ1bmN0aW9uKGF1ZGlvKSB7XG4gICAgICBDQUNIRVthdWRpby5nYW1lanNLZXldID0gYXVkaW87XG4gICB9KTtcbiAgIHJldHVybjtcbn1cblxuLyoqXG4gKiBTb3VuZHMgY2FuIGJlIHBsYXllZCBiYWNrLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ3xkb20uQXVkaW9FbGVtZW50fSB1cmlPckF1ZGlvIHRoZSB1cmkgb2YgPGF1ZGlvPiBkb20gZWxlbWVudFxuICogICAgICAgICAgICAgICAgb2YgdGhlIHNvdW5kXG4gKi9cbmV4cG9ydHMuU291bmQgPSBmdW5jdGlvbiBTb3VuZCh1cmlPckF1ZGlvKSB7XG4gICB2YXIgY2FjaGVkQXVkaW87XG4gICBpZiAodHlwZW9mIHVyaU9yQXVkaW8gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjYWNoZWRBdWRpbyA9IENBQ0hFW3VyaU9yQXVkaW9dO1xuICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlZEF1ZGlvID0gdXJpT3JBdWRpbztcbiAgIH1cbiAgIGlmICghY2FjaGVkQXVkaW8pIHtcbiAgICAgIC8vIFRPRE8gc3luYyBhdWRpbyBsb2FkaW5nXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCInICsgdXJpT3JBdWRpbyArICdcIiwgZ2FtZWpzLnByZWxvYWQoKSBhbGwgYXVkaW8gZmlsZXMgYmVmb3JlIGxvYWRpbmcnKTtcbiAgIH1cblxuICAgdmFyIGNoYW5uZWxzID0gW107XG4gICB2YXIgaSA9IE5VTV9DSEFOTkVMUztcbiAgIHdoaWxlIChpLS0+MCkge1xuICAgICAgdmFyIGF1ZGlvID0gbmV3IEF1ZGlvKCk7XG4gICAgICBhdWRpby5wcmVsb2FkID0gXCJhdXRvXCI7XG4gICAgICBhdWRpby5sb29wID0gZmFsc2U7XG4gICAgICBhdWRpby5zcmMgPSBjYWNoZWRBdWRpby5zcmM7XG4gICAgICBjaGFubmVscy5wdXNoKGF1ZGlvKTtcbiAgIH1cbiAgIC8qKlxuICAgICogc3RhcnQgdGhlIHNvdW5kXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvb3Agd2hldGhlciB0aGUgYXVkaW8gc2hvdWxkIGxvb3AgZm9yIGV2ZXIgb3Igbm90XG4gICAgKi9cbiAgIHRoaXMucGxheSA9IGZ1bmN0aW9uKGxvb3ApIHtcbiAgICAgIGNoYW5uZWxzLnNvbWUoZnVuY3Rpb24oYXVkaW8pIHtcbiAgICAgICAgIGlmIChhdWRpby5lbmRlZCB8fCBhdWRpby5wYXVzZWQpIHtcbiAgICAgICAgICAgIGF1ZGlvLmxvb3AgPSAhIWxvb3A7XG4gICAgICAgICAgICBhdWRpby5wbGF5KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBTdG9wIHRoZSBzb3VuZC5cbiAgICAqIFRoaXMgd2lsbCBzdG9wIHRoZSBwbGF5YmFjayBvZiB0aGlzIFNvdW5kIG9uIGFueSBhY3RpdmUgQ2hhbm5lbHMuXG4gICAgKi9cbiAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2hhbm5lbHMuZm9yRWFjaChmdW5jdGlvbihhdWRpbykge1xuICAgICAgICAgYXVkaW8uc3RvcCgpO1xuICAgICAgfSk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIFNldCB2b2x1bWUgb2YgdGhpcyBzb3VuZFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZvbHVtZSBmcm9tIDAgdG8gMVxuICAgICovXG4gICB0aGlzLnNldFZvbHVtZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjaGFubmVscy5mb3JFYWNoKGZ1bmN0aW9uKGF1ZGlvKSB7XG4gICAgICAgICBhdWRpby52b2x1bWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgc291bmQncyB2b2x1bWUgZnJvbSAwIHRvIDFcbiAgICAqL1xuICAgdGhpcy5nZXRWb2x1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjaGFubmVsc1swXS52b2x1bWU7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IER1cmF0aW9uIG9mIHRoaXMgc291bmQgaW4gc2Vjb25kc1xuICAgICovXG4gICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNoYW5uZWxzWzBdLmR1cmF0aW9uO1xuICAgfTtcblxuICAgcmV0dXJuIHRoaXM7XG59O1xuIiwidmFyIFN1cmZhY2UgPSByZXF1aXJlKCcuL2dyYXBoaWNzJykuU3VyZmFjZTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1ldGhvZHMgdG8gY3JlYXRlLCBhY2Nlc3MgYW5kIG1hbmlwdWxhdGUgdGhlIGRpc3BsYXkgU3VyZmFjZS5cbiAqXG4gKiBZb3UgY2FuIGp1c3QgZ3JhYiB0aGUgY2FudmFzIGVsZW1lbnQgd2hldGhlciBpdCBleGlzdHMgaW4gdGhlIERPTSBvciBub3QgKEdhbWVKc1xuICogd2lsbCBjcmVhdGUgaXQgaWYgbmVjZXNzYXJ5KTpcbiAqXG4gKiAgICAgdmFyIGRpc3BsYXkgPSBnYW1lanMuZGlzcGxheS5nZXRTdXJmYWNlKCk7XG4gKlxuICogSWYgeW91IG5lZWQgdG8gcmVzaXplIHRoZSBjYW52YXMgLSBhbHRob3VnaCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdHlsZSBpdCB3aXRoIENTUyAtIHlvdSBjYW5cbiAqIGNhbGwgdGhlIGBzZXRNb2RlKClgIGZ1bmN0aW9uLCB3aGljaCBjb252aW5pZW50bHkgcmV0dXJucyB0aGUgbmV3IGRpc3BsYXkgc3VyZmFjZTpcbiAqXG4gKiAgICAgbmV3RGlzcGxheSA9IGdhbWVqcy5kaXNwbGF5LnNldE1vZGUoWzgwMCwgNjAwXSk7XG4gKlxuICogIyMjIEJyb3dzZXIgd2luZG93IGdldHMgcmVzaXplZFxuICpcbiAqIFdoZW4gdGhlIGNhbnZhcyBzaXplIGlzIGNvbmZpZ3VyZWQgd2l0aCBDU1MsIHRoZSBkaXNwbGF5IHN1cmZhY2UgbWlnaHQgY2hhbmdlIHdoZW5cbiAqIHRoZSBicm93c2VyIHdpbmRvdyBpcyByZXNpemVkLiBHYW1lSnMgd2lsbCBpbnRlcm5hbGx5IGRlYWwgd2l0aCB0aGlzIGFuZCByZWNyZWF0ZVxuICogdGhlIHRoZSBkaXNwbGF5IHN1cmZhY2Ugd2l0aCB0aGUgbmV3IHNpemUuXG4gKlxuICogWW91IHdpbGwgdHlwaWNhbGx5IG5vdCBoYXZlIHRvIHdvcnJ5IGFib3V0IHRoaXMgYnV0IGlmIHlvdSB3YW50IHRvIGdldCBpbmZvcm1lZFxuICogYWJvdXQgYSBkaXNwbGF5IHJlc2l6ZSwgeW91IGNhbiByZWdpc3RlciBhIGNhbGxiYWNrIHdpdGggYGdhbWVqcy5ldmVudC5vbkRpc3BsYXlSZXNpemVgLlxuICpcbiAqXG4gKiAjIyMgRmxhZ3NcbiAqXG4gKiBGb3IgYWR2YW5jZWQgdXNlcyB5b3UgY2FuIHNldCBhIGZldyBtb2RlcyB3aGljaCBhZGRpdGlvbmFsbHkgY2hhbmdlIGhvdyB0aGUgZGlzcGxheVxuICogYmVoYXZlcyB3aXRoIHJlZ2FyZHMgdG8gcGl4ZWwgc21vb3RoaW5nIGFuZCB3aGV0aGVyIHlvdSB3YW50IGEgZnVsbHNjcmVlbiBjYW52YXMgd2l0aFxuICogb3Igd2l0aG91dGggdGhlIG1vdXNlIHBvaW50ZXIgbG9ja2VkIGluc2lkZSB0aGUgd2luZG93IChmb3IgZW5kbGVzcyBtb3VzZSBtb3ZlbWVudCBpblxuICogYWxsIGRpcmVjdGlvbnMpLlxuICpcbiAqXG4gKiBgZ2FtZWpzLmRpc3BsYXkuc2V0TW9kZSgpYCB1bmRlcnN0YW5kcyB0aHJlZSBmbGFnczpcbiAqXG4gKiAgICogZ2FtZWpzLmRpc3BsYXkuRlVMTFNDUkVFTlxuICogICAqIGdhbWVqcy5kaXNwbGF5LkRJU0FCTEVfU01PT1RISU5HXG4gKiAgICogZ2FtZWpzLmRpc3BsYXkuUE9JTlRFUkxPQ0sgKGltcGxpZXMgRlVMTFNDUkVFTilcbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqICAgICAgLy8gZGlzYWJsZSBzbW9vdGhpbmdcbiAqICAgICAgZ2FtZWpzLmRpc3BsYXkuc2V0TW9kZShbODAwLCA2MDBdLCBnYW1lanMuZGlzcGxheS5ESVNBQkxFX1NNT09USElORyk7XG4gKiAgICAgIC8vIGRpc2FibGUgc21vb3RoaW5nIGFuZCBmdWxsc2NyZWVuXG4gKiAgICAgIGdhbWVqcy5kaXNwbGF5LnNldE1vZGUoXG4gICAgICAgICAgICAgICBbODAwLCA2MDBdLFxuICAgICAgICAgICAgICAgZ2FtZWpzLmRpc3BsYXkuRElTQUJMRV9TTU9PVEhJTkcgfCBnYW1lanMuZGlzcGxheS5GVUxMU0NSRUVOXG4gICAgICAgICApO1xuICpcbiAqICMjIyBGdWxsc2NyZWVuIG1vZGVcbiAqXG4gKiBXaGVuIGBzZXRNb2RlKClgIGlzIGNhbGxlZCB3aXRoIHRoZSBmdWxsc2NyZWVuIGZsYWcgdGhlbiB0aGUgZnVsbHNjcmVlbiBtb2RlIGNhbiBiZSBlbmFibGVkIGJ5IHRoZVxuICogcGxheWVyIGJ5IGNsaWNraW5nIG9uIHRoZSBET00gZWxlbWVudCB3aXRoIGlkIFwiZ2pzLWZ1bGxzY3JlZW4tdG9nZ2xlXCIuIEJyb3dzZXIgc2VjdXJpdHkgcmVxdWlyZXNcbiAqIHRoYXQgYSB1c2VyIGVuYWJsZXMgZnVsbHNjcmVlbiB3aXRoIGEgXCJnZXN0dXJlXCIgKGUuZy4sIGNsaWNraW5nIGEgYnV0dG9uKSBhbmQgd2UgY2FuIG5vdCBlbmFibGUgZnVsbHNjcmVlblxuICogaW4gY29kZS5cbiAqXG4gKiBGdWxsc2NyZWVuIG1vZGUgY2FuIGJlIGV4aXRlZCBieSBtYW55IGtleXMsIGUuZy4sIGFueXRoaW5nIHdpbmRvdyBtYW5hZ2VyIHJlbGF0ZWQgKEFMVC1UQUIpIG9yIEVTQy4gQSBsb3RcbiAqIG9mIGtleXMgd2lsbCB0cmlnZ2VyIGEgYnJvd3NlciBpbmZvcm1hdGlvbiBwb3B1cCBleHBsYWluaW5nIGhvdyBmdWxsc2NyZWVuIG1vZGUgY2FuIGJlIGV4aXRlZC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGtleXMgYXJlIFwid2hpdGVsaXN0ZWRcIiBpbiBmdWxsc2NyZWVuIG1vZGUgYW5kIHdpbGwgbm90IHRyaWdnZXIgc3VjaCBhIGJyb3dzZXIgcG9wdXA6XG4gKlxuICogICogbGVmdCBhcnJvdywgcmlnaHQgYXJyb3csIHVwIGFycm93LCBkb3duIGFycm93XG4gKiAgKiBzcGFjZVxuICogICogc2hpZnQsIGNvbnRyb2wsIGFsdFxuICogICogcGFnZSB1cCwgcGFnZSBkb3duXG4gKiAgKiBob21lLCBlbmQsIHRhYiwgbWV0YVxuICpcbiAqXG4gKiAjIyMgUmVsZXZhbnQgRE9NIG5vZGUgaWRzIGFjY2Vzc2VkIGJ5IHRoaXMgbW9kdWxlXG4gKlxuICogWW91IGNhbiBwcm92aWRlIHlvdXIgb3duIHRhZ3Mgd2l0aCB0aG9zZSBpZHNcbiAqXG4gKiAgICogZ2pzLWNhbnZhcyAtIHRoZSBkaXNwbGF5IHN1cmZhY2VcbiAqICAgKiBnanMtbG9hZGVyIC0gbG9hZGluZyBiYXJcbiAqICAgKiBnanMtZnVsbHNjcmVlbi10b2dnbGUgYSBjbGlja2FibGUgZWxlbWVudCB0byBlbmFibGUgZnVsbHNjcmVlblxuICogICAqIGdqcy1jYW52YXMtd3JhcHBlciB0aGlzIHdyYXBwZXIgaXMgYWRkZWQgd2hlbiBpbiBmdWxsc2NyZWVuIG1vZGVcbiAqXG4gKi9cblxudmFyIENBTlZBU19JRCA9IFwiZ2pzLWNhbnZhc1wiO1xudmFyIExPQURFUl9JRCA9IFwiZ2pzLWxvYWRlclwiO1xudmFyIFNVUkZBQ0UgPSBudWxsO1xuXG4vKipcbiAqIFBhc3MgdGhpcyBmbGFnIHRvIGBnYW1lanMuZGlzcGxheS5zZXRNb2RlKHJlc29sdXRpb24sIGZsYWdzKWAgdG8gZGlzYWJsZVxuICogcGl4ZWwgc21vb3RoaW5nOyB0aGlzIGlzLCBmb3IgZXhhbXBsZSwgdXNlZnVsIGZvciByZXRyby1zdHlsZSwgbG93IHJlc29sdXRpb24gZ3JhcGhpY3NcbiAqIHdoZXJlIHlvdSBkb24ndCB3YW50IHRoZSBicm93c2VyIHRvIHNtb290aCB0aGVtIHdoZW4gc2NhbGluZyAmIGRyYXdpbmcuXG4gKi9cbnZhciBESVNBQkxFX1NNT09USElORyA9IGV4cG9ydHMuRElTQUJMRV9TTU9PVEhJTkcgPSAyO1xudmFyIEZVTExTQ1JFRU4gPSBleHBvcnRzLkZVTExTQ1JFRU4gPSA0O1xudmFyIFBPSU5URVJMT0NLID0gZXhwb3J0cy5QT0lOVEVSTE9DSyA9IDg7XG5cbnZhciBfZmxhZ3MgPSAwO1xuXG4vKipcbiAqIEByZXR1cm5zIHtkb2N1bWVudC5FbGVtZW50fSB0aGUgY2FudmFzIGRvbSBlbGVtZW50XG4gKiBAaWdub3JlXG4gKi9cbnZhciBnZXRDYW52YXMgPSBleHBvcnRzLl9nZXRDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgIHZhciBkaXNwbGF5Q2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoQ0FOVkFTX0lEKTtcbiAgIGlmICghZGlzcGxheUNhbnZhcykge1xuICAgICAgZGlzcGxheUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBkaXNwbGF5Q2FudmFzLnNldEF0dHJpYnV0ZShcImlkXCIsIENBTlZBU19JRCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpc3BsYXlDYW52YXMpO1xuICAgfVxuICAgcmV0dXJuIGRpc3BsYXlDYW52YXM7XG59O1xuXG5cbnZhciBnZXRGdWxsU2NyZWVuVG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgZnVsbFNjcmVlbkJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnanMtZnVsbHNjcmVlbi10b2dnbGUnKTtcbiAgIGlmICghZnVsbFNjcmVlbkJ1dHRvbikge1xuICAgICAgLy8gYmVmb3JlIGNhbnZhc1xuICAgICAgZnVsbFNjcmVlbkJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgZnVsbFNjcmVlbkJ1dHRvbi5pbm5lckhUTUwgPSAnRnVsbHNjcmVlbic7XG4gICAgICBmdWxsU2NyZWVuQnV0dG9uLmlkID0gJ2dqcy1mdWxsc2NyZWVuLXRvZ2dsZSc7XG4gICAgICB2YXIgY2FudmFzID0gZ2V0Q2FudmFzKCk7XG4gICAgICBjYW52YXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZnVsbFNjcmVlbkJ1dHRvbiwgY2FudmFzKTtcbiAgICAgIGNhbnZhcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpLCBjYW52YXMpO1xuXG4gICB9XG4gICByZXR1cm4gZnVsbFNjcmVlbkJ1dHRvbjtcbn07XG5cbnZhciBmdWxsU2NyZWVuQ2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgIHZhciBnanNFdmVudCA9e1xuICAgICAgdHlwZTogaXNGdWxsU2NyZWVuKCkgPyByZXF1aXJlKCcuL2V2ZW50JykuRElTUExBWV9GVUxMU0NSRUVOX0VOQUJMRUQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9ldmVudCcpLkRJU1BMQVlfRlVMTFNDUkVFTl9ESVNBQkxFRFxuXG4gICB9O1xuICAgaWYgKGlzRnVsbFNjcmVlbigpKSB7XG4gICAgICBpZiAoX2ZsYWdzICYgUE9JTlRFUkxPQ0spIHtcbiAgICAgICAgIGVuYWJsZVBvaW50ZXJMb2NrKCk7XG4gICAgICB9XG4gICB9XG4gICByZXF1aXJlKCcuL2V2ZW50JykuX3RyaWdnZXJDYWxsYmFja3MoZ2pzRXZlbnQpO1xufTtcblxuZXhwb3J0cy5oYXNQb2ludGVyTG9jayA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuICEhKGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCB8fFxuICAgICAgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgIGRvY3VtZW50Lm1vekZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCk7XG59O1xuXG5mdW5jdGlvbiBvblJlc2l6ZShldmVudCkge1xuICAgdmFyIGNhbnZhcyA9IGdldENhbnZhcygpO1xuICAgU1VSRkFDRS5fY2FudmFzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgU1VSRkFDRS5fY2FudmFzLmhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICByZXF1aXJlKCcuL2V2ZW50JykuX3RyaWdnZXJDYWxsYmFja3Moe1xuICAgICAgdHlwZTogcmVxdWlyZSgnLi9ldmVudCcpLkRJU1BMQVlfUkVTSVpFXG4gICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIG1hc3RlciBDYW52YXMgcGxhbmUuXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgLy8gY3JlYXRlIGNhbnZhcyBlbGVtZW50IGlmIG5vdCB5ZXQgcHJlc2VudFxuICAgdmFyIGNhbnZhcyA9IGdldENhbnZhcygpO1xuICAgaWYgKCFjYW52YXMuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAvLyB0byBiZSBmb2N1c2FibGUsIHRhYmluZGV4IG11c3QgYmUgc2V0XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgMSk7XG4gICAgICBjYW52YXMuZm9jdXMoKTtcbiAgIH1cbiAgIC8vIHJlbW92ZSBsb2FkZXIgaWYgYW55O1xuICAgdmFyICRsb2FkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChMT0FERVJfSUQpO1xuICAgaWYgKCRsb2FkZXIpIHtcbiAgICAgICRsb2FkZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgfVxuICAgdmFyICRkaXNwbGF5U3VyZmFjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKENBTlZBU19JRCk7XG4gICBpZiAoJGRpc3BsYXlTdXJmYWNlKSB7XG4gICAgICAkZGlzcGxheVN1cmZhY2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICB9XG4gICAvLyBob29rIGludG8gcmVzaXplXG4gICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSwgZmFsc2UpO1xuICAgcmV0dXJuO1xufTtcblxudmFyIGlzRnVsbFNjcmVlbiA9IGV4cG9ydHMuaXNGdWxsc2NyZWVuID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gKGRvY3VtZW50LmZ1bGxTY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW4gfHwgZG9jdW1lbnQud2Via2l0SXNGdWxsU2NyZWVuIHx8IGRvY3VtZW50LndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuKTtcbn07XG5cbi8qKlxuICogU3dpdGNoZXMgdGhlIGRpc3BsYXkgd2luZG93IG5vcm1hbCBicm93c2VyIG1vZGUgYW5kIGZ1bGxzY3JlZW4uXG4gKiBAaWdub3JlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBvcGVyYXRpb24gd2FzIHN1Y2Nlc3NmdWxsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xudmFyIGVuYWJsZUZ1bGxTY3JlZW4gPSBmdW5jdGlvbihldmVudCkge1xuICAgdmFyIHdyYXBwZXIgPSBnZXRDYW52YXMoKTtcbiAgIHdyYXBwZXIucmVxdWVzdEZ1bGxTY3JlZW4gPSB3cmFwcGVyLnJlcXVlc3RGdWxsU2NyZWVuIHx8IHdyYXBwZXIubW96UmVxdWVzdEZ1bGxTY3JlZW4gfHwgd3JhcHBlci53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbjtcbiAgIGlmICghd3JhcHBlci5yZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxuICAgLy8gQHhicm93c2VyIGNocm9tZSBhbGxvd3Mga2Vib2FyZCBpbnB1dCBvbmwgaWYgYXNrIGZvciBpdCAod2h5IG9oIHdoeT8pXG4gICBpZiAoRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCkge1xuICAgICAgd3JhcHBlci53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbihFbGVtZW50LkFMTE9XX0tFWUJPQVJEX0lOUFVUKTtcbiAgIH0gZWxzZSB7XG4gICAgICB3cmFwcGVyLnJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gICB9XG4gICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBlbmFibGVQb2ludGVyTG9jayA9IGZ1bmN0aW9uKCkge1xuICAgdmFyIHdyYXBwZXIgPSBnZXRDYW52YXMoKTtcbiAgIHdyYXBwZXIucmVxdWVzdFBvaW50ZXJMb2NrID0gd3JhcHBlci5yZXF1ZXN0UG9pbnRlckxvY2sgfHwgd3JhcHBlci5tb3pSZXF1ZXN0UG9pbnRlckxvY2sgfHwgd3JhcHBlci53ZWJraXRSZXF1ZXN0UG9pbnRlckxvY2s7XG4gICBpZiAod3JhcHBlci5yZXF1ZXN0UG9pbnRlckxvY2spIHtcbiAgICAgIHdyYXBwZXIucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICB9XG59O1xuXG4vKiogQGlnbm9yZSAqKi9cbmV4cG9ydHMuX2hhc0ZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBnZXRDYW52YXMoKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBEaXNwbGF5LiBDb252aW5pZW50bHkgdGhpcyB3aWxsXG4gKiByZXR1cm4gdGhlIGFjdHVhbCBkaXNwbGF5IFN1cmZhY2UgLSB0aGUgc2FtZSBhcyBjYWxsaW5nIFtnYW1lanMuZGlzcGxheS5nZXRTdXJmYWNlKCldKCNnZXRTdXJmYWNlKVxuICogbGF0ZXIgb24uXG4gKiBAcGFyYW0ge0FycmF5fSBkaW1lbnNpb25zIFt3aWR0aCwgaGVpZ2h0XSBvZiB0aGUgZGlzcGxheSBzdXJmYWNlXG4gKiBAcGFyYW0ge051bWJlcn0gZmxhZ3MgZ2FtZWpzLmRpc3BsYXkuRElTQUJMRV9TTU9PVEhJTkcgfCBnYW1lanMuZGlzcGxheS5GVUxMU0NSRUVOIHwgZ2FtZWpzLmRpc3BsYXkuUE9JTlRFUkxPQ0tcbiAqL1xuZXhwb3J0cy5zZXRNb2RlID0gZnVuY3Rpb24oZGltZW5zaW9ucywgZmxhZ3MpIHtcbiAgIFNVUkZBQ0UgPSBudWxsO1xuICAgdmFyIGNhbnZhcyA9IGdldENhbnZhcygpO1xuICAgY2FudmFzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoID0gZGltZW5zaW9uc1swXTtcbiAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0ID0gZGltZW5zaW9uc1sxXTtcblxuICAgX2ZsYWdzID0gX2ZsYWdzIHx8IGZsYWdzO1xuICAgLy8gQCB4YnJvd3NlciBmaXJlZm94IGFsbG93cyBwb2ludGVybG9jayBvbmx5IGlmIGZ1bGxzY3JlZW5cbiAgIGlmIChfZmxhZ3MgJiBQT0lOVEVSTE9DSykge1xuICAgICAgX2ZsYWdzID0gX2ZsYWdzIHwgRlVMTFNDUkVFTjtcbiAgIH1cbiAgIGlmIChfZmxhZ3MgJiBGVUxMU0NSRUVOKSB7XG4gICAgICAvLyBhdHRhY2ggZnVsbHNjcmVlbiB0b2dnbGUgY2hlY2tib3hcbiAgICAgIHZhciBmdWxsU2NyZWVuVG9nZ2xlID0gZ2V0RnVsbFNjcmVlblRvZ2dsZSgpO1xuICAgICAgZnVsbFNjcmVlblRvZ2dsZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGVuYWJsZUZ1bGxTY3JlZW4sIGZhbHNlKTtcbiAgICAgIGZ1bGxTY3JlZW5Ub2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlbmFibGVGdWxsU2NyZWVuLCBmYWxzZSk7XG4gICAgICAvLyBAQCB4YnJvd3NlclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnVsbFNjcmVlbmNoYW5nZScsZnVsbFNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsZnVsbFNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW96ZnVsbHNjcmVlbmNoYW5nZScsZnVsbFNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIGZ1bGxTY3JlZW5DaGFuZ2UsIGZhbHNlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCBmdWxsU2NyZWVuQ2hhbmdlLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgZnVsbFNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuICAgfVxuICAgcmV0dXJuIGdldFN1cmZhY2UoZGltZW5zaW9ucyk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgQ2FwdGlvbiBvZiB0aGUgRGlzcGxheSAoZG9jdW1lbnQudGl0bGUpXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgdGhlIHRpdGxlIG9mIHRoZSBhcHBcbiAqIEBwYXJhbSB7Z2FtZWpzLkltYWdlfSBpY29uIEZJWE1FIGltcGxlbWVudCBmYXZpY29uIHN1cHBvcnRcbiAqL1xuZXhwb3J0cy5zZXRDYXB0aW9uID0gZnVuY3Rpb24odGl0bGUsIGljb24pIHtcbiAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG59O1xuXG4vKiogQGlnbm9yZSAqKi9cbmV4cG9ydHMuX2lzU21vb3RoaW5nRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuICEoX2ZsYWdzICYgRElTQUJMRV9TTU9PVEhJTkcpO1xufTtcblxuLyoqXG4gKiBUaGUgRGlzcGxheSAodGhlIGNhbnZhcyBlbGVtZW50KSBpcyBtb3N0IGxpa2VseSBub3QgaW4gdGhlIHRvcCBsZWZ0IGNvcm5lclxuICogb2YgdGhlIGJyb3dzZXIgZHVlIHRvIENTUyBzdHlsaW5nLiBUbyBjYWxjdWxhdGUgdGhlIG1vdXNlcG9zaXRpb24gd2l0aGluIHRoZVxuICogY2FudmFzIHdlIG5lZWQgdGhpcyBvZmZzZXQuXG4gKiBAc2VlIGdhbWVqcy9ldmVudFxuICogQGlnbm9yZVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX0gW3gsIHldIG9mZnNldCBvZiB0aGUgY2FudmFzXG4gKi9cblxuZXhwb3J0cy5fZ2V0Q2FudmFzT2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgYm91bmRSZWN0ID0gZ2V0Q2FudmFzKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICByZXR1cm4gW2JvdW5kUmVjdC5sZWZ0LCBib3VuZFJlY3QudG9wXTtcbn07XG5cbi8qKlxuICogRHJhd2luZyBvbiB0aGUgU3VyZmFjZSByZXR1cm5lZCBieSBgZ2V0U3VyZmFjZSgpYCB3aWxsIGRyYXcgb24gdGhlIHNjcmVlbi5cbiAqIEByZXR1cm5zIHtnYW1lanMuU3VyZmFjZX0gdGhlIGRpc3BsYXkgU3VyZmFjZVxuICovXG52YXIgZ2V0U3VyZmFjZSA9IGV4cG9ydHMuZ2V0U3VyZmFjZSA9IGZ1bmN0aW9uKGRpbWVuc2lvbnMpIHtcbiAgIGlmIChTVVJGQUNFID09PSBudWxsKSB7XG4gICAgICB2YXIgY2FudmFzID0gZ2V0Q2FudmFzKCk7XG4gICAgICBpZiAoZGltZW5zaW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICBkaW1lbnNpb25zID0gW2NhbnZhcy5jbGllbnRXaWR0aCwgY2FudmFzLmNsaWVudEhlaWdodF07XG4gICAgICB9XG4gICAgICBTVVJGQUNFID0gbmV3IFN1cmZhY2UoZGltZW5zaW9ucyk7XG4gICAgICBTVVJGQUNFLl9jYW52YXMgPSBjYW52YXM7XG4gICAgICBTVVJGQUNFLl9jYW52YXMud2lkdGggPSBkaW1lbnNpb25zWzBdO1xuICAgICAgU1VSRkFDRS5fY2FudmFzLmhlaWdodCA9IGRpbWVuc2lvbnNbMV07XG4gICAgICBTVVJGQUNFLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoIShfZmxhZ3MgJiBESVNBQkxFX1NNT09USElORykpIHtcbiAgICAgICAgIFNVUkZBQ0UuX3Ntb290aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIFNVUkZBQ0UuX25vU21vb3RoKCk7XG4gICAgICB9XG4gICB9XG4gICByZXR1cm4gU1VSRkFDRTtcbn07XG4iLCJ2YXIgZGlzcGxheSA9IHJlcXVpcmUoJy4vZGlzcGxheScpO1xudmFyIENhbGxiYWNrID0gcmVxdWlyZSgnLi91dGlscy9jYWxsYmFjaycpLkNhbGxiYWNrO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIERlYWwgd2l0aCBtb3VzZSBhbmQga2V5Ym9hcmQgZXZlbnRzLlxuICpcbiAqIFlvdSBjYW4gZWl0aGVyIGhhbmRsZSBhbGwgZXZlbnRzIGluIG9uZSBjYWxsYmFjayB3aXRoIGBnYW1lanMuZXZlbnQub25FdmVudCgpYDpcbiAqXG4gKiAgICAgZ2FtZWpzLm9uRXZlbnQoZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gZ2FtZWpzLmV2ZW50Lk1PVVNFX1VQKSB7XG4gKiAgICAgICAgICBnYW1lanMubG9nZ2luZy5pbmZvKGV2ZW50LnBvcywgZXZlbnQuYnV0dG9uKTtcbiAqICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IGdhbWVqcy5ldmVudC5LRVlfVVApIHtcbiAqICAgICAgICAgIGdhbWVqcy5sb2dnaW5nLmluZm8oZXZlbnQua2V5KTtcbiAqICAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogT3IgcmVjaWV2ZSBtb3JlIHNwZWNpZmljIGNhbGxiYWNrcywgZS5nLiBvbmx5IGZvciBgS0VZXFxfVVBgIHdpdGggIGBnYW1lanMuZXZlbnQub25LZXlVcCgpYDpcbiAqXG4gKiAgICAgZ2FtZWpzLm9uS2V5VXAoZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICAgICAgIGdhbWVqcy5sb2dnaW5nLmluZm8oZXZlbnQua2V5KTtcbiAqICAgICB9KTtcbiAqXG4gKiBBbGwgZXZlbnRzIHBhc3NlZCB0byB5b3VyIGNhbGxiYWNrIGFyZSBpbnN0YW5jZXMgb2YgYGdhbWVqcy5ldmVudC5FdmVudGAgYW5kIGhhdmUgYSBgdHlwZWAgcHJvcGVydHkgdG8gaGVscFxuICogeW91IGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIGRpZmZlcmVudCBldmVudHMuIFRoaXMgYHR5cGVgIHByb3BlcnR5IGlzIHNldCB0byBvbmUgb2YgdGhvc2UgY29uc3RhbnRzOlxuICpcbiAqICAqIGdhbWVqcy5ldmVudC5NT1VTRVxcX1VQXG4gKiAgKiBnYW1lanMuZXZlbnQuTU9VU0VcXF9NT1RJT05cbiAqICAqIGdhbWVqcy5ldmVudC5NT1VTRVxcX0RPV05cbiAqICAqIGdhbWVqcy5ldmVudC5LRVlcXF9VUFxuICogICogZ2FtZWpzLmV2ZW50LktFWVxcX0RPV05cbiAqICAqIGdhbWVqcy5ldmVudC5ESVNQTEFZXFxfRlVMTFNDUkVFTlxcX0VOQUJMRURcbiAqICAqIGdhbWVqcy5ldmVudC5ESVNQTEFZXFxfRlVMTFNDUkVFTlxcX0RJU0FCTEVEXG4gKiAgKiBnYW1lanMuZXZlbnQuUVVJVFxuICogICogZ2FtZWpzLmV2ZW50Lk1PVVNFX1dIRUVMXG4gKiAgKiBnYW1lanMuZXZlbnQuVE9VQ0hcXF9ET1dOXG4gKiAgKiBnYW1lanMuZXZlbnQuVE9VQ0hcXF9VUFxuICogICogZ2FtZWpzLmV2ZW50LlRPVUNIXFxfTU9USU9OXG4gKlxuICogIyMjIEtleWJvYXJkIGNvbnN0YW50c1xuICpcbiAqIFRoZXJlIGFyZSBhbHNvIGEgbG90IG9mIGtleWJvYXJkIGNvbnN0YW50cyBmb3IgQVNDSUkuIFRob3NlIGFyZSBhbGwgcHJlZml4ZWQgd2l0aCBgS1xcX2AsIGUuZy4gYGdhbWVqcy5ldmVudC5LXFxfYWAgd291bGQgYmUgdGhlIFwiYVwiXG4gKiBrZXkgYW5kIGBnYW1lanMuZXZlbnQuS19TUEFDRWAgaXMgdGhlIHNwYWNlYmFyLlxuICpcbiAqICMjIFRvdWNoIGV2ZW50c1xuICpcbiAqIFRvdWNoIGV2ZW50cyBkbyBub3QgaGF2ZSBhIHNpbmdsZSBwb3NpdGlvbiBidXQgZm9yIGFsbCBgVE9VQ0hcXF8qYCBldmVudHMgeW91IGdldCBhbiBhcnJheSBvZlxuICogYHRvdWNoZXNgLCB3aGljaCBlYWNoIGhhdmUgdGhlaXIgb3duIGBwb3NgIGF0dHJpYnV0ZSBhbmQgYSB1bmlxdWUgYGlkZW50aWZpZXJgIGZvciB0cmFja2luZ1xuICogdGhpcyB0b3VjaCBhY3Jvc3MgbXVsdGlwbGUgYFRPVUNIXFxfTU9USU9OYCBldmVudHMuXG4gKlxuICogIyMgVXNlciBkZWZpbmVkIGV2ZW50c1xuICpcbiAqIEFsbCB1c2VyIGRlZmluZWQgZXZlbnRzIGNhbiBoYXZlIHRoZSB2YWx1ZSBvZiBgZ2FtZWpzLmV2ZW50LlVTRVJFVkVOVGAgb3IgaGlnaGVyLlxuICogTWFrZSBzdXJlIHlvdXIgY3VzdG9tIGV2ZW50IGlkcyBmb2xsb3cgdGhpcyBzeXN0ZW0uXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICBnYW1lanMub25FdmVudChmdW5jdGlvbihldmVudCkge1xuICogICAgICAgIGlmIChldmVudC50eXBlID09PSBnYW1lanMuZXZlbnQuTU9VU0VfVVApIHtcbiAqICAgICAgICAgIGdhbWVqcy5sb2dnaW5nLmxvZyhldmVudC5wb3MsIGV2ZW50LmJ1dHRvbik7XG4gKiAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBnYW1lanMuZXZlbnQuS0VZX1VQKSB7XG4gKiAgICAgICAgICBnYW1lanMubG9nZ2luZy5sb2coZXZlbnQua2V5KTtcbiAqICAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICovXG5cbnZhciBfQ0FMTEJBQ0tTID0gW107XG5cbi8qKiBAaWdub3JlICoqL1xudmFyIF90cmlnZ2VyQ2FsbGJhY2tzID0gZXhwb3J0cy5fdHJpZ2dlckNhbGxiYWNrcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgX0NBTExCQUNLUy5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7XG4gICAgaWYgKGNiLnR5cGUgPT09ICdhbGwnIHx8IGFyZ3NbMF0udHlwZSA9PT0gY2IudHlwZSkge1xuICAgICAgY2IuY2FsbGJhY2suYXBwbHkoY2Iuc2NvcGUsIGFyZ3MpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKlxuZXhwb3J0cy5vblF1aXQoY2FsbGJhY2spXG5leHBvcnRzLm9uVmlzaWJsaXR5Q2hhbmdlKGNhbGxiYWNrKVxuKi9cblxuLyoqXG4gKiBQYXNzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gRnVsbHNjcmVlbiBpcyBlbmFibGVkIG9yIGRpc2FibGVkLlxuICogSW5zcGVjdCBgZXZlbnQudHlwZWAgdG8gZGlzdGluZ3VpcyBiZXR3ZWVuIGVudGVyaW5nIGFuZCBleGl0aW5nIGZ1bGxzY3JlZW4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgY2FsbGVkXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgd2l0aGluIHdoaWNoIHRoZSBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkLiBJdCdzIGB0aGlzYCBkdXJpbmcgaW52b2NhdGlvbi4gKG9wdGlvbmFsKVxuICovXG5leHBvcnRzLm9uRnVsbHNjcmVlbiA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBzY29wZSkge1xuICAgaWYgKHR5cGVvZihjYWxsYmFjaykgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICB9XG4gICBfQ0FMTEJBQ0tTLnB1c2goe1xuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgdHlwZTogZXhwb3J0cy5ESVNQTEFZX0ZVTExTQ1JFRU5fRU5BQkxFRFxuICAgfSk7XG4gICBfQ0FMTEJBQ0tTLnB1c2goe1xuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgdHlwZTogZXhwb3J0cy5ESVNQTEFZX0ZVTExTQ1JFRU5fRElTQUJMRURcbiAgIH0pO1xufTtcblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gcGFzc3NlZCB0byBgb25FdmVudGAgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXJcbiAqIGFueSBldmVudCAobW91c2UsIGtleWJvYXJkLCBldGMpIHdhcyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgY2FsbGVkXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgd2l0aGluIHdoaWNoIHRoZSBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkLiBJdCdzIGB0aGlzYCBkdXJpbmcgaW52b2NhdGlvbi4gKG9wdGlvbmFsKVxuICovXG5leHBvcnRzLm9uRXZlbnQgPSBmdW5jdGlvbihjYWxsYmFjaywgc2NvcGUpIHtcbiAgIGlmICh0eXBlb2YoY2FsbGJhY2spICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgfVxuICBfQ0FMTEJBQ0tTLnB1c2goe1xuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgdHlwZTogJ2FsbCdcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgY2FsbGVkXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgd2l0aGluIHdoaWNoIHRoZSBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkLiBJdCdzIGB0aGlzYCBkdXJpbmcgaW52b2NhdGlvbi4gKG9wdGlvbmFsKVxuICovXG5leHBvcnRzLm9uRGlzcGxheVJlc2l6ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBzY29wZSkge1xuICAgaWYgKHR5cGVvZihjYWxsYmFjaykgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICB9O1xuXG4gIF9DQUxMQkFDS1MucHVzaCh7XG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHNjb3BlOiBzY29wZSxcbiAgICB0eXBlOiBleHBvcnRzLkRJU1BMQVlfUkVTSVpFXG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIHdpdGhpbiB3aGljaCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZC4gSXQncyBgdGhpc2AgZHVyaW5nIGludm9jYXRpb24uIChvcHRpb25hbClcbiAqL1xuZXhwb3J0cy5vbk1vdXNlTW90aW9uID0gZnVuY3Rpb24oY2FsbGJhY2ssIHNjb3BlKSB7XG4gICBpZiAodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgIH1cbiAgX0NBTExCQUNLUy5wdXNoKHtcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgc2NvcGU6IHNjb3BlLFxuICAgIHR5cGU6IGV4cG9ydHMuTU9VU0VfTU9USU9OXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBjYWxsZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSB3aXRoaW4gd2hpY2ggdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWQuIEl0J3MgYHRoaXNgIGR1cmluZyBpbnZvY2F0aW9uLiAob3B0aW9uYWwpXG4gKi9cbmV4cG9ydHMub25Nb3VzZVVwID0gZnVuY3Rpb24oY2FsbGJhY2ssIHNjb3BlKSB7XG4gICBpZiAodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgIH1cbiAgX0NBTExCQUNLUy5wdXNoKHtcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgc2NvcGU6IHNjb3BlLFxuICAgIHR5cGU6IGV4cG9ydHMuTU9VU0VfVVBcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIHdpdGhpbiB3aGljaCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZC4gSXQncyBgdGhpc2AgZHVyaW5nIGludm9jYXRpb24uIChvcHRpb25hbClcbiAqL1xuZXhwb3J0cy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBzY29wZSkge1xuICAgaWYgKHR5cGVvZihjYWxsYmFjaykgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICB9XG4gIF9DQUxMQkFDS1MucHVzaCh7XG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHNjb3BlOiBzY29wZSxcbiAgICB0eXBlOiBleHBvcnRzLk1PVVNFX0RPV05cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIHdpdGhpbiB3aGljaCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZC4gSXQncyBgdGhpc2AgZHVyaW5nIGludm9jYXRpb24uIChvcHRpb25hbClcbiAqL1xuZXhwb3J0cy5vblRvdWNoTW90aW9uID0gZnVuY3Rpb24oY2FsbGJhY2ssIHNjb3BlKSB7XG4gICBpZiAodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgIH1cbiAgX0NBTExCQUNLUy5wdXNoKHtcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgc2NvcGU6IHNjb3BlLFxuICAgIHR5cGU6IGV4cG9ydHMuVE9VQ0hfTU9USU9OXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBjYWxsZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSB3aXRoaW4gd2hpY2ggdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWQuIEl0J3MgYHRoaXNgIGR1cmluZyBpbnZvY2F0aW9uLiAob3B0aW9uYWwpXG4gKi9cbmV4cG9ydHMub25Ub3VjaFVwID0gZnVuY3Rpb24oY2FsbGJhY2ssIHNjb3BlKSB7XG4gICBpZiAodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgIH1cbiAgX0NBTExCQUNLUy5wdXNoKHtcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgc2NvcGU6IHNjb3BlLFxuICAgIHR5cGU6IGV4cG9ydHMuVE9VQ0hfVVBcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIHdpdGhpbiB3aGljaCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZC4gSXQncyBgdGhpc2AgZHVyaW5nIGludm9jYXRpb24uIChvcHRpb25hbClcbiAqL1xuZXhwb3J0cy5vblRvdWNoRG93biA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBzY29wZSkge1xuICAgaWYgKHR5cGVvZihjYWxsYmFjaykgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICB9XG4gIF9DQUxMQkFDS1MucHVzaCh7XG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHNjb3BlOiBzY29wZSxcbiAgICB0eXBlOiBleHBvcnRzLlRPVUNIX0RPV05cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIHdpdGhpbiB3aGljaCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZC4gSXQncyBgdGhpc2AgZHVyaW5nIGludm9jYXRpb24uIChvcHRpb25hbClcbiAqL1xuZXhwb3J0cy5vbktleURvd24gPSBmdW5jdGlvbihjYWxsYmFjaywgc2NvcGUpIHtcbiAgIGlmICh0eXBlb2YoY2FsbGJhY2spICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgfVxuICBfQ0FMTEJBQ0tTLnB1c2goe1xuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgdHlwZTogZXhwb3J0cy5LRVlfRE9XTlxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgY2FsbGVkXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgd2l0aGluIHdoaWNoIHRoZSBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkLiBJdCdzIGB0aGlzYCBkdXJpbmcgaW52b2NhdGlvbi4gKG9wdGlvbmFsKVxuICovXG5leHBvcnRzLm9uS2V5VXAgPSBmdW5jdGlvbihjYWxsYmFjaywgc2NvcGUpIHtcbiAgIGlmICh0eXBlb2YoY2FsbGJhY2spICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgfVxuICBfQ0FMTEJBQ0tTLnB1c2goe1xuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgdHlwZTogZXhwb3J0cy5LRVlfVVBcbiAgfSk7XG59O1xuXG4vLyBrZXkgY29uc3RhbnRzXG5leHBvcnRzLktfVVAgPSAzODtcbmV4cG9ydHMuS19ET1dOID0gNDA7XG5leHBvcnRzLktfUklHSFQgPSAzOTtcbmV4cG9ydHMuS19MRUZUID0gMzc7XG5cbmV4cG9ydHMuS19TUEFDRSA9IDMyO1xuZXhwb3J0cy5LX0JBQ0tTUEFDRSA9IDg7XG5leHBvcnRzLktfVEFCID0gOTtcbmV4cG9ydHMuS19FTlRFUiA9IDEzO1xuZXhwb3J0cy5LX1NISUZUID0gMTY7XG5leHBvcnRzLktfQ1RSTCA9IDE3O1xuZXhwb3J0cy5LX0FMVCA9IDE4O1xuZXhwb3J0cy5LX0VTQyA9IDI3O1xuXG5leHBvcnRzLktfMCA9IDQ4O1xuZXhwb3J0cy5LXzEgPSA0OTtcbmV4cG9ydHMuS18yID0gNTA7XG5leHBvcnRzLktfMyA9IDUxO1xuZXhwb3J0cy5LXzQgPSA1MjtcbmV4cG9ydHMuS181ID0gNTM7XG5leHBvcnRzLktfNiA9IDU0O1xuZXhwb3J0cy5LXzcgPSA1NTtcbmV4cG9ydHMuS184ID0gNTY7XG5leHBvcnRzLktfOSA9IDU3O1xuZXhwb3J0cy5LX2EgPSA2NTtcbmV4cG9ydHMuS19iID0gNjY7XG5leHBvcnRzLktfYyA9IDY3O1xuZXhwb3J0cy5LX2QgPSA2ODtcbmV4cG9ydHMuS19lID0gNjk7XG5leHBvcnRzLktfZiA9IDcwO1xuZXhwb3J0cy5LX2cgPSA3MTtcbmV4cG9ydHMuS19oID0gNzI7XG5leHBvcnRzLktfaSA9IDczO1xuZXhwb3J0cy5LX2ogPSA3NDtcbmV4cG9ydHMuS19rID0gNzU7XG5leHBvcnRzLktfbCA9IDc2O1xuZXhwb3J0cy5LX20gPSA3NztcbmV4cG9ydHMuS19uID0gNzg7XG5leHBvcnRzLktfbyA9IDc5O1xuZXhwb3J0cy5LX3AgPSA4MDtcbmV4cG9ydHMuS19xID0gODE7XG5leHBvcnRzLktfciA9IDgyO1xuZXhwb3J0cy5LX3MgPSA4MztcbmV4cG9ydHMuS190ID0gODQ7XG5leHBvcnRzLktfdSA9IDg1O1xuZXhwb3J0cy5LX3YgPSA4NjtcbmV4cG9ydHMuS193ID0gODc7XG5leHBvcnRzLktfeCA9IDg4O1xuZXhwb3J0cy5LX3kgPSA4OTtcbmV4cG9ydHMuS196ID0gOTA7XG5cbmV4cG9ydHMuS19LUDEgPSA5NztcbmV4cG9ydHMuS19LUDIgPSA5ODtcbmV4cG9ydHMuS19LUDMgPSA5OTtcbmV4cG9ydHMuS19LUDQgPSAxMDA7XG5leHBvcnRzLktfS1A1ID0gMTAxO1xuZXhwb3J0cy5LX0tQNiA9IDEwMjtcbmV4cG9ydHMuS19LUDcgPSAxMDM7XG5leHBvcnRzLktfS1A4ID0gMTA0O1xuZXhwb3J0cy5LX0tQOSA9IDEwNTtcblxuLy8gZXZlbnQgdHlwZSBjb25zdGFudHNcbmV4cG9ydHMuTk9FVkVOVCA9IDA7XG5leHBvcnRzLk5VTUVWRU5UUyA9IDMyMDAwO1xuXG5leHBvcnRzLkRJU1BMQVlfRlVMTFNDUkVFTl9FTkFCTEVEID0gMzAwO1xuZXhwb3J0cy5ESVNQTEFZX0ZVTExTQ1JFRU5fRElTQUJMRUQgPSAzMDE7XG5leHBvcnRzLkRJU1BMQVlfUkVTSVpFID0gMzAyO1xuXG5leHBvcnRzLlFVSVQgPSAwO1xuZXhwb3J0cy5LRVlfRE9XTiA9IDE7XG5leHBvcnRzLktFWV9VUCA9IDI7XG5leHBvcnRzLk1PVVNFX01PVElPTiA9IDM7XG5leHBvcnRzLk1PVVNFX1VQID0gNDtcbmV4cG9ydHMuTU9VU0VfRE9XTiA9IDU7XG5leHBvcnRzLk1PVVNFX1dIRUVMID0gNjtcbmV4cG9ydHMuVE9VQ0hfVVAgPSA3O1xuZXhwb3J0cy5UT1VDSF9ET1dOID0gODtcbmV4cG9ydHMuVE9VQ0hfTU9USU9OID0gOTtcbmV4cG9ydHMuVVNFUkVWRU5UID0gMjAwMDtcblxuXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiB0aGUgYGV2ZW50YCBvYmplY3QgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBjYWxsYmFja3MuXG4gKiBAY2xhc3NcbiAqL1xuXG5leHBvcnRzLkV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGV2ZW50LiBlLmcuLCBnYW1lanMuZXZlbnQuUVVJVCwgS0VZRE9XTiwgTU9VU0VVUC5cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIGtleSB0aGUga2V5Q29kZSBvZiB0aGUga2V5LiBjb21wYXJlIHdpdGggZ2FtZWpzLmV2ZW50LktfYSwgZ2FtZWpzLmV2ZW50LktfYiwuLi5cbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogcmVsYXRpdmUgbW92ZW1lbnQgZm9yIGEgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICovXG4gICAgdGhpcy5yZWwgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIHRoZSBudW1iZXIgb2YgdGhlIG1vdXNlYnV0dG9uIHByZXNzZWRcbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvbiA9IG51bGw7XG4gICAgLyoqXG4gICAgICogcG9zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgZm9yIG1vdXNlIGV2ZW50c1xuICAgICAqL1xuICAgIHRoaXMucG9zID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICAgdmFyIGxhc3RQb3MgPSBbXTtcblxuICAgLy8gYW5vbnltb3VzIGZ1bmN0aW9ucyBhcyBldmVudCBoYW5kbGVycyA9IG1lbW9yeSBsZWFrLCBzZWUgTURDOmVsZW1lbnRBZGRFdmVudExpc3RlbmVyXG5cbiAgIGZ1bmN0aW9uIG9uTW91c2VEb3duIChldikge1xuICAgICAgdmFyIGNhbnZhc09mZnNldCA9IGRpc3BsYXkuX2dldENhbnZhc09mZnNldCgpO1xuICAgICAgX3RyaWdnZXJDYWxsYmFja3Moe1xuICAgICAgICAgJ3R5cGUnOiBleHBvcnRzLk1PVVNFX0RPV04sXG4gICAgICAgICAncG9zJzogW2V2LmNsaWVudFggLSBjYW52YXNPZmZzZXRbMF0sIGV2LmNsaWVudFkgLSBjYW52YXNPZmZzZXRbMV1dLFxuICAgICAgICAgJ2J1dHRvbic6IGV2LmJ1dHRvbixcbiAgICAgICAgICdzaGlmdEtleSc6IGV2LnNoaWZ0S2V5LFxuICAgICAgICAgJ2N0cmxLZXknOiBldi5jdHJsS2V5LFxuICAgICAgICAgJ21ldGFLZXknOiBldi5tZXRhS2V5XG4gICAgICB9KTtcbiAgIH1cblxuICAgZnVuY3Rpb24gb25Nb3VzZVVwIChldikge1xuICAgICAgdmFyIGNhbnZhc09mZnNldCA9IGRpc3BsYXkuX2dldENhbnZhc09mZnNldCgpO1xuICAgICAgX3RyaWdnZXJDYWxsYmFja3Moe1xuICAgICAgICAgJ3R5cGUnOmV4cG9ydHMuTU9VU0VfVVAsXG4gICAgICAgICAncG9zJzogW2V2LmNsaWVudFggLSBjYW52YXNPZmZzZXRbMF0sIGV2LmNsaWVudFkgLSBjYW52YXNPZmZzZXRbMV1dLFxuICAgICAgICAgJ2J1dHRvbic6IGV2LmJ1dHRvbixcbiAgICAgICAgICdzaGlmdEtleSc6IGV2LnNoaWZ0S2V5LFxuICAgICAgICAgJ2N0cmxLZXknOiBldi5jdHJsS2V5LFxuICAgICAgICAgJ21ldGFLZXknOiBldi5tZXRhS2V5XG4gICAgICB9KTtcbiAgIH1cblxuICAgZnVuY3Rpb24gb25LZXlEb3duIChldikge1xuICAgICAgdmFyIGtleSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XG4gICAgICBfdHJpZ2dlckNhbGxiYWNrcyh7XG4gICAgICAgICAndHlwZSc6IGV4cG9ydHMuS0VZX0RPV04sXG4gICAgICAgICAna2V5Jzoga2V5LFxuICAgICAgICAgJ3NoaWZ0S2V5JzogZXYuc2hpZnRLZXksXG4gICAgICAgICAnY3RybEtleSc6IGV2LmN0cmxLZXksXG4gICAgICAgICAnbWV0YUtleSc6IGV2Lm1ldGFLZXlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiB0aGUgZGlzcGxheSBoYXMgZm9jdXMsIHdlIHN1cnByZXNzIGRlZmF1bHQgYWN0aW9uXG4gICAgICAvLyBmb3IgbW9zdCBrZXlzXG4gICAgICBpZiAoZGlzcGxheS5faGFzRm9jdXMoKSAmJiAoIWV2LmN0cmxLZXkgJiYgIWV2Lm1ldGFLZXkgJiZcbiAgICAgICAgICgoa2V5ID49IGV4cG9ydHMuS19MRUZUICYmIGtleSA8PSBleHBvcnRzLktfRE9XTikgfHxcbiAgICAgICAgIChrZXkgPj0gZXhwb3J0cy5LXzAgICAgJiYga2V5IDw9IGV4cG9ydHMuS196KSB8fFxuICAgICAgICAgKGtleSA+PSBleHBvcnRzLktfS1AxICAmJiBrZXkgPD0gZXhwb3J0cy5LX0tQOSkgfHxcbiAgICAgICAgIGtleSA9PT0gZXhwb3J0cy5LX1NQQUNFIHx8XG4gICAgICAgICBrZXkgPT09IGV4cG9ydHMuS19UQUIgfHxcbiAgICAgICAgIGtleSA9PT0gZXhwb3J0cy5LX0VOVEVSKSkgfHxcbiAgICAgICAgIGtleSA9PT0gZXhwb3J0cy5LX0FMVCB8fFxuICAgICAgICAga2V5ID09PSBleHBvcnRzLktfQkFDS1NQQUNFKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICB9XG5cbiAgIGZ1bmN0aW9uIG9uS2V5VXAgKGV2KSB7XG4gICAgICBfdHJpZ2dlckNhbGxiYWNrcyh7XG4gICAgICAgICAndHlwZSc6IGV4cG9ydHMuS0VZX1VQLFxuICAgICAgICAgJ2tleSc6IGV2LmtleUNvZGUsXG4gICAgICAgICAnc2hpZnRLZXknOiBldi5zaGlmdEtleSxcbiAgICAgICAgICdjdHJsS2V5JzogZXYuY3RybEtleSxcbiAgICAgICAgICdtZXRhS2V5JzogZXYubWV0YUtleVxuICAgICAgfSk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlIChldikge1xuICAgICAgdmFyIGNhbnZhc09mZnNldCA9IGRpc3BsYXkuX2dldENhbnZhc09mZnNldCgpO1xuICAgICAgdmFyIGN1cnJlbnRQb3MgPSBbZXYuY2xpZW50WCAtIGNhbnZhc09mZnNldFswXSwgZXYuY2xpZW50WSAtIGNhbnZhc09mZnNldFsxXV07XG4gICAgICB2YXIgcmVsYXRpdmVQb3MgPSBbXTtcbiAgICAgIGlmIChsYXN0UG9zLmxlbmd0aCkge1xuICAgICAgICAgcmVsYXRpdmVQb3MgPSBbXG4gICAgICAgICAgICBsYXN0UG9zWzBdIC0gY3VycmVudFBvc1swXSxcbiAgICAgICAgICAgIGxhc3RQb3NbMV0gLSBjdXJyZW50UG9zWzFdXG4gICAgICAgICBdO1xuICAgICAgfVxuICAgICAgX3RyaWdnZXJDYWxsYmFja3Moe1xuICAgICAgICAgJ3R5cGUnOiBleHBvcnRzLk1PVVNFX01PVElPTixcbiAgICAgICAgICdwb3MnOiBjdXJyZW50UG9zLFxuICAgICAgICAgJ3JlbCc6IHJlbGF0aXZlUG9zLFxuICAgICAgICAgJ2J1dHRvbnMnOiBudWxsLCAvLyBGSVhNRSwgZml4YWJsZT9cbiAgICAgICAgICd0aW1lc3RhbXAnOiBldi50aW1lU3RhbXAsXG4gICAgICAgICAnbW92ZW1lbnQnOiBbZXYubW92ZW1lbnRYICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZXYubW96TW92ZW1lbnRYICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZXYud2Via2l0TW92ZW1lbnRYIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgZXYubW92ZW1lbnRZICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZXYubW96TW92ZW1lbnRZICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZXYud2Via2l0TW92ZW1lbnRZIHx8IDBcbiAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICB9KTtcbiAgICAgIGxhc3RQb3MgPSBjdXJyZW50UG9zO1xuICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICBmdW5jdGlvbiBvbk1vdXNlU2Nyb2xsKGV2KSB7XG4gICAgICB2YXIgY2FudmFzT2Zmc2V0ID0gZGlzcGxheS5fZ2V0Q2FudmFzT2Zmc2V0KCk7XG4gICAgICB2YXIgY3VycmVudFBvcyA9IFtldi5jbGllbnRYIC0gY2FudmFzT2Zmc2V0WzBdLCBldi5jbGllbnRZIC0gY2FudmFzT2Zmc2V0WzFdXTtcbiAgICAgIF90cmlnZ2VyQ2FsbGJhY2tzKHtcbiAgICAgICAgIHR5cGU6IGV4cG9ydHMuTU9VU0VfV0hFRUwsXG4gICAgICAgICBwb3M6IGN1cnJlbnRQb3MsXG4gICAgICAgICBkZWx0YTogZXYuZGV0YWlsIHx8ICgtIGV2LndoZWVsRGVsdGFZIC8gNDApXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgZnVuY3Rpb24gb25CZWZvcmVVbmxvYWQgKGV2KSB7XG4gICAgICBfdHJpZ2dlckNhbGxiYWNrcyh7XG4gICAgICAgICAndHlwZSc6IGV4cG9ydHMuUVVJVFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICB9O1xuXG4gICAvLyBjb252ZXJ0IGEgdzNjIHRvdWNoIGV2ZW50IGludG8gZ2FtZWpzIGV2ZW50XG4gICBmdW5jdGlvbiB3M2NUb3VjaENvbnZlcnQodG91Y2hMaXN0KSB7XG4gICAgICB2YXIgY2FudmFzT2Zmc2V0ID0gZGlzcGxheS5fZ2V0Q2FudmFzT2Zmc2V0KCk7XG4gICAgICB2YXIgdExpc3QgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG91Y2hMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICB2YXIgdG91Y2hFdmVudCA9IHRvdWNoTGlzdC5pdGVtKGkpO1xuICAgICAgICAgdExpc3QucHVzaCh7XG4gICAgICAgICAgICBpZGVudGlmaWVyOiB0b3VjaEV2ZW50LmlkZW50aWZpZXIsXG4gICAgICAgICAgICBwb3M6IFt0b3VjaEV2ZW50LmNsaWVudFggLSBjYW52YXNPZmZzZXRbMF0sIHRvdWNoRXZlbnQuY2xpZW50WSAtIGNhbnZhc09mZnNldFsxXV1cbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRMaXN0O1xuICAgfVxuXG4gICBmdW5jdGlvbiBvblRvdWNoRG93bihldikge1xuICAgICAgdmFyIGNhbnZhc09mZnNldCA9IGRpc3BsYXkuX2dldENhbnZhc09mZnNldCgpO1xuICAgICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gdzNjVG91Y2hDb252ZXJ0KGV2LmNoYW5nZWRUb3VjaGVzKTtcbiAgICAgIF90cmlnZ2VyQ2FsbGJhY2tzKHtcbiAgICAgICAgICd0eXBlJzogZXhwb3J0cy5UT1VDSF9ET1dOLFxuICAgICAgICAgJ3RvdWNoZXMnOiBjaGFuZ2VkVG91Y2hlc1xuICAgICAgfSk7XG4gICB9O1xuXG4gICBmdW5jdGlvbiBvblRvdWNoVXAoZXYpIHtcbiAgICAgIHZhciBjaGFuZ2VkVG91Y2hlcyA9IHczY1RvdWNoQ29udmVydChldi5jaGFuZ2VkVG91Y2hlcyk7XG4gICAgICBfdHJpZ2dlckNhbGxiYWNrcyh7XG4gICAgICAgICAndHlwZSc6IGV4cG9ydHMuVE9VQ0hfVVAsXG4gICAgICAgICAndG91Y2hlcyc6IGNoYW5nZWRUb3VjaGVzLFxuICAgICAgfSk7XG4gICB9XG4gICBmdW5jdGlvbiBvblRvdWNoTW90aW9uKGV2KSB7XG4gICAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSB3M2NUb3VjaENvbnZlcnQoZXYuY2hhbmdlZFRvdWNoZXMpO1xuICAgICAgX3RyaWdnZXJDYWxsYmFja3Moe1xuICAgICAgICAgJ3R5cGUnOiBleHBvcnRzLlRPVUNIX01PVElPTixcbiAgICAgICAgICd0b3VjaGVzJzogY2hhbmdlZFRvdWNoZXNcbiAgICAgIH0pO1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgIH1cblxuICAgLy8gSUUgZG9lcyBub3Qgc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyIG9uIGRvY3VtZW50IGl0c2VsZlxuICAgLy8gRlggZXZlbnRzIGRvbid0IHJlYWNoIGJvZHkgaWYgbW91c2Ugb3V0c2lkZSB3aW5kb3cgb3Igb24gbWVudWJhclxuICAgdmFyIGNhbnZhcyA9IGRpc3BsYXkuX2dldENhbnZhcygpO1xuICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlKTtcbiAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgb25LZXlVcCwgZmFsc2UpO1xuICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgb25Nb3VzZVNjcm9sbCwgZmFsc2UpO1xuICAgLy8gTU9aRklYXG4gICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db2RlX3NuaXBwZXRzL01pc2NlbGxhbmVvdXMjRGV0ZWN0aW5nX21vdXNlX3doZWVsX2V2ZW50c1xuICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgb25Nb3VzZVNjcm9sbCwgZmFsc2UpO1xuICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIG9uQmVmb3JlVW5sb2FkLCBmYWxzZSk7XG4gICAvLyB0b3VjaHNcbiAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBvblRvdWNoRG93biwgZmFsc2UpO1xuICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvblRvdWNoVXAsIGZhbHNlKTtcbiAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgb25Ub3VjaFVwLCBmYWxzZSk7XG4gICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobGVhdmVcIiwgb25Ub3VjaFVwLCBmYWxzZSk7XG4gICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvblRvdWNoTW90aW9uLCBmYWxzZSk7XG5cbn07XG4iLCJ2YXIgU3VyZmFjZSA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKS5TdXJmYWNlO1xudmFyIG9iamVjdHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdHMnKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1ldGhvZHMgZm9yIGNyZWF0aW5nIEZvbnQgb2JqZWN0cyB3aGljaCBjYW4gcmVuZGVyIHRleHRcbiAqIHRvIGEgU3VyZmFjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGZvbnQgPSBuZXcgRm9udCgnMjBweCBtb25vc3BhY2UnKTtcbiAqIC8vIHJlbmRlciB0ZXh0IC0gdGhpcyByZXR1cm5zIGEgc3VyZmFjZSB3aXRoIHRoZSB0ZXh0IHdyaXR0ZW4gb24gaXQuXG4gKiB2YXIgaGVsbG9TdXJmYWNlID0gZm9udC5yZW5kZXIoJ0hlbGxvIFdvcmxkJylcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIEZvbnQgdG8gZHJhdyBvbiB0aGUgc2NyZWVuLiBUaGUgRm9udCBhbGxvd3MgeW91IHRvXG4gKiBgcmVuZGVyKClgIHRleHQuIFJlbmRlcmluZyB0ZXh0IHJldHVybnMgYSBTdXJmYWNlIHdoaWNoXG4gKiBpbiB0dXJuIGNhbiBiZSBwdXQgb24gc2NyZWVuLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGZvbnRIZWlnaHQgdGhlIGxpbmUgaGVpZ2h0IG9mIHRoaXMgRm9udFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb250U2V0dGluZ3MgYSBjc3MgZm9udCBkZWZpbml0aW9uLCBlLmcuLCBcIjIwcHggbW9ub3NwYWNlXCJcbiAqIEBwYXJhbSB7U1RyaW5nfSBiYWNrZ3JvdW5kQ29sb3IgdmFsaWQgI3JnYiBzdHJpbmcsIFwiI2ZmMDBjY1wiXG4gKi9cbnZhciBGb250ID0gZXhwb3J0cy5Gb250ID0gZnVuY3Rpb24oZm9udFNldHRpbmdzLCBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICB0aGlzLnNhbXBsZVN1cmZhY2UgPSBuZXcgU3VyZmFjZShbMTAsMTBdKTtcbiAgIHRoaXMuc2FtcGxlU3VyZmFjZS5jb250ZXh0LmZvbnQgPSBmb250U2V0dGluZ3M7XG4gICB0aGlzLnNhbXBsZVN1cmZhY2UuY29udGV4dC50ZXh0QWxpZ24gPSAnc3RhcnQnO1xuICAgLy8gaHR0cDovL2RpdmVpbnRvaHRtbDUub3JnL2NhbnZhcy5odG1sI3RleHRcbiAgIHRoaXMuc2FtcGxlU3VyZmFjZS5jb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3IgfHwgZmFsc2U7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIFN1cmZhY2Ugd2l0aCB0aGUgZ2l2ZW4gdGV4dCBvbiBpdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSB0ZXh0IHRvIHJlbmRlclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIGEgdmFsaWQgI1JHQiBTdHJpbmcsIFwiI2ZmY2MwMFwiXG4gKiBAcmV0dXJucyB7Z2FtZWpzLlN1cmZhY2V9IFN1cmZhY2Ugd2l0aCB0aGUgcmVuZGVyZWQgdGV4dCBvbiBpdC5cbiAqL1xuRm9udC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24odGV4dCwgY29sb3IpIHtcbiAgIHZhciBkaW1zID0gdGhpcy5zaXplKHRleHQpO1xuICAgdmFyIHN1cmZhY2UgPSBuZXcgU3VyZmFjZShkaW1zKTtcbiAgIHZhciBjdHggPSBzdXJmYWNlLmNvbnRleHQ7XG4gICBjdHguc2F2ZSgpO1xuICAgaWYgKCB0aGlzLmJhY2tncm91bmRDb2xvciApIHtcbiAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHN1cmZhY2UucmVjdC53aWR0aCwgc3VyZmFjZS5yZWN0LmhlaWdodCk7XG4gICB9XG4gICBjdHguZm9udCA9IHRoaXMuc2FtcGxlU3VyZmFjZS5jb250ZXh0LmZvbnQ7XG4gICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy5zYW1wbGVTdXJmYWNlLmNvbnRleHQudGV4dEJhc2VsaW5lO1xuICAgY3R4LnRleHRBbGlnbiA9IHRoaXMuc2FtcGxlU3VyZmFjZS5jb250ZXh0LnRleHRBbGlnbjtcbiAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvciB8fCBcIiMwMDAwMDBcIjtcbiAgIGN0eC5maWxsVGV4dCh0ZXh0LCAwLCBzdXJmYWNlLnJlY3QuaGVpZ2h0LCBzdXJmYWNlLnJlY3Qud2lkdGgpO1xuICAgY3R4LnJlc3RvcmUoKTtcbiAgIHJldHVybiBzdXJmYWNlO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGdpdmVuIHRleHQgaWYgcmVuZGVyZWRcbiAqIHdpdGggdGhpcyBGb250LlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIHRleHQgdG8gbWVhc3VyZVxuICogQHJldHVybnMge0FycmF5fSB0aGUgW3dpZHRoLCBoZWlnaHRdIG9mIHRoZSB0ZXh0IGlmIHJlbmRlcmVkIHdpdGggdGhpcyBGb250XG4gKi9cbkZvbnQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICB2YXIgbWV0cmljcyA9IHRoaXMuc2FtcGxlU3VyZmFjZS5jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgLy8gRklYTUUgbWVhc3VyZXRleHQgaXMgYnVnZ3ksIG1ha2UgZXh0cmEgd2lkZVxuICAgcmV0dXJuIFttZXRyaWNzLndpZHRoLCB0aGlzLmZvbnRIZWlnaHRdO1xufTtcblxuLyoqXG4gKiBIZWlnaHQgb2YgdGhlIGZvbnQgaW4gcGl4ZWxzLlxuICovXG5vYmplY3RzLmFjY2Vzc29ycyhGb250LnByb3RvdHlwZSwge1xuICAgJ2ZvbnRIZWlnaHQnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgLy8gUmV0dXJucyBhbiBhcHByb3hpbWF0ZSBsaW5lIGhlaWdodCBvZiB0aGUgdGV4dFxuICAgICAgICAgLy8gwrtUaGlzIHZlcnNpb24gb2YgdGhlIHNwZWNpZmljYXRpb24gZG9lcyBub3QgcHJvdmlkZSBhIHdheSB0byBvYnRhaW5cbiAgICAgICAgIC8vIHRoZSBib3VuZGluZyBib3ggZGltZW5zaW9ucyBvZiB0aGUgdGV4dC7Cq1xuICAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLW1lYXN1cmV0ZXh0XG4gICAgICAgICByZXR1cm4gdGhpcy5zYW1wbGVTdXJmYWNlLmNvbnRleHQubWVhc3VyZVRleHQoJ00nKS53aWR0aCAqIDEuNTtcbiAgICAgIH1cbiAgIH1cblxufSk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIFRoaXMgbW9kdWxlIGhvbGRzIHRoZSBpbXBvcnRhbnQgYFN1cmZhY2VgIGNsYXNzIHdoaWNoIGlzIHRoZSBnZW5lcmFsIGNvbnRhaW5lciBmb3IgaW1hZ2UgZGF0YS5cbiAqXG4gKiAgICAgdmFyIHN1cmZhY2UgPSBuZXcgZ2FtZWpzLmdyYXBoaWNzLlN1cmZhY2UoW3dpZHRoLCBoZWlnaHRdKTtcbiAqXG4gKiBUaGUgZnVuY3Rpb25zXG4gKiB0byBkcmF3IGdlb21ldHJpYyBsaW5lcyBsaWtlIGNpcmNsZXMsIGxpbmVzLCByZWN0YW5nbGVzLCBldGMuIGFyZSBhbHNvIGFsbCBpbiB0aGlzIG1vZHVsZTpcbiAqXG4gKiAgICAgZ2FtZWpzLmdyYXBoaWNzLmxpbmUoc3VyZmFjZSwgJyNmZjAwMDAnLCBjZW50ZXJQb2ludCwgcmFkaXVzKTtcbiAqXG4gKiBFYWNoIFN1cmZhY2UgaW5zdGFuY2UgaGFzIG1ldGhvZHMgdG8gY3JlYXRlICphIG5ldyogcm90YXRlZCwgZmxpcHBlZCwgc2NhbGVkLCBldGMuIGluc3RhbmNlIG9mIGl0c2VsZjpcbiAqXG4gKiAgICAgLy8gdGhlIG9yaWdpbmFsIGBzdXJmYWNlYCByZW1haW5zIHVudG91Y2hlZCBieSB0aGVcbiAqICAgICAvLyBmaWxwIG9wZXJhdGlvbi4gQSBuZXcgU3VyZmFjZSBpbnN0YW5jZVxuICogICAgIC8vIGlzIHJldHVybmVkIGJ5IGBmbGlwKClgLlxuICogICAgIHZhciBob3Jpem9udGFsRmxpcHBlZFN1cmZhY2UgPSBzdXJmYWNlLmZsaXAodHJ1ZSk7XG4gKlxuICogSWYgeW91IHdhbnQgdG8gcHV0IGltYWdlcyAocG5nLCBqcGcpIG9uIHRoZSBzY3JlZW4sIGFsc28gc2VlIHRoZSBgZ2FtZWpzLmltYWdlYCBtb2R1bGUgYW5kIGBnYW1lanMucHJlbG9hZCgpYC5cbiAqXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCB3YXlzIHRvIHNwZWNpZnkgY29sb3JzLiBXaGVuZXZlciB0aGUgZG9jcyBzYXlzIFwidmFsaWQgI1JHQiBzdHJpbmdcIlxuICogeW91IGNhbiBwYXNzIGluIGFueSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6IGBcIiNmZjAwZmZcImAsIGBcInJnYigyNTUsIDAsIDI1NSlcImAgb3IgYFwicmdiYSgyNTUsIDAsIDI1NSwgMSlcImAuXG4gKlxuICogQHNlZSBnYW1lanMvaW1hZ2VcbiAqL1xudmFyIGdhbWVqcyA9IHJlcXVpcmUoJy4uL2dhbWVqcycpO1xudmFyIFJlY3QgPSBnYW1lanMuUmVjdDtcbnZhciBvYmplY3RzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3RzJyk7XG5cbi8qKlxuICogdHJhbnNmb3JtIGZ1bmN0aW9uc1xuICovXG52YXIgbWF0cml4ID0gcmVxdWlyZSgnLi9tYXRoL21hdHJpeCcpO1xudmFyIHZlY3RvcnMgPSByZXF1aXJlKCcuL21hdGgvdmVjdG9ycycpO1xuXG4vKipcbiAqIEEgU3VyZmFjZSByZXByZXNlbnRzIGEgYml0bWFwIGltYWdlIHdpdGggYSBmaXhlZCB3aWR0aCBhbmQgaGVpZ2h0LiBUaGVcbiAqIG1vc3QgaW1wb3J0YW50IGZlYXR1cmUgb2YgYSBTdXJmYWNlIGlzIHRoYXQgdGhleSBjYW4gYmUgYGJsaXR0ZWRgXG4gKiBvbnRvIGVhY2ggb3RoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBnYW1lanMuZ3JhcGhpY3MuU3VyZmFjZShbd2lkdGgsIGhlaWdodF0pO1xuICogbmV3IGdhbWVqcy5ncmFwaGljcy5TdXJmYWNlKHdpZHRoLCBoZWlnaHQpO1xuICogbmV3IGdhbWVqcy5ncmFwaGljcy5TdXJmYWNlKHJlY3QpO1xuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGltZW5zaW9ucyBBcnJheSBob2xkaW5nIHdpZHRoIGFuZCBoZWlnaHRcbiAqL1xudmFyIFN1cmZhY2UgPSBleHBvcnRzLlN1cmZhY2UgPSBmdW5jdGlvbigpIHtcbiAgIHZhciBhcmdzID0gZ2FtZWpzLm5vcm1hbGl6ZVJlY3RBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIHZhciB3aWR0aCA9IGFyZ3MubGVmdDtcbiAgIHZhciBoZWlnaHQgPSBhcmdzLnRvcDtcbiAgIC8vIHVubGVzcyBhcmd1bWVudCBpcyByZWN0OlxuICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBSZWN0KSB7XG4gICAgICB3aWR0aCA9IGFyZ3Mud2lkdGg7XG4gICAgICBoZWlnaHQgPSBhcmdzLmhlaWdodDtcbiAgIH1cbiAgIC8vIG9ubHkgZm9yIHJvdGF0YXRpb24gJiBzY2FsZVxuICAgLyoqIEBpZ25vcmUgKi9cbiAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeC5pZGVudGl0eSgpO1xuICAgLyoqIEBpZ25vcmUgKi9cbiAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICB0aGlzLl9ibGl0QWxwaGEgPSAxLjA7XG5cbiAgIC8qKiBAaWdub3JlICovXG4gICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAvLyB1c2luZyBleHBvcnRzIGlzIHdlaXJkIGJ1dCBhdm9pZHMgY2lyY3VsYXIgcmVxdWlyZVxuICAgaWYgKGdhbWVqcy5kaXNwbGF5Ll9pc1Ntb290aGluZ0VuYWJsZWQoKSkge1xuICAgICAgdGhpcy5fc21vb3RoKCk7XG4gICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbm9TbW9vdGgoKTtcbiAgIH1cbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIEBpZ25vcmUgKi9cblN1cmZhY2UucHJvdG90eXBlLl9ub1Ntb290aCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGRpc2FibGUgaW1hZ2Ugc2NhbGluZ1xuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9DYW52YXNfdHV0b3JpYWwvVXNpbmdfaW1hZ2VzI0NvbnRyb2xsaW5nX2ltYWdlX3NjYWxpbmdfYmVoYXZpb3JcbiAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2pidWNrL3Byb2Nlc3NpbmctanMvY29tbWl0LzY1ZGUxNmE4MzQwYzY5NGNlZTQ3MWEyZGI3NjM0NzMzMzcwYjk0MWNcbiAgICB0aGlzLmNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gIHRoaXMuY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgIHJldHVybjtcbn07XG4vKiogQGlnbm9yZSAqL1xuU3VyZmFjZS5wcm90b3R5cGUuX3Ntb290aCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcbiAgdGhpcy5jb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG5cbn07XG5cbi8qKlxuICogQmxpdHMgYW5vdGhlciBTdXJmYWNlIG9uIHRoaXMgU3VyZmFjZS4gVGhlIGRlc3RpbmF0aW9uIHdoZXJlIHRvIGJsaXQgdG9cbiAqIGNhbiBiZSBnaXZlbiAob3IgaXQgZGVmYXVsdHMgdG8gdGhlIHRvcCBsZWZ0IGNvcm5lcikgYXMgd2VsbCBhcyB0aGVcbiAqIEFyZWEgZnJvbSB0aGUgU3VyZmFjZSB3aGljaCBzaG91bGQgYmUgYmxpdHRlZCAoZS5nLiwgZm9yIGN1dHRpbmcgb3V0IHBhcnRzIG9mXG4gKiBhIFN1cmZhY2UpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBibGl0IGZsb3dlciBpbiB0b3AgbGVmdCBjb3JuZXIgb2YgZGlzcGxheVxuICogZGlzcGxheVN1cmZhY2UuYmxpdChmbG93ZXJTdXJmYWNlKTtcbiAqXG4gKiAvLyBwb3NpdGlvbiBmbG93ZXIgYXQgMTAvMTAgb2YgZGlzcGxheVxuICogZGlzcGxheVN1cmZhY2UuYmxpdChmbG93ZXJTdXJmYWNlLCBbMTAsIDEwXSlcbiAqXG4gKiAvLyAuLi4gYGRlc3RgIGNhbiBhbHNvIGJlIGEgcmVjdCB3aG9zZSB0b3BsZWZ0IHBvc2l0aW9uIGlzIHRha2VuOlxuICogZGlzcGxheVN1cmZhY2UuYmxpdChmbG93ZXJTdXJmYWNlLCBuZXcgZ2FtZWpzLlJlY3QoWzEwLCAxMF0pO1xuICpcbiAqIC8vIG9ubHkgYmxpdCBoYWxmIG9mIHRoZSBmbG93ZXIgb250byB0aGUgZGlzcGxheVxuICogdmFyIGZsb3dlclJlY3QgPSBmbG93ZXJTdXJmYWNlLnJlY3Q7XG4gKiBmbG93ZXJSZWN0ID0gbmV3IGdhbWVqcy5SZWN0KFswLDBdLCBbZmxvd2VyUmVjdC53aWR0aC8yLCBmbG93ZXJSZWN0LmhlaWdodC8yXSlcbiAqIGRpc3BsYXlTdXJmYWNlLmJsaXQoZmxvd2VyU3VyZmFjZSwgWzAsMF0sIGZsb3dlclJlY3QpO1xuICpcbiAqIEBwYXJhbSB7Z2FtZWpzLmdyYXBoaWNzLlN1cmZhY2V9IHNyYyBUaGUgU3VyZmFjZSB3aGljaCB3aWxsIGJlIGJsaXR0ZWQgb250byB0aGlzIG9uZVxuICogQHBhcmFtIHtnYW1lanMuUmVjdHxBcnJheX0gZHN0IHRoZSBEZXN0aW5hdGlvbiB4LCB5IHBvc2l0aW9uIGluIHRoaXMgU3VyZmFjZS5cbiAqICAgICAgICAgICAgSWYgYSBSZWN0IGlzIGdpdmVuLCBpdCdzIHRvcCBhbmQgbGVmdCB2YWx1ZXMgYXJlIHRha2VuLiBJZiB0aGlzIGFyZ3VtZW50XG4gKiAgICAgICAgICAgIGlzIG5vdCBzdXBwbGllZCB0aGUgYmxpdCBoYXBwZW5zIGF0IFswLDBdLlxuICogQHBhcmFtIHtnYW1lc2pzLlJlY3R8QXJyYXl9IGFyZWEgdGhlIEFyZWEgZnJvbSB0aGUgcGFzc2VkIFN1cmZhY2Ugd2hpY2hcbiAqICAgICAgICAgICAgc2hvdWxkIGJlIGJsaXR0ZWQgb250byB0aGlzIFN1cmZhY2UuXG4gKiBAcGFyYW0ge051bWJlcn0gY29tcG9zaXRpb25PcGVyYXRpb24gaG93IHRoZSBzb3VyY2UgYW5kIHRhcmdldCBzdXJmYWNlcyBhcmUgY29tcG9zaXRlZCB0b2dldGhlcjsgb25lIG9mOiBzb3VyY2UtYXRvcCwgc291cmNlLWluLCBzb3VyY2Utb3V0LCBzb3VyY2Utb3ZlciAoZGVmYXVsdCksIGRlc3RpbmF0aW9uLWF0b3AsIGRlc3RpbmF0aW9uLWluLCBkZXN0aW5hdGlvbi1vdXQsIGRlc3RpbmF0aW9uLW92ZXIsIGxpZ2h0ZXIsIGNvcHksIHhvcjsgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIHRoZXNlIHZhbHVlcyBzZWU6IGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1LzJkY29udGV4dC8jZG9tLWNvbnRleHQtMmQtZ2xvYmFsY29tcG9zaXRlb3BlcmF0aW9uXG4gKiBAcmV0dXJucyB7Z2FtZWpzLlJlY3R9IFJlY3QgYWN0dWFsbHkgcmVwYWludGVkIEZJWE1FIGFjdHVhbGx5IHJldHVybiBzb21ldGhpbmc/XG4gKi9cblN1cmZhY2UucHJvdG90eXBlLmJsaXQgPSBmdW5jdGlvbihzcmMsIGRlc3QsIGFyZWEsIGNvbXBvc2l0ZU9wZXJhdGlvbikge1xuXG4gICB2YXIgckRlc3QsIHJBcmVhO1xuXG4gICBpZiAoZGVzdCBpbnN0YW5jZW9mIFJlY3QpIHtcbiAgICAgIHJEZXN0ID0gZGVzdC5jbG9uZSgpO1xuICAgICAgdmFyIHNyY1NpemUgPSBzcmMuZ2V0U2l6ZSgpO1xuICAgICAgaWYgKCFyRGVzdC53aWR0aCkge1xuICAgICAgICAgckRlc3Qud2lkdGggPSBzcmNTaXplWzBdO1xuICAgICAgfVxuICAgICAgaWYgKCFyRGVzdC5oZWlnaHQpIHtcbiAgICAgICAgIHJEZXN0LmhlaWdodCA9IHNyY1NpemVbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkZXN0ICYmIGRlc3QgaW5zdGFuY2VvZiBBcnJheSAmJiBkZXN0Lmxlbmd0aCA9PSAyKSB7XG4gICAgICByRGVzdCA9IG5ldyBSZWN0KGRlc3QsIHNyYy5nZXRTaXplKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByRGVzdCA9IG5ldyBSZWN0KFswLDBdLCBzcmMuZ2V0U2l6ZSgpKTtcbiAgICB9XG4gICBjb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb24gfHwgJ3NvdXJjZS1vdmVyJztcblxuICAgLy8gYXJlYSB3aXRoaW4gc3JjIHRvIGJlIGRyYXduXG4gICBpZiAoYXJlYSBpbnN0YW5jZW9mIFJlY3QpIHtcbiAgICAgIHJBcmVhID0gYXJlYTtcbiAgIH0gZWxzZSBpZiAoYXJlYSAmJiBhcmVhIGluc3RhbmNlb2YgQXJyYXkgJiYgYXJlYS5sZW5ndGggPT0gMikge1xuICAgICAgdmFyIHNpemUgPSBzcmMuZ2V0U2l6ZSgpO1xuICAgICAgckFyZWEgPSBuZXcgUmVjdChhcmVhLCBbc2l6ZVswXSAtIGFyZWFbMF0sIHNpemVbMV0gLSBhcmVhWzFdXSk7XG4gICB9IGVsc2Uge1xuICAgICAgckFyZWEgPSBuZXcgUmVjdChbMCwwXSwgc3JjLmdldFNpemUoKSk7XG4gICB9XG5cbiAgIGlmIChpc05hTihyRGVzdC5sZWZ0KSB8fCBpc05hTihyRGVzdC50b3ApIHx8IGlzTmFOKHJEZXN0LndpZHRoKSB8fCBpc05hTihyRGVzdC5oZWlnaHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tibGl0XSBiYWQgcGFyYW1ldGVycywgZGVzdGluYXRpb24gaXMgJyArIHJEZXN0KTtcbiAgIH1cblxuICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgIHRoaXMuY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XG4gICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBzcmMuX2JsaXRBbHBoYTtcbiAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2Uoc3JjLmNhbnZhcywgckFyZWEubGVmdCwgckFyZWEudG9wLCByQXJlYS53aWR0aCwgckFyZWEuaGVpZ2h0LCByRGVzdC5sZWZ0LCByRGVzdC50b3AsIHJEZXN0LndpZHRoLCByRGVzdC5oZWlnaHQpO1xuICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgIHJldHVybjtcbn07XG5cbi8qKlxuICogQHJldHVybnMge051bWJlcltdfSB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgU3VyZmFjZVxuICovXG5TdXJmYWNlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gW3RoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHRdO1xufTtcblxuLyoqXG4gKiBPYnNvbHRlLCBvbmx5IGhlcmUgZm9yIGNvbXBhdGliaWxpdHkuXG4gKiBAZGVwcmVjYXRlZFxuICogQGlnbm9yZVxuICogQHJldHVybnMge2dhbWVqcy5SZWN0fSBhIFJlY3Qgb2YgdGhlIHNpemUgb2YgdGhpcyBTdXJmYWNlXG4gKi9cblN1cmZhY2UucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgUmVjdChbMCwwXSwgdGhpcy5nZXRTaXplKCkpO1xufTtcblxuLyoqXG4gKiBGaWxscyB0aGUgd2hvbGUgU3VyZmFjZSB3aXRoIGEgY29sb3IuIFVzZWZ1bGwgZm9yIGVyYXNpbmcgYSBTdXJmYWNlLlxuICogQHBhcmFtIHtTdHJpbmd9IENTUyBjb2xvciBzdHJpbmcsIGUuZy4gJyMwZDEyMGEnIG9yICcjMGYwJyBvciAncmdiYSgyNTUsIDAsIDAsIDAuNSknXG4gKiBAcGFyYW0ge2dhbWVqcy5SZWN0fSBhIFJlY3Qgb2YgdGhlIGFyZWEgdG8gZmlsbCAoZGVmYXV0cyB0byBlbnRpcmUgc3VyZmFjZSBpZiBub3Qgc3BlY2lmaWVkKVxuICovXG5TdXJmYWNlLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24oY29sb3IsIHJlY3QpIHtcbiAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IgfHwgXCIjMDAwMDAwXCI7XG4gICBpZiAocmVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgcmVjdCA9IG5ldyBSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIH1cblxuICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4gICByZXR1cm47XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBzdXJmYWNlLlxuICovXG5TdXJmYWNlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICByZWN0ID0gcmVjdCB8fCBuZXcgUmVjdCgwLCAwLCBzaXplWzBdLCBzaXplWzFdKTtcbiAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QocmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgcmV0dXJuO1xufTtcblxub2JqZWN0cy5hY2Nlc3NvcnMoU3VyZmFjZS5wcm90b3R5cGUsIHtcbiAgIC8qKlxuICAgICogQHR5cGUgZ2FtZWpzLlJlY3RcbiAgICAqL1xuICAgJ3JlY3QnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVjdCgpO1xuICAgICAgfVxuICAgfSxcbiAgIC8qKlxuICAgICogQGlnbm9yZVxuICAgICovXG4gICAnY29udGV4dCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgICAgIH1cbiAgIH0sXG4gICAnY2FudmFzJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgICB9XG4gICB9XG59KTtcblxuLyoqXG4gKiBAcmV0dXJucyB7Z2FtZWpzLmdyYXBoaWNzLlN1cmZhY2V9IGEgY2xvbmUgb2YgdGhpcyBzdXJmYWNlXG4gKi9cblN1cmZhY2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuZXdTdXJmYWNlID0gbmV3IFN1cmZhY2UodGhpcy5nZXRSZWN0KCkpO1xuICBuZXdTdXJmYWNlLmJsaXQodGhpcyk7XG4gIHJldHVybiBuZXdTdXJmYWNlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBjdXJyZW50IGFscGhhIHZhbHVlXG4gKi9cblN1cmZhY2UucHJvdG90eXBlLmdldEFscGhhID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gKDEgLSB0aGlzLl9ibGl0QWxwaGEpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGFscGhhIHZhbHVlIGZvciB0aGUgd2hvbGUgU3VyZmFjZS4gV2hlbiBibGl0dGluZyB0aGUgU3VyZmFjZSBvblxuICogYSBkZXN0aW5hdGlvbiwgdGhlIHBpeGVscyB3aWxsIGJlIGRyYXduIHNsaWdodGx5IHRyYW5zcGFyZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIHZhbHVlIGluIHJhbmdlIDAuMCAtIDEuMFxuICogQHJldHVybnMge051bWJlcn0gY3VycmVudCBhbHBoYSB2YWx1ZVxuICovXG5TdXJmYWNlLnByb3RvdHlwZS5zZXRBbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICBpZiAoaXNOYU4oYWxwaGEpIHx8IGFscGhhIDwgMCB8fCBhbHBoYSA+IDEpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgdGhpcy5fYmxpdEFscGhhID0gKDEgLSBhbHBoYSk7XG4gICByZXR1cm4gKDEgLSB0aGlzLl9ibGl0QWxwaGEpO1xufTtcblxuLyoqXG4gKiBUaGUgZGF0YSBtdXN0IGJlIHJlcHJlc2VudGVkIGluIGxlZnQtdG8tcmlnaHQgb3JkZXIsIHJvdyBieSByb3cgdG9wIHRvIGJvdHRvbSxcbiAqIHN0YXJ0aW5nIHdpdGggdGhlIHRvcCBsZWZ0LCB3aXRoIGVhY2ggcGl4ZWwncyByZWQsIGdyZWVuLCBibHVlLCBhbmQgYWxwaGEgY29tcG9uZW50c1xuICogYmVpbmcgZ2l2ZW4gaW4gdGhhdCBvcmRlciBmb3IgZWFjaCBwaXhlbC5cbiAqIEBzZWUgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvMmRjb250ZXh0LyNjYW52YXNwaXhlbGFycmF5XG4gKiBAcmV0dXJucyB7SW1hZ2VEYXRhfSBhbiBvYmplY3QgaG9sZGluZyB0aGUgcGl4ZWwgaW1hZ2UgZGF0YSB7ZGF0YSwgd2lkdGgsIGhlaWdodH1cbiAqL1xuU3VyZmFjZS5wcm90b3R5cGUuZ2V0SW1hZ2VEYXRhID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZVswXSwgc2l6ZVsxXSk7XG59O1xuXG5cblxuLy8gRklYTUUgYWxsIGRyYXcgZnVuY3Rpb25zIG11c3QgcmV0dXJuIGEgbWluaW1hbCByZWN0IGNvbnRhaW5pbmcgdGhlIGRyYXduIHNoYXBlXG5cbi8qKlxuICogQHBhcmFtIHtnYW1lanMuZ3JhcGhpY3MuU3VyZmFjZX0gc3VyZmFjZSB0aGUgU3VyZmFjZSB0byBkcmF3IG9uXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgdmFsaWQgI1JHQiBzdHJpbmcsIGUuZy4sIFwiI2ZmMDAwMFwiXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydFBvcyBbeCwgeV0gcG9zaXRpb24gb2YgbGluZSBzdGFydFxuICogQHBhcmFtIHtBcnJheX0gZW5kUG9zIFt4LCB5XSBwb3NpdGlvbiBvZiBsaW5lIGVuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIG9mIHRoZSBsaW5lLCBkZWZhdWx0cyB0byAxXG4gKi9cbmV4cG9ydHMubGluZSA9IGZ1bmN0aW9uKHN1cmZhY2UsIGNvbG9yLCBzdGFydFBvcywgZW5kUG9zLCB3aWR0aCkge1xuICAgdmFyIGN0eCA9IHN1cmZhY2UuY29udGV4dDtcbiAgIGN0eC5zYXZlKCk7XG4gICBjdHguYmVnaW5QYXRoKCk7XG4gICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgIGN0eC5saW5lV2lkdGggPSB3aWR0aCB8fCAxO1xuICAgY3R4Lm1vdmVUbyhzdGFydFBvc1swXSwgc3RhcnRQb3NbMV0pO1xuICAgY3R4LmxpbmVUbyhlbmRQb3NbMF0sIGVuZFBvc1sxXSk7XG4gICBjdHguc3Ryb2tlKCk7XG4gICBjdHgucmVzdG9yZSgpO1xuICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBEcmF3IGNvbm5lY3RlZCBsaW5lcy4gVXNlIHRoaXMgaW5zdGVhZCBvZiBpbmRpdml1ZGFsIGxpbmUoKSBjYWxscyBmb3JcbiAqIGJldHRlciBwZXJmb3JtYW5jZVxuICpcbiAqIEBwYXJhbSB7Z2FtZWpzLmdyYXBoaWNzLlN1cmZhY2V9IHN1cmZhY2UgdGhlIFN1cmZhY2UgdG8gZHJhdyBvblxuICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIGEgdmFsaWQgI1JHQiBzdHJpbmcsIFwiI2ZmMDAwMFwiXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlZCBpZiB0cnVlIHRoZSBsYXN0IGFuZCBmaXJzdCBwb2ludCBhcmUgY29ubmVjdGVkXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGxpc3QgaG9sZGluZyBhcnJheSBbeCx5XSBhcnJheXMgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggd2lkdGggb2YgdGhlIGxpbmVzLCBkZWZhdWx0cyB0byAxXG4gKi9cbmV4cG9ydHMubGluZXMgPSBmdW5jdGlvbihzdXJmYWNlLCBjb2xvciwgY2xvc2VkLCBwb2ludGxpc3QsIHdpZHRoKSB7XG4gICBjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XG4gICB2YXIgY3R4ID0gc3VyZmFjZS5jb250ZXh0O1xuICAgY3R4LnNhdmUoKTtcbiAgIGN0eC5iZWdpblBhdGgoKTtcbiAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgIGN0eC5saW5lV2lkdGggPSB3aWR0aCB8fCAxO1xuICAgcG9pbnRsaXN0LmZvckVhY2goZnVuY3Rpb24ocG9pbnQsIGlkeCkge1xuICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgIH1cbiAgIH0pO1xuICAgaWYgKGNsb3NlZCkge1xuICAgICAgY3R4LmxpbmVUbyhwb2ludGxpc3RbMF1bMF0sIHBvaW50bGlzdFswXVsxXSk7XG4gICB9XG4gICBjdHguc3Ryb2tlKCk7XG4gICBjdHgucmVzdG9yZSgpO1xuICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBEcmF3IGEgY2lyY2xlIG9uIFN1cmZhY2VcbiAqXG4gKiBAcGFyYW0ge2dhbWVqcy5ncmFwaGljcy5TdXJmYWNlfSBzdXJmYWNlIHRoZSBTdXJmYWNlIHRvIGRyYXcgb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBhIHZhbGlkICNSR0IgU3RyaW5nLCAjZmYwMGNjXG4gKiBAcGFyYW0ge0FycmF5fSBwb3MgW3gsIHldIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgY2VudGVyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCB3aWR0aCBvZiB0aGUgY2lyY2xlLCBpZiBub3QgZ2l2ZW4gb3IgMCB0aGUgY2lyY2xlIGlzIGZpbGxlZFxuICovXG5leHBvcnRzLmNpcmNsZSA9IGZ1bmN0aW9uKHN1cmZhY2UsIGNvbG9yLCBwb3MsIHJhZGl1cywgd2lkdGgpIHtcbiAgIGlmIChpc05hTihyYWRpdXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjaXJjbGVdIHJhZGl1cyByZXF1aXJlZCBhcmd1bWVudCcpO1xuICAgfVxuICAgaWYgKCFwb3MgfHwgIShwb3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NpcmNsZV0gcG9zIG11c3QgYmUgZ2l2ZW4gJiBhcnJheScgKyBwb3MpO1xuICAgfVxuXG4gICB2YXIgY3R4ID0gc3VyZmFjZS5jb250ZXh0O1xuICAgY3R4LnNhdmUoKTtcbiAgIGN0eC5iZWdpblBhdGgoKTtcbiAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgIGN0eC5saW5lV2lkdGggPSB3aWR0aCB8fCAxO1xuICAgY3R4LmFyYyhwb3NbMF0sIHBvc1sxXSwgcmFkaXVzLCAwLCAyKk1hdGguUEksIHRydWUpO1xuICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgd2lkdGggPT09IDApIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICB9IGVsc2Uge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgfVxuICAgY3R4LnJlc3RvcmUoKTtcbiAgIHJldHVybjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtnYW1lanMuZ3JhcGhpY3MuU3VyZmFjZX0gc3VyZmFjZSB0aGUgU3VyZmFjZSB0byBkcmF3IG9uXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgYSB2YWxpZCAjUkdCIFN0cmluZywgI2ZmMDBjY1xuICogQHBhcmFtIHtnYW1lanMuUmVjdH0gcmVjdCB0aGUgcG9zaXRpb24gYW5kIGRpbWVuc2lvbiBhdHRyaWJ1dGVzIG9mIHRoaXMgUmVjdCB3aWxsIGJlIHVzZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCB0aGUgd2lkdGggb2YgbGluZSBkcmF3aW5nIHRoZSBSZWN0LCBpZiAwIG9yIG5vdCBnaXZlbiB0aGUgUmVjdCBpcyBmaWxsZWQuXG4gKi9cbmV4cG9ydHMucmVjdCA9IGZ1bmN0aW9uKHN1cmZhY2UsIGNvbG9yLCByZWN0LCB3aWR0aCkge1xuICAgdmFyIGN0eCA9c3VyZmFjZS5jb250ZXh0O1xuICAgY3R4LnNhdmUoKTtcbiAgIGN0eC5iZWdpblBhdGgoKTtcbiAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgIGlmIChpc05hTih3aWR0aCkgfHwgd2lkdGggPT09IDApIHtcbiAgICAgIGN0eC5maWxsUmVjdChyZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgICBjdHguc3Ryb2tlUmVjdChyZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICB9XG4gICBjdHgucmVzdG9yZSgpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2dhbWVqcy5ncmFwaGljcy5TdXJmYWNlfSBzdXJmYWNlIHRoZSBTdXJmYWNlIHRvIGRyYXcgb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBhIHZhbGlkICNSR0IgU3RyaW5nLCAjZmYwMGNjXG4gKiBAcGFyYW0ge0FycmF5fSBwb3MgW3gsIHldIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgY2VudGVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSwgYm90aCBhbmdsZXMgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0b3BBbmdsZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIHRoZSB3aWR0aCBvZiBsaW5lLCBpZiAwIG9yIG5vdCBnaXZlbiB0aGUgYXJjIGlzIGZpbGxlZC5cbiAqL1xuZXhwb3J0cy5hcmM9IGZ1bmN0aW9uKHN1cmZhY2UsIGNvbG9yLCBwb3MsIHN0YXJ0QW5nbGUsIHN0b3BBbmdsZSwgcmFkaXVzLCB3aWR0aCkge1xuICAgdmFyIGN0eCA9IHN1cmZhY2UuY29udGV4dDtcbiAgIGN0eC5zYXZlKCk7XG4gICBjdHguYmVnaW5QYXRoKCk7XG4gICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICBjdHguYXJjKHBvc1swXSwgcG9zWzFdLFxuICAgICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgICAgc3RhcnRBbmdsZSwgc3RvcEFuZ2xlLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICk7XG4gICBpZiAoaXNOYU4od2lkdGgpIHx8IHdpZHRoID09PSAwKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB3aWR0aCB8fCAxO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgfVxuICAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbi8qKlxuICogRHJhdyBhIHBvbHlnb24gb24gdGhlIHN1cmZhY2UuIFRoZSBwb2ludGxpc3QgYXJndW1lbnQgYXJlIHRoZSB2ZXJ0aWNlc1xuICogZm9yIHRoZSBwb2x5Z29uLlxuICpcbiAqIEBwYXJhbSB7Z2FtZWpzLmdyYXBoaWNzLlN1cmZhY2V9IHN1cmZhY2UgdGhlIFN1cmZhY2UgdG8gZHJhdyBvblxuICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIGEgdmFsaWQgI1JHQiBTdHJpbmcsICNmZjAwY2NcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50bGlzdCBhcnJheSBvZiB2ZXJ0aWNlcyBbeCwgeV0gb2YgdGhlIHBvbHlnb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCB0aGUgd2lkdGggb2YgbGluZSwgaWYgMCBvciBub3QgZ2l2ZW4gdGhlIHBvbHlnb24gaXMgZmlsbGVkLlxuICovXG5leHBvcnRzLnBvbHlnb24gPSBmdW5jdGlvbihzdXJmYWNlLCBjb2xvciwgcG9pbnRsaXN0LCB3aWR0aCkge1xuICAgdmFyIGN0eCA9IHN1cmZhY2UuY29udGV4dDtcbiAgIGN0eC5zYXZlKCk7XG4gICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICBjdHguYmVnaW5QYXRoKCk7XG4gICBwb2ludGxpc3QuZm9yRWFjaChmdW5jdGlvbihwb2ludCwgaWR4KSB7XG4gICAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgICBjdHgubW92ZVRvKHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgY3R4LmxpbmVUbyhwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgfVxuICAgfSk7XG4gICBjdHguY2xvc2VQYXRoKCk7XG4gICBpZiAoaXNOYU4od2lkdGgpIHx8IHdpZHRoID09PSAwKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB3aWR0aCB8fCAxO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgfVxuICAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbi8qKlxuICogRHJhdyBhIHF1YWRyYXRpYyBjdXJ2ZSB3aXRoIG9uZSBjb250cm9sIHBvaW50IG9uIHRoZSBzdXJmYWNlLlxuICogVGhlIGNvbnRyb2wgcG9pbnQgcG9zaXRpb24gZGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIHF1YWRyYXRpYyBjdXJ2ZS5cbiAqXG4gKiBAcGFyYW0ge2dhbWVqcy5ncmFwaGljcy5TdXJmYWNlfSBzdXJmYWNlIHRoZSBTdXJmYWNlIHRvIGRyYXcgb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciB2YWxpZCAjUkdCIHN0cmluZywgZS5nLiwgXCIjZmYwMDAwXCJcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0UG9zIFt4LCB5XSB0aGUgc3RhcnQgcG9zaXRpb24gZm9yIHRoZSBxdWFkcmF0aWMgY3VydmVcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZFBvcyBbeCwgeV0gdGhlIGVuZCBwb3NpdGlvbiBmb3IgdGhlIHF1YWRyYXRpYyBjdXJ2ZVxuICogQHBhcmFtIHtBcnJheX0gY29udHJvbFBvcyBbeCwgeV0gcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgcG9pbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBvZiB0aGUgcXVhZHJhdGljIGN1cnZlLCBkZWZhdWx0cyB0byAxXG4gKi9cbmV4cG9ydHMucXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbihzdXJmYWNlLCBjb2xvciwgc3RhcnRQb3MsIGVuZFBvcywgY29udHJvbFBvcywgd2lkdGgpIHtcbiAgIGlmICghc3RhcnRQb3MgfHwgIShzdGFydFBvcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbcXVhZHJhdGljX2N1cnZlXSBzdGFydFBvcyBtdXN0IGJlIGRlZmluZWQhJyk7XG4gICB9XG4gICBpZiAoIWVuZFBvcyB8fCAhKGVuZFBvcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbcXVhZHJhdGljX2N1cnZlXSBlbmRQb3MgbXVzdCBiZSBkZWZpbmVkIScpO1xuICAgfVxuICAgaWYgKCFjb250cm9sUG9zIHx8ICEoY29udHJvbFBvcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbcXVhZHJhdGljX2N1cnZlXSBjb250cm9sUG9zIG11c3QgYmUgZGVmaW5lZCEnKTtcbiAgIH1cblxuICAgdmFyIGN0eCA9IHN1cmZhY2UuY29udGV4dDtcbiAgIGN0eC5zYXZlKCk7XG4gICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICBjdHgubGluZVdpZHRoID0gd2lkdGggfHwgMTtcblxuICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgY3R4Lm1vdmVUbyhzdGFydFBvc1swXSwgc3RhcnRQb3NbMV0pO1xuICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvc1swXSwgY29udHJvbFBvc1sxXSwgZW5kUG9zWzBdLCBlbmRQb3NbMV0pO1xuICAgY3R4LnN0cm9rZSgpO1xuXG4gICBjdHgucmVzdG9yZSgpO1xufTtcblxuLyoqXG4gKiBEcmF3IGEgYmV6aWVyIGN1cnZlIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzIG9uIHRoZSBzdXJmYWNlLlxuICogVGhlIGNvbnRyb2wgcG9pbnQgcG9zaXRpb25zIGRlZmluZSB0aGUgc2hhcGUgb2YgdGhlIGJlemllciBjdXJ2ZS5cbiAqXG4gKiBAcGFyYW0ge2dhbWVqcy5ncmFwaGljcy5TdXJmYWNlfSBzdXJmYWNlIHRoZSBTdXJmYWNlIHRvIGRyYXcgb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciB2YWxpZCAjUkdCIHN0cmluZywgZS5nLiwgXCIjZmYwMDAwXCJcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0UG9zIFt4LCB5XSB0aGUgc3RhcnQgcG9zaXRpb24gZm9yIHRoZSBiZXppZXIgY3VydmVcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZFBvcyBbeCwgeV0gdGhlIGVuZCBwb3NpdGlvbiBmb3IgdGhlIGJlemllciBjdXJ2ZVxuICogQHBhcmFtIHtBcnJheX0gY3QxUG9zIFt4LCB5XSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludFxuICogQHBhcmFtIHtBcnJheX0gY3QyUG9zIFt4LCB5XSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBvZiB0aGUgYmV6aWVyIGN1cnZlLCBkZWZhdWx0cyB0byAxXG4gKi9cbmV4cG9ydHMuYmV6aWVyQ3VydmUgPSBmdW5jdGlvbihzdXJmYWNlLCBjb2xvciwgc3RhcnRQb3MsIGVuZFBvcywgY3QxUG9zLCBjdDJQb3MsIHdpZHRoKSB7XG4gICBpZiAoIXN0YXJ0UG9zIHx8ICEoc3RhcnRQb3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2Jlemllcl9jdXJ2ZV0gc3RhcnRQb3MgbXVzdCBiZSBkZWZpbmVkIScpO1xuICAgfVxuICAgaWYgKCFlbmRQb3MgfHwgIShlbmRQb3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2Jlemllcl9jdXJ2ZV0gZW5kUG9zIG11c3QgYmUgZGVmaW5lZCEnKTtcbiAgIH1cbiAgIGlmICghY3QxUG9zIHx8ICEoY3QxUG9zIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tiZXppZXJfY3VydmVdIGN0MVBvcyBtdXN0IGJlIGRlZmluZWQhJyk7XG4gICB9XG4gICBpZiAoIWN0MlBvcyB8fCAhKGN0MlBvcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbYmV6aWVyX2N1cnZlXSBjdDJQb3MgbXVzdCBiZSBkZWZpbmVkIScpO1xuICAgfVxuICAgdmFyIGN0eCA9IHN1cmZhY2UuY29udGV4dDtcbiAgIGN0eC5zYXZlKCk7XG4gICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICBjdHgubGluZVdpZHRoID0gd2lkdGggfHwgMTtcblxuICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgY3R4Lm1vdmVUbyhzdGFydFBvc1swXSwgc3RhcnRQb3NbMV0pO1xuICAgY3R4LmJlemllckN1cnZlVG8oY3QxUG9zWzBdLCBjdDFQb3NbMV0sIGN0MlBvc1swXSwgY3QyUG9zWzFdLCBlbmRQb3NbMF0sIGVuZFBvc1sxXSk7XG4gICBjdHguc3Ryb2tlKCk7XG5cbiAgIGN0eC5yZXN0b3JlKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgc3VyZmFjZSB3aGljaCBob2xkcyB0aGlzIHN1cmZhY2Ugcm90YXRlIGJ5IGFuZ2xlIGRlZ3JlZXMuXG4gKiBVbmxlc3Mgcm90YXRpbmcgYnkgOTAgZGVncmVlIGluY3JlbWVudHMsIHRoZSBpbWFnZSB3aWxsIGJlIHBhZGRlZCBsYXJnZXIgdG8gaG9sZCB0aGUgbmV3IHNpemUuXG4gKiBAcGFyYW0ge2FuZ2VsfSBhbmdsZSBDbG9ja3dpc2UgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7U3VyZmFjZX0gbmV3LCByb3RhdGVkIHN1cmZhY2VcbiAqL1xuU3VyZmFjZS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICB2YXIgb3JpZ1NpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgIHZhciByYWRpYW5zID0gKGFuZ2xlICogTWF0aC5QSSAvIDE4MCk7XG4gICB2YXIgbmV3U2l6ZSA9IG9yaWdTaXplO1xuICAgLy8gZmluZCBuZXcgYm91bmRpbmcgYm94XG4gICBpZiAoYW5nbGUgJSAzNjAgIT09IDApIHtcbiAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KCk7XG4gICAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgICAgWy1yZWN0LndpZHRoLzIsIHJlY3QuaGVpZ2h0LzJdLFxuICAgICAgICAgW3JlY3Qud2lkdGgvMiwgcmVjdC5oZWlnaHQvMl0sXG4gICAgICAgICBbLXJlY3Qud2lkdGgvMiwgLXJlY3QuaGVpZ2h0LzJdLFxuICAgICAgICAgW3JlY3Qud2lkdGgvMiwgLXJlY3QuaGVpZ2h0LzJdXG4gICAgICBdO1xuICAgICAgdmFyIHJvdFBvaW50cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgcmV0dXJuIHZlY3RvcnMucm90YXRlKHAsIHJhZGlhbnMpO1xuICAgICAgfSk7XG4gICAgICB2YXIgeHMgPSByb3RQb2ludHMubWFwKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHBbMF07IH0pO1xuICAgICAgdmFyIHlzID0gcm90UG9pbnRzLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBwWzFdOyB9KTtcbiAgICAgIHZhciBsZWZ0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgeHMpO1xuICAgICAgdmFyIHJpZ2h0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgeHMpO1xuICAgICAgdmFyIGJvdHRvbSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHlzKTtcbiAgICAgIHZhciB0b3AgPSBNYXRoLm1heC5hcHBseShNYXRoLCB5cyk7XG4gICAgICBuZXdTaXplID0gW3JpZ2h0LWxlZnQsIHRvcC1ib3R0b21dO1xuICAgfVxuICAgdmFyIG5ld1N1cmZhY2UgPSBuZXcgU3VyZmFjZShuZXdTaXplKTtcbiAgIHZhciBtID0gbWF0cml4LnRyYW5zbGF0ZSh0aGlzLl9tYXRyaXgsIG9yaWdTaXplWzBdLzIsIG9yaWdTaXplWzFdLzIpO1xuICAgbSA9IG1hdHJpeC5yb3RhdGUobSwgcmFkaWFucyk7XG4gICBtID0gbWF0cml4LnRyYW5zbGF0ZShtLCAtb3JpZ1NpemVbMF0vMiwgLW9yaWdTaXplWzFdLzIpO1xuICAgdmFyIG9mZnNldCA9IFsobmV3U2l6ZVswXSAtIG9yaWdTaXplWzBdKSAvIDIsIChuZXdTaXplWzFdIC0gb3JpZ1NpemVbMV0pIC8gMl07XG4gICBuZXdTdXJmYWNlLmNvbnRleHQuc2F2ZSgpO1xuICAgbmV3U3VyZmFjZS5jb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgIG5ld1N1cmZhY2UuYmxpdCh0aGlzLCBvZmZzZXQpO1xuICAgbmV3U3VyZmFjZS5jb250ZXh0LnJlc3RvcmUoKTtcbiAgIHJldHVybiBuZXdTdXJmYWNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IHN1cmZhY2UgaG9sZGluZyB0aGUgc2NhbGVkIHN1cmZhY2UuXG4gKiBAcGFyYW0ge0FycmF5fSBkaW1lbnNpb25zIG5ldyBbd2lkdGgsIGhlaWdodF0gb2Ygc3VyZmFjZSBhZnRlciBzY2FsaW5nXG4gKiBAcmV0dXJucyB7U3VyZmFjZX0gbmV3LCBzY2FsZWQgc3VyZmFjZVxuICovXG5TdXJmYWNlLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKGRpbXMpIHtcbiAgIHZhciB3aWR0aCA9IGRpbXNbMF07XG4gICB2YXIgaGVpZ2h0ID0gZGltc1sxXTtcbiAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tnYW1lanMudHJhbnNmb3JtLnNjYWxlXSBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCcsIFt3aWR0aCwgaGVpZ2h0XSk7XG4gICB9XG4gICB2YXIgb2xkRGltcyA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgdmFyIHdzID0gd2lkdGggLyBvbGREaW1zWzBdO1xuICAgdmFyIGhzID0gaGVpZ2h0IC8gb2xkRGltc1sxXTtcbiAgIHZhciBuZXdTdXJmYWNlID0gbmV3IFN1cmZhY2UoW3dpZHRoLCBoZWlnaHRdKTtcbiAgIHZhciBvcmlnaW5hbE1hdHJpeCA9IHRoaXMuX21hdHJpeC5zbGljZSgwKTtcbiAgIHZhciBtID0gbWF0cml4LnNjYWxlKG1hdHJpeC5pZGVudGl0eSgpLCBbd3MsIGhzXSk7XG4gICBuZXdTdXJmYWNlLmNvbnRleHQuc2F2ZSgpO1xuICAgbmV3U3VyZmFjZS5jb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgIG5ld1N1cmZhY2UuYmxpdCh0aGlzKTtcbiAgIG5ld1N1cmZhY2UuY29udGV4dC5yZXN0b3JlKCk7XG4gICByZXR1cm4gbmV3U3VyZmFjZTtcbn07XG5cbi8qKlxuICogRmxpcCBhIFN1cmZhY2UgZWl0aGVyIHZlcnRpY2FsbHksIGhvcml6b250YWxseSBvciBib3RoLiBUaGlzIHJldHVybnNcbiAqIGEgbmV3IFN1cmZhY2UgKGkuZTogbm9uZGVzdHJ1Y3RpdmUpLlxuICogQHBhcmFtIHtCb29sZWFufSBmbGlwSG9yaXpvbnRhbFxuICogQHBhcmFtIHtCb29sZWFufSBmbGlwVmVydGljYWxcbiAqIEByZXR1cm5zIHtTdXJmYWNlfSBuZXcsIGZsaXBwZWQgc3VyZmFjZVxuICovXG5TdXJmYWNlLnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24oZmxpcEhvcml6b250YWwsIGZsaXBWZXJ0aWNhbCkge1xuICAgdmFyIGRpbXMgPSB0aGlzLmdldFNpemUoKTtcbiAgIHZhciBuZXdTdXJmYWNlID0gbmV3IFN1cmZhY2UoZGltcyk7XG4gICB2YXIgc2NhbGVYID0gMTtcbiAgIHZhciBzY2FsZVkgPSAxO1xuICAgdmFyIHhQb3MgPSAwO1xuICAgdmFyIHlQb3MgPSAwO1xuICAgaWYgKGZsaXBIb3Jpem9udGFsID09PSB0cnVlKSB7XG4gICAgICBzY2FsZVggPSAtMTtcbiAgICAgIHhQb3MgPSAtZGltc1swXTtcbiAgIH1cbiAgIGlmIChmbGlwVmVydGljYWwgPT09IHRydWUpIHtcbiAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgeVBvcyA9IC1kaW1zWzFdO1xuICAgfVxuICAgbmV3U3VyZmFjZS5jb250ZXh0LnNhdmUoKTtcbiAgIG5ld1N1cmZhY2UuY29udGV4dC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICBuZXdTdXJmYWNlLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMuY2FudmFzLCB4UG9zLCB5UG9zKTtcbiAgIG5ld1N1cmZhY2UuY29udGV4dC5yZXN0b3JlKCk7XG4gICByZXR1cm4gbmV3U3VyZmFjZTtcbn07XG5cblxuLyoqXG4gKiBEaXJlY3RseSBjb3B5IHZhbHVlcyBmcm9tIGFuIGFycmF5IGludG8gYSBTdXJmYWNlLlxuICpcbiAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gYmxpdHRpbmcgdGhlIGBzdXJmYWNlYCBwcm9wZXJ0eSBvbiBhIFN1cmZhY2VBcnJheVxuICpcbiAqIFRoZSBhcnJheSBtdXN0IGJlIHRoZSBzYW1lIGRpbWVuc2lvbnMgYXMgdGhlIFN1cmZhY2UgYW5kIHdpbGwgY29tcGxldGVseVxuICogcmVwbGFjZSBhbGwgcGl4ZWwgdmFsdWVzLlxuICogQHBhcmFtIHtnYW1lanMuZ3JhcGhpY3MuU3VyZmFjZX0gc3VyZmFjZVxuICogQHBhcmFtIHtnYW1lanMuZ3JhcGhpY3MuU3VyZmFjZWFycmF5LlN1cmZhY2VBcnJheX0gc3VyZmFjZUFycmF5XG4gKi9cbmV4cG9ydHMuYmxpdEFycmF5ID0gZnVuY3Rpb24oc3VyZmFjZSwgc3VyZmFjZUFycmF5KSB7XG4gICBzdXJmYWNlLmNvbnRleHQucHV0SW1hZ2VEYXRhKHN1cmZhY2VBcnJheS5pbWFnZURhdGEsIDAsIDApO1xuICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBGYXN0IHBpeGVsIGFjY2Vzcy4gVGhlIFN1cmZhY2VBcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgd2l0aCBhIHN1cmZhY2Ugd2hvc2UgdmFsdWVzXG4gKiBhcmUgdGhlbiB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHBpeGVsIGFycmF5LlxuICpcbiAqIFRoZSBzdXJmYWNlIHBhc3NlZCBhcyBhcmd1bWVudCBpcyBub3QgbW9kaWZpZWQgYnkgdGhlIFN1cmZhY2VBcnJheS5cbiAqXG4gKiBJZiBhbiBhcnJheSBpcyB1c2VkIHRvIGNvbnN0cnVjdCBTdXJmYWNlQXJyYXksIHRoZSBhcnJheSBtdXN0IGRlc2NyaWJlXG4gKiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgU3VyZmFjZUFycmF5IFt3aWR0aCwgaGVpZ2h0XS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgLy8gY3JlYXRlIGFycmF5IGZyb20gZGlzcGxheSBzdXJmYWNlXG4gKiAgIHZhciBzcmZBcnJheSA9IG5ldyBTdXJmYWNlQXJyYXkoZGlzcGxheSk7XG4gKiAgIC8vIGRpcmVjdCBwaXhlbCBhY2Nlc3NcbiAqICAgc3JmQXJyYXkuc2V0KDUwLCAxMDAsIFsyNTUsIDAsIDAsIDEwMF0pO1xuICogICBjb25zb2xlLmxvZyhzcmZBcnJheS5nZXQoMzAsIDUwKSk7XG4gKiAgIC8vIGJsaXQgbW9kaWZpZWQgYXJyYXkgYmFjayB0byBkaXNwbGF5IHN1cmZhY2VcbiAqICAgYmxpdEFycmF5KGRpc3BsYXksIHNyZkFycmF5KTtcbiAqXG4gKiBAcGFyYW0ge2dhbWVqcy5ncmFwaGljcy5TdXJmYWNlfEFycmF5fSBzdXJmYWNlT3JEaW1lbnNpb25zXG4gKiBAc2VlIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1LzJkY29udGV4dC8jcGl4ZWwtbWFuaXB1bGF0aW9uXG4gKi9cbnZhciBTdXJmYWNlQXJyYXkgPSBleHBvcnRzLlN1cmZhY2VBcnJheSA9IGZ1bmN0aW9uKHN1cmZhY2VPckRpbWVuc2lvbnMpIHtcbiAgIHZhciBzaXplID0gbnVsbDtcbiAgIHZhciBkYXRhID0gbnVsbDtcbiAgIHZhciBpbWFnZURhdGEgPSBudWxsO1xuXG4gICAvKipcbiAgICAqIFNldCByZ2JhIHZhbHVlIGF0IHBvc2l0aW9uIHgsIHkuXG4gICAgKlxuICAgICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgdGhpcyBmdW5jdGlvbiBoYXMgb25seSBvbmUgc2lnbmF0dXJlXG4gICAgKiBiZWluZyBOdW1iZXIsIE51bWJlciwgQXJyYXlbNF0uXG4gICAgKlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBwb3NpdGlvbiBvZiBwaXhlbFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBwb3NpdGlvbiBvZiBwaXhlbFxuICAgICogQHBhcmFtIHtBcnJheX0gcmdiYSBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdIHZhbHVlcyBbMjU1LCAyNTUsIDI1NSwgMjU1XSAoYWxwaGEsIHRoZSBsYXN0IGFyZ3VtZW50IGRlZmF1bHRzIHRvIDI1NSlcbiAgICAqIEB0aHJvd3MgRXJyb3IgaWYgeCwgeSBvdXQgb2YgcmFuZ2VcbiAgICAqL1xuICAgdGhpcy5zZXQgPSBmdW5jdGlvbih4LCB5LCByZ2JhKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gKHggKiA0KSArICh5ICogc2l6ZVswXSAqIDQpO1xuICAgICAgLyoqIGZhc3RlciB3aXRob3V0XG4gICAgICBpZiAob2Zmc2V0ICsgMyA+PSBkYXRhLmxlbmd0aCB8fCB4IDwgMCB8fCB5IDwgMCkge1xuICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4LCB5IG91dCBvZiByYW5nZScsIHgsIHkpO1xuICAgICAgfVxuICAgICAgKiovXG4gICAgICBkYXRhW29mZnNldF0gPSByZ2JhWzBdO1xuICAgICAgZGF0YVtvZmZzZXQrMV0gPSByZ2JhWzFdO1xuICAgICAgZGF0YVtvZmZzZXQrMl0gPSByZ2JhWzJdO1xuICAgICAgZGF0YVtvZmZzZXQrM10gPSByZ2JhWzNdID09PSB1bmRlZmluZWQgPyAyNTUgOiByZ2JhWzNdO1xuICAgICAgcmV0dXJuO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBHZXQgcmdiYSB2YWx1ZSBhdCBwb3NpdGlvbiB4eSxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICogQHJldHVybnMge0FycmF5fSBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdXG4gICAgKi9cbiAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIG9mZnNldCA9ICh4ICogNCkgKyAoeSAqIHNpemVbMF0gKiA0KTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICBkYXRhW29mZnNldF0sXG4gICAgICAgICBkYXRhW29mZnNldCsxXSxcbiAgICAgICAgIGRhdGFbb2Zmc2V0KzJdLFxuICAgICAgICAgZGF0YVtvZmZzZXQrM11cbiAgICAgIF07XG4gICB9O1xuXG4gICAvKipcbiAgICAqIGEgbmV3IGdhbWVqcy5ncmFwaGljcy5TdXJmYWNlIG9uIGV2ZXJ5IGFjY2VzcywgcmVwcmVzZW50aW5nXG4gICAgKiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgU3VyZmFjZUFycmF5LlxuICAgICogQHR5cGUge2dhbWVqcy5ncmFwaGljcy5TdXJmYWNlfVxuICAgICovXG4gICAvLyBmb3IganNkb2Mgb25seVxuICAgdGhpcy5zdXJmYWNlID0gbnVsbDtcblxuICAgb2JqZWN0cy5hY2Nlc3NvcnModGhpcywge1xuICAgICAgc3VyZmFjZToge1xuICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzID0gbmV3IGdhbWVqcy5ncmFwaGljcy5TdXJmYWNlKHNpemUpO1xuICAgICAgICAgICAgcy5jb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW1hZ2VEYXRhOiB7XG4gICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlRGF0YTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH0pO1xuXG4gICB0aGlzLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzaXplO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBjb25zdHJ1Y3RvclxuICAgICovXG4gICBpZiAoc3VyZmFjZU9yRGltZW5zaW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBzaXplID0gc3VyZmFjZU9yRGltZW5zaW9ucztcbiAgICAgIGltYWdlRGF0YSA9IGdhbWVqcy5kaXNwbGF5LmdldFN1cmZhY2UoKS5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YShzaXplWzBdLCBzaXplWzFdKTtcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gc3VyZmFjZU9yRGltZW5zaW9ucy5nZXRTaXplKCk7XG4gICAgICBpbWFnZURhdGEgPSBzdXJmYWNlT3JEaW1lbnNpb25zLmdldEltYWdlRGF0YSgwLCAwLCBzaXplWzBdLCBzaXplWzFdKTtcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgIH1cbiAgIHJldHVybiB0aGlzO1xufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNYWtlIHN5bmNocm9ub3VzIGh0dHAgcmVxdWVzdHMgdG8geW91ciBnYW1lJ3Mgc2VydmVyc2lkZSBjb21wb25lbnQuXG4gKlxuICogSWYgeW91IGNvbmZpZ3VyZSBhIGFqYXggYmFzZSBVUkwgeW91IGNhbiBtYWtlIGh0dHAgcmVxdWVzdHMgdG8geW91clxuICogc2VydmVyIHVzaW5nIHRob3NlIGZ1bmN0aW9ucy5cblxuICogVGhlIG1vc3QgaGlnaC1sZXZlbCBmdW5jdGlvbnMgYXJlIGBsb2FkKClgIGFuZCBgc2F2ZSgpYCB3aGljaCB0YWtlXG4gKiBhbmQgcmV0dXJuIGEgSmF2YVNjcmlwdCBvYmplY3QsIHdoaWNoIHRoZXkgd2lsbCBzZW5kIHRvIC8gcmVjaWV2ZSBmcm9tXG4gKiB0aGUgc2VydmVyLXNpZGUgaW4gSlNPTiBmb3JtYXQuXG4gKlxuICpcbiAqL1xuXG4vKipcbiAqIFJlc3BvbnNlIG9iamVjdCByZXR1cm5lZCBieSBodHRwIGZ1bmN0aW9ucyBgZ2V0YCBhbmQgYHBvc3RgLiBUaGlzXG4gKiBjbGFzcyBpcyBub3QgaW5zdGFudGlhYmxlLlxuICpcbiAqIEBwYXJhbXtTdHJpbmd9IHJlc3BvbnNlVGV4dFxuICogQHBhcmFtIHtTdHJpbmd9IHJlc3BvbnNlWE1MXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RhdHVzVGV4dFxuICovXG5leHBvcnRzLlJlc3BvbnNlID0gZnVuY3Rpb24oKSB7XG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJcbiAgICAqL1xuICAgdGhpcy5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlcikgIHtcbiAgIH07XG4gICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3BvbnNlIGNsYXNzIG5vdCBpbnN0YW50aWFibGUnKTtcbn07XG5cbi8qKlxuICogTWFrZSBodHRwIHJlcXVlc3QgdG8gc2VydmVyLXNpZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgaHR0cCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB0eXBlIFwiQWNjZXB0XCIgaGVhZGVyIHZhbHVlXG4gKiBAcmV0dXJuIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAqL1xudmFyIGFqYXggPSBleHBvcnRzLmFqYXggPSBmdW5jdGlvbihtZXRob2QsIHVybCwgZGF0YSwgdHlwZSkge1xuICAgZGF0YSA9IGRhdGEgfHwgbnVsbDtcbiAgIHZhciByZXNwb25zZSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgcmVzcG9uc2Uub3BlbihtZXRob2QsIHVybCwgZmFsc2UpO1xuICAgaWYgKHR5cGUpIHtcbiAgICAgIHJlc3BvbnNlLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgdHlwZSk7XG4gICB9XG4gICBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgcmVzcG9uc2Uuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgIH1cbiAgIHJlc3BvbnNlLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcbiAgIHJlc3BvbnNlLnNlbmQoZGF0YSk7XG4gICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG4vKipcbiAqIE1ha2UgaHR0cCBHRVQgcmVxdWVzdCB0byBzZXJ2ZXItc2lkZVxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICovXG52YXIgZ2V0ID0gZXhwb3J0cy5nZXQgPSBmdW5jdGlvbih1cmwpIHtcbiAgIHJldHVybiBhamF4KCdHRVQnLCB1cmwpO1xufTtcblxuLyoqXG4gKiBNYWtlIGh0dHAgUE9TVCByZXF1ZXN0IHRvIHNlcnZlci1zaWRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdHlwZSBcIkFjY2VwdFwiIGhlYWRlciB2YWx1ZVxuICogQHJldHVybnMge1Jlc3BvbnNlfVxuICovXG52YXIgcG9zdCA9IGV4cG9ydHMucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgdHlwZSkge1xuICAgcmV0dXJuIGFqYXgoJ1BPU1QnLCB1cmwsIGRhdGEsIHR5cGUpO1xufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KHJlc3BvbnNlKSB7XG4gICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICByZXR1cm4gZXZhbCgnKCcgKyByZXNwb25zZS5yZXNwb25zZVRleHQgKyAnKScpO1xuICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbn1cblxuZnVuY3Rpb24gYWpheEJhc2VIcmVmKCkge1xuICAgIHJldHVybiAod2luZG93LiRnICYmIHdpbmRvdy4kZy5hamF4QmFzZUhyZWYpIHx8ICcuLyc7XG59XG5cbi8qKlxuICogTG9hZCBhbiBvYmplY3QgZnJvbSB0aGUgc2VydmVyLXNpZGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBvYmplY3QgbG9hZGVkIGZyb20gdGhlIHNlcnZlclxuICovXG5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbih1cmwpIHtcbiAgIHJldHVybiBzdHJpbmdpZnkoZ2V0KGFqYXhCYXNlSHJlZigpICsgdXJsKSk7XG59O1xuXG4vKipcbiAqIFNlbmQgYW4gb2JqZWN0IHRvIGEgc2VydmVyLXNpZGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdHlwZSBcIkFjY2VwdFwiIGhlYWRlciB2YWx1ZVxuICogQHJldHVybnMge09iamVjdH0gdGhlIHJlc3BvbnNlIG9iamVjdFxuICovXG5leHBvcnRzLnNhdmUgPSBmdW5jdGlvbih1cmwsIGRhdGEsIHR5cGUpIHtcbiAgIHJldHVybiBzdHJpbmdpZnkocG9zdChhamF4QmFzZUhyZWYoKSArIHVybCwge3BheWxvYWQ6IGRhdGF9LCB0eXBlKSk7XG59O1xuIiwidmFyIGdhbWVqcyA9IHJlcXVpcmUoJy4uL2dhbWVqcycpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgTG9hZCBpbWFnZXMgYXMgU3VyZmFjZXMuXG4gKlxuICogU291bmRzICYgSW1hZ2VzIGFyZSBsb2FkZWQgcmVsYXRpdmUgdG8geW91ciBnYW1lJ3MgaHRtbCBwYWdlXG4gKiAodGhlIGh0bWwgd2hpY2ggaW5jbHVkZXMgdGhlIEdhbWVKcyBjb2RlKSBvciByZWxhdGl2ZSB0byB0aGVcbiAqIHByb3BlcnR5IGB3aW5kb3cuJGcucmVzb3VyY2VCYXNlSHJlZmBcbiAqIGlmIGl0IGlzIHNldC5cbiAqXG4gKlxuICovXG5cbnZhciBDQUNIRSA9IHt9O1xuXG4vKipcbiAqIG5lZWQgdG8gZXhwb3J0IHByZWxvYWRpbmcgc3RhdHVzIGZvciByZXF1aXJlXG4gKiBAaWdub3JlXG4gKi9cbnZhciBfUFJFTE9BRElORyA9IGZhbHNlO1xuXG4vKipcbiAqIExvYWQgaW1hZ2UgYW5kIHJldHVybiBpdCBvbiBhIFN1cmZhY2UuXG4gKlxuICogQWxsIGltYWdlcyBtdXN0IGJlIHByZWxvYWRlZCBiZWZvcmUgdGhleSBjYW4gYmUgdXNlZC5cbiAqIEBleGFtcGxlXG5cbiAqICAgICBnYW1lanMucHJlbG9hZChbXCIuL2ltYWdlcy9zaGlwLnBuZ1wiLCBcIi4vaW1hZ2VzL3N1bmZsb3dlci5wbmdcIl0pO1xuICogICAgIC8vIC4uLmxhdGVyLi4uXG4gKiAgICAgZGlzcGxheS5ibGl0KGdhbWVqcy5pbWFnZS5sb2FkKCdpbWFnZXMvc2hpcC5wbmcnKSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xkb20uSW1hZ2V9IHVyaU9ySW1hZ2UgcmVzb3VyY2UgdXJpIGZvciBpbWFnZVxuICogQHJldHVybnMge2dhbWVqcy5ncmFwaGljcy5TdXJmYWNlfSBzdXJmYWNlIHdpdGggdGhlIGltYWdlIG9uIGl0LlxuICovXG5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbihrZXkpIHtcbiAgIHZhciBpbWc7XG4gICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGltZyA9IENBQ0hFW2tleV07XG4gICAgICBpZiAoIWltZykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwiJyArIGtleSArICdcIiwgZ2FtZWpzLnByZWxvYWQoKSBhbGwgaW1hZ2VzIGJlZm9yZSB0cnlpbmcgdG8gbG9hZCB0aGVtLicpO1xuICAgICAgfVxuICAgfSBlbHNlIHtcbiAgICAgIGltZyA9IGtleTtcbiAgIH1cbiAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgIC8vIElFRklYIG1pc3NpbmcgaHRtbDUgZmVhdHVyZSBuYXR1cmFsV2lkdGgvSGVpZ2h0XG4gICBjYW52YXMud2lkdGggPSBpbWcubmF0dXJhbFdpZHRoIHx8IGltZy53aWR0aDtcbiAgIGNhbnZhcy5oZWlnaHQgPSBpbWcubmF0dXJhbEhlaWdodCB8fCBpbWcuaGVpZ2h0O1xuICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICBpbWcuZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW2ltZy5uYXR1cmFsV2lkdGgsIGltZy5uYXR1cmFsSGVpZ2h0XTsgfTtcbiAgIHZhciBzdXJmYWNlID0gbmV3IGdhbWVqcy5ncmFwaGljcy5TdXJmYWNlKGltZy5nZXRTaXplKCkpO1xuICAgLy8gTk9URSBoYWNrIHNldHRpbmcgcHJvdGVjdGVkIF9jYW52YXMgZGlyZWN0bHlcbiAgIHN1cmZhY2UuX2NhbnZhcyA9IGNhbnZhcztcbiAgIHN1cmZhY2UuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgcmV0dXJuIHN1cmZhY2U7XG59O1xuXG5cbi8qKlxuICogYWRkIGFsbCBpbWFnZXMgb24gdGhlIGN1cnJyZW50IHBhZ2UgaW50byBjYWNoZVxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybjtcbn07XG5cbi8qKlxuICogcHJlbG9hZCB0aGUgZ2l2ZW4gaW1nIFVSSXNcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd2hpY2ggcmV0dXJucyAwLTEgZm9yIHByZWxvYWQgcHJvZ3Jlc3NcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5wcmVsb2FkID0gZnVuY3Rpb24oaW1nSWRlbnRzKSB7XG5cbiAgIHZhciBjb3VudExvYWRlZCA9IDA7XG4gICB2YXIgY291bnRUb3RhbCA9IDA7XG5cbiAgIGZ1bmN0aW9uIGluY3JlbWVudExvYWRlZCgpIHtcbiAgICAgIGNvdW50TG9hZGVkKys7XG4gICAgICBpZiAoY291bnRMb2FkZWQgPT0gY291bnRUb3RhbCkge1xuICAgICAgICAgX1BSRUxPQURJTkcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb3VudExvYWRlZCAlIDEwID09PSAwKSB7XG4gICAgICAgICBnYW1lanMubG9nZ2luZy5kZWJ1ZygnZ2FtZWpzLmltYWdlOiBwcmVsb2FkZWQgICcgKyBjb3VudExvYWRlZCArICcgb2YgJyArIGNvdW50VG90YWwpO1xuICAgICAgfVxuICAgfVxuXG4gICBmdW5jdGlvbiBnZXRQcm9ncmVzcygpIHtcbiAgICAgIHJldHVybiBjb3VudFRvdGFsID4gMCA/IGNvdW50TG9hZGVkIC8gY291bnRUb3RhbCA6IDE7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHN1Y2Nlc3NIYW5kbGVyKCkge1xuICAgICAgYWRkVG9DYWNoZSh0aGlzKTtcbiAgICAgIGluY3JlbWVudExvYWRlZCgpO1xuICAgfVxuICAgZnVuY3Rpb24gZXJyb3JIYW5kbGVyKCkge1xuICAgICAgaW5jcmVtZW50TG9hZGVkKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGxvYWRpbmcgJyArIHRoaXMuc3JjKTtcbiAgIH1cblxuICAgdmFyIGtleTtcbiAgIGZvciAoa2V5IGluIGltZ0lkZW50cykge1xuICAgICAgdmFyIGxvd2VyS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJLZXkuaW5kZXhPZignLnBuZycpID09IC0xICYmXG4gICAgICAgICAgICBsb3dlcktleS5pbmRleE9mKCcuanBnJykgPT0gLTEgJiZcbiAgICAgICAgICAgIGxvd2VyS2V5LmluZGV4T2YoJy5qcGVnJykgPT0gLTEgJiZcbiAgICAgICAgICAgIGxvd2VyS2V5LmluZGV4T2YoJy5zdmcnKSA9PSAtMSAmJlxuICAgICAgICAgICAgbG93ZXJLZXkuaW5kZXhPZignLmdpZicpID09IC0xKSB7XG4gICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgc3VjY2Vzc0hhbmRsZXIsIHRydWUpO1xuICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyLCB0cnVlKTtcbiAgICAgIGltZy5zcmMgPSBpbWdJZGVudHNba2V5XTtcbiAgICAgIGltZy5nYW1lanNLZXkgPSBrZXk7XG4gICAgICBjb3VudFRvdGFsKys7XG4gICB9XG4gICBpZiAoY291bnRUb3RhbCA+IDApIHtcbiAgICAgIF9QUkVMT0FESU5HID0gdHJ1ZTtcbiAgIH1cbiAgIHJldHVybiBnZXRQcm9ncmVzcztcbn07XG5cbi8qKlxuICogYWRkIHRoZSBnaXZlbiA8aW1nPiBkb20gZWxlbWVudHMgaW50byB0aGUgY2FjaGUuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRkVG9DYWNoZSA9IGZ1bmN0aW9uKGltZykge1xuICAgQ0FDSEVbaW1nLmdhbWVqc0tleV0gPSBpbWc7XG4gICByZXR1cm47XG59O1xuIiwiXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhdGljIG1ldGhvZHMgZm9yIGxvZ2dpbmcgYW5kIHNldHRpbmcgdGhlIGxvZyBsZXZlbC4gQWxsIGxvZ2dpbmcgZnVuY3Rpb25zIChgaW5mbygpYCwgYGRlYnVnKClgLCBldGMuKSB0YWtlXG4gKiBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgd2lsbCBwcmludCB0aGVtIGluIG9uZSBsaW5lLlxuICpcbiAqL1xuXG52YXIgREVCVUdfTEVWRUxTID0gWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InLCAnZmF0YWwnXTtcbnZhciBkZWJ1Z0xldmVsID0gMjtcbnZhciBnYW1lanMgPSByZXF1aXJlKCcuLi9nYW1lanMnKTtcblxuLyoqXG4gKiBzZXQgbG9nTGV2ZWwgYXMgc3RyaW5nIG9yIG51bWJlclxuICogICAqIDAgPSBpbmZvXG4gKiAgICogMSA9IHdhcm5cbiAqICAgKiAyID0gZXJyb3JcbiAqICAgKiAzID0gZmF0YWxcbiAqXG4gKiBAZXhhbXBsZVxuICogZ2FtZWpzLnNldExvZ0xldmVsKDApOyAvLyBkZWJ1Z1xuICogZ2FtZWpzLnNldExvZ0xldmVsKCdlcnJvcicpOyAvLyBlcXVhbCB0byBzZXRMb2dMZXZlbCgyKVxuICovXG5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24obG9nTGV2ZWwpIHtcbiAgIGlmICh0eXBlb2YgbG9nTGV2ZWwgPT09ICdzdHJpbmcnICYmIERFQlVHX0xFVkVMUy5pbmRleE9mKGxvZ0xldmVsKSkge1xuICAgICAgZGVidWdMZXZlbCA9IERFQlVHX0xFVkVMUy5pbmRleE9mKGxvZ0xldmVsKTtcbiAgIH0gZWxzZSBpZiAodHlwZW9mIGxvZ0xldmVsID09PSAnbnVtYmVyJykge1xuICAgICAgZGVidWdMZXZlbCA9IGxvZ0xldmVsO1xuICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsb2dMZXZlbCAnLCBsb2dMZXZlbCwgJyBNdXN0IGJlIG9uZSBvZjogJywgREVCVUdfTEVWRUxTKTtcbiAgIH1cbiAgIHJldHVybiBkZWJ1Z0xldmVsO1xufTtcblxuLyoqXG4gKiBMb2cgYSBtc2cgdG8gdGhlIGNvbnNvbGUgaWYgY29uc29sZSBpcyBlbmFibGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLC4uLiB0aGUgbXNnIHRvIGxvZ1xuICovXG52YXIgbG9nID0gZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcblxuICAgaWYgKGdhbWVqcy50aHJlYWQuaW5Xb3JrZXIgPT09IHRydWUpIHtcbiAgICAgIGdhbWVqcy50aHJlYWQuX2xvZ01lc3NhZ2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgLy8gSUVGSVggY2FuJ3QgY2FsbCBhcHBseSBvbiBjb25zb2xlXG4gICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMsIFswXSk7XG4gICBhcmdzLnVuc2hpZnQoRGF0ZS5ub3coKSk7XG4gICBpZiAod2luZG93LmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSwuLi4gdG8gbG9nXG4gKi9cbmV4cG9ydHMuZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgIGlmIChkZWJ1Z0xldmVsIDw9IERFQlVHX0xFVkVMUy5pbmRleE9mKCdkZWJ1ZycpKSB7XG4gICAgICBsb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLC4uLiB0byBsb2dcbiAqL1xuZXhwb3J0cy5pbmZvID0gZnVuY3Rpb24oKSB7XG4gICBpZiAoZGVidWdMZXZlbCA8PSBERUJVR19MRVZFTFMuaW5kZXhPZignaW5mbycpKSB7XG4gICAgICBsb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLC4uLiB0byBsb2dcbiAqL1xuZXhwb3J0cy53YXJuID0gZnVuY3Rpb24oKSB7XG4gICBpZiAoZGVidWdMZXZlbCA8PSBERUJVR19MRVZFTFMuaW5kZXhPZignd2FybicpKSB7XG4gICAgICBsb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLC4uLiB0byBsb2dcbiAqL1xuZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgaWYgKGRlYnVnTGV2ZWwgPD0gREVCVUdfTEVWRUxTLmluZGV4T2YoJ2Vycm9yJykpIHtcbiAgICAgIGxvZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdG8gbG9nXG4gKi9cbmV4cG9ydHMuZmF0YWwgPSBmdW5jdGlvbigpIHtcbiAgIGlmIChkZWJ1Z0xldmVsIDw9IERFQlVHX0xFVkVMUy5pbmRleE9mKCdmYXRhbCcpKSB7XG4gICAgICBsb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgIH1cbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVncmVlcyBhbmQgcmFkaWFucy5cbiAqXG4gKi9cblxuLyoqXG4gKlxuICogYWJzb2x1dGUgYW5nbGUgdG8gcmVsYXRpdmUgYW5nbGUsIGluIGRlZ3JlZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBhYnNvbHV0ZSBhbmdsZSBpbiBkZWdyZWVzXG4gKiBAcmV0dXJucyB7TnVtYmVyfSByZWxhdGl2ZSBhbmdsZSBpbiBkZWdyZWVzXG4gKi9cbmV4cG9ydHMubm9ybWFsaXNlRGVncmVlcz1mdW5jdGlvbihkZWdyZWVzKXtcbiAgICBkZWdyZWVzPWRlZ3JlZXMgJSAzNjA7XG4gICAgaWYoZGVncmVlczwwKSB7XG4gICAgICAgIGRlZ3JlZXMrPTM2MDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZ3JlZXM7XG59O1xuXG4vKipcbiAqXG4gKiBhYnNvbHV0ZSBhbmdsZSB0byByZWxhdGl2ZSBhbmdsZSwgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtOdW1iZXJ9IGFic29sdXRlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHJlbGF0aXZlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuZXhwb3J0cy5ub3JtYWxpc2VSYWRpYW5zPWZ1bmN0aW9uKHJhZGlhbnMpe1xuICAgIHJhZGlhbnM9cmFkaWFucyAlICgyKk1hdGguUEkpO1xuICAgIGlmKHJhZGlhbnM8MCkge1xuICAgICAgICByYWRpYW5zKz0oMipNYXRoLlBJKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbnM7XG59O1xuXG4vKipcbiAqXG4gKiBjb252ZXJ0IHJhZGlhbnMgdG8gZGVncmVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnNcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRlZ3JlZXNcbiAqL1xuZXhwb3J0cy5kZWdyZWVzPWZ1bmN0aW9uKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyooMTgwL01hdGguUEkpO1xufTtcblxuLyoqXG4gKlxuICogY29udmVydCBkZWdyZWVzIHRvIHJhZGlhbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWVzXG4gKiBAcmV0dXJucyB7TnVtYmVyfSByYWRpYW5zXG4gKi9cbmV4cG9ydHMucmFkaWFucz1mdW5jdGlvbihkZWdyZWVzKSB7XG4gICAgcmV0dXJuIGRlZ3JlZXMqKE1hdGguUEkvMTgwKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmluYXJ5IEhlYXAgaW1wbGVtZW50YXRpb24gZnJvbSBFbG9xdWVudCBKYXZhU2NyaXB0XG4gKlxuICogQHNlZSBodHRwOi8vZWxvcXVlbnRqYXZhc2NyaXB0Lm5ldC9hcHBlbmRpeDIuaHRtbFxuICovXG52YXIgQmluYXJ5SGVhcCA9IGV4cG9ydHMuQmluYXJ5SGVhcCA9IGZ1bmN0aW9uKHNjb3JlRnVuY3Rpb24pe1xuICAgLyoqXG4gICAgKiBAaWdub3JlXG4gICAgKi9cbiAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgLyoqXG4gICAgKiBAaWdub3JlXG4gICAgKi9cbiAgIHRoaXMuc2NvcmVGdW5jdGlvbiA9IHNjb3JlRnVuY3Rpb247XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGVsZW1lbnQgdG8gaGVhcC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gKi9cbkJpbmFyeUhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICB0aGlzLmNvbnRlbnQucHVzaChlbGVtZW50KTtcbiAgIHRoaXMuc2lua0Rvd24odGhpcy5jb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gZmlyc3QgZWxlbWVudCBmcm9tIGhlYXAuXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gZWxlbWVudFxuICovXG5CaW5hcnlIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgIC8vIFN0b3JlIHRoZSBmaXJzdCBlbGVtZW50IHNvIHdlIGNhbiByZXR1cm4gaXQgbGF0ZXIuXG4gICB2YXIgcmVzdWx0ID0gdGhpcy5jb250ZW50WzBdO1xuICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcbiAgIC8vIElmIHRoZXJlIGFyZSBhbnkgZWxlbWVudHMgbGVmdCwgcHV0IHRoZSBlbmQgZWxlbWVudCBhdCB0aGVcbiAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IGJ1YmJsZSB1cC5cbiAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5jb250ZW50WzBdID0gZW5kO1xuICAgICAgdGhpcy5idWJibGVVcCgwKTtcbiAgIH1cbiAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBoZWFwLlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBub2RlIG5vdCBmb3VuZFxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSB3YXMgcm91bmQgYW5kIHJlbW92ZWQgb3IgZmFscyBvdGhlcndpc2VcbiAqL1xuQmluYXJ5SGVhcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obm9kZSkge1xuICAgLy8gVG8gcmVtb3ZlIGEgdmFsdWUsIHdlIG11c3Qgc2VhcmNoIHRocm91Z2ggdGhlIGFycmF5IHRvIGZpbmRcbiAgIC8vIGl0LlxuICAgdmFyIGlzRm91bmQgPSB0aGlzLmNvbnRlbnQuc29tZShmdW5jdGlvbihjTm9kZSwgaWR4KSB7XG4gICAgICBpZiAoY05vZGUgPT0gbm9kZSkge1xuICAgICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgICAgIGlmIChpZHggIT0gdGhpcy5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50W2lkeF0gPSBlbmQ7XG4gICAgICAgICAgICBpZiAodGhpcy5zY29yZUZ1bmN0aW9uKGVuZCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgIHRoaXMuc2lua0Rvd24oaWR4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB0aGlzLmJ1YmJsZVVwKGlkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH0sIHRoaXMpO1xuICAgcmV0dXJuIGlzRm91bmQ7XG59O1xuXG4vKipcbiAqIE51bWJlciBvZiBlbGVtZW50cyBpbiBoZWFwLlxuICovXG5CaW5hcnlIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5CaW5hcnlIZWFwLnByb3RvdHlwZS5zaW5rRG93biA9IGZ1bmN0aW9uKGlkeCkge1xuICAgLy8gRmV0Y2ggdGhlIGVsZW1lbnQgdGhhdCBoYXMgdG8gYmUgc3Vua1xuICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNvbnRlbnRbaWR4XTtcbiAgIC8vIFdoZW4gYXQgMCwgYW4gZWxlbWVudCBjYW4gbm90IHNpbmsgYW55IGZ1cnRoZXIuXG4gICB3aGlsZSAoaWR4ID4gMCkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgdmFyIHBhcmVudElkeCA9IE1hdGguZmxvb3IoKGlkeCArIDEpIC8gMikgLSAxO1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuY29udGVudFtwYXJlbnRJZHhdO1xuICAgICAgLy8gU3dhcCB0aGUgZWxlbWVudHMgaWYgdGhlIHBhcmVudCBpcyBncmVhdGVyLlxuICAgICAgaWYgKHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KSA8IHRoaXMuc2NvcmVGdW5jdGlvbihwYXJlbnQpKSB7XG4gICAgICAgICB0aGlzLmNvbnRlbnRbcGFyZW50SWR4XSA9IGVsZW1lbnQ7XG4gICAgICAgICB0aGlzLmNvbnRlbnRbaWR4XSA9IHBhcmVudDtcbiAgICAgICAgIC8vIFVwZGF0ZSAnbicgdG8gY29udGludWUgYXQgdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgIGlkeCA9IHBhcmVudElkeDtcbiAgICAgIC8vIEZvdW5kIGEgcGFyZW50IHRoYXQgaXMgbGVzcywgbm8gbmVlZCB0byBzaW5rIGFueSBmdXJ0aGVyLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgfVxuICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbkJpbmFyeUhlYXAucHJvdG90eXBlLmJ1YmJsZVVwID0gZnVuY3Rpb24oaWR4KSB7XG4gICAvLyBMb29rIHVwIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgaXRzIHNjb3JlLlxuICAgdmFyIGxlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtpZHhdO1xuICAgdmFyIGVsZW1TY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KTtcblxuICAgd2hpbGUodHJ1ZSkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgaW5kaWNlcyBvZiB0aGUgY2hpbGQgZWxlbWVudHMuXG4gICAgICB2YXIgY2hpbGQySWR4ID0gKGlkeCArIDEpICogMjtcbiAgICAgIHZhciBjaGlsZDFJZHg9IGNoaWxkMklkeCAtIDE7XG4gICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCxcbiAgICAgIC8vIGlmIGFueS5cbiAgICAgIHZhciBzd2FwSWR4ID0gbnVsbDtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXG4gICAgICB2YXIgY2hpbGQxU2NvcmU7XG4gICAgICBpZiAoY2hpbGQxSWR4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cbiAgICAgICAgIHZhciBjaGlsZDEgPSB0aGlzLmNvbnRlbnRbY2hpbGQxSWR4XTtcbiAgICAgICAgIGNoaWxkMVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMSk7XG4gICAgICAgICAvLyBJZiB0aGUgc2NvcmUgaXMgbGVzcyB0aGFuIG91ciBlbGVtZW50J3MsIHdlIG5lZWQgdG8gc3dhcC5cbiAgICAgICAgIGlmIChjaGlsZDFTY29yZSA8IGVsZW1TY29yZSkge1xuICAgICAgICAgICAgc3dhcElkeCA9IGNoaWxkMUlkeDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIERvIHRoZSBzYW1lIGNoZWNrcyBmb3IgdGhlIG90aGVyIGNoaWxkLlxuICAgICAgaWYgKGNoaWxkMklkeCA8IGxlbmd0aCkge1xuICAgICAgICAgdmFyIGNoaWxkMiA9IHRoaXMuY29udGVudFtjaGlsZDJJZHhdO1xuICAgICAgICAgdmFyIGNoaWxkMlNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMik7XG4gICAgICAgICBpZiAoY2hpbGQyU2NvcmUgPCAoc3dhcElkeCA9PT0gbnVsbCA/IGVsZW1TY29yZSA6IGNoaWxkMVNjb3JlKSkge1xuICAgICAgICAgICAgc3dhcElkeCA9IGNoaWxkMklkeDtcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgbmVlZHMgdG8gYmUgbW92ZWQsIHN3YXAgaXQsIGFuZCBjb250aW51ZS5cbiAgICAgIGlmIChzd2FwSWR4ICE9PSBudWxsKSB7XG4gICAgICAgICB0aGlzLmNvbnRlbnRbaWR4XSA9IHRoaXMuY29udGVudFtzd2FwSWR4XTtcbiAgICAgICAgIHRoaXMuY29udGVudFtzd2FwSWR4XSA9IGVsZW1lbnQ7XG4gICAgICAgICBpZHggPSBzd2FwSWR4O1xuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBhcmUgZG9uZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgIH1cbiAgIHJldHVybjtcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWF0cml4IG1hbmlwdWxhdGlvbiwgdXNlZCBieSBHYW1lSnMgaXRzZWxmLiBZb3VcbiAqIHByb2JhYmx5IGRvIG5vdCBuZWVkIHRoaXMgdW5sZXNzIHlvdSBtYW5pcHVsYXRlIGEgQ29udGV4dCdzIHRyYW5zZm9ybWF0aW9uXG4gKiBtYXRyaXggeW91cnNlbGYuXG4gKi9cblxuLy8gY29ycmVjdCB3YXkgdG8gZG8gc2NhbGUsIHJvdGF0ZSwgdHJhbnNsYXRlXG4vLyAqICBnYW1lanMudXRpbHMubWF0cml4IHdpbGwgYmUgdXNlZCBpbiBnYW1lanMudHJhbnNmb3JtcywgbW9kaWZpbmcgdGhlIHN1cmZhY2VzLm1hdHJpeFxuLy8gKiB0aGlzIG1hdHJpeCBtdXN0IGJlIGFwcGxpZWQgdG8gdGhlIGNvbnRleHQgaW4gU3VyZmFjZS5kcmF3KClcblxuLyoqXG4gKiBAcmV0dXJucyB7QXJyYXl9IFsxLCAwLCAwLCAxLCAwLCAwXVxuICovXG52YXIgaWRlbnRpeSA9IGV4cG9ydHMuaWRlbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeFxuICogQHJldHVybnMge0FycmF5fSBtYXRyaXggc3VtXG4gKi9cbnZhciBhZGQgPSBleHBvcnRzLmFkZCA9IGZ1bmN0aW9uKG0xLCBtMikge1xuICAgcmV0dXJuIFtcbiAgICAgIG0xWzBdICsgbTJbMF0sXG4gICAgICBtMVsxXSArIG0yWzFdLFxuICAgICAgbTFbMl0gKyBtMlsyXSxcbiAgICAgIG0xWzNdICsgbTJbM10sXG4gICAgICBtMVs0XSArIG0yWzRdLFxuICAgICAgbTFbNV0gKyBtMls1XSxcbiAgICAgIG0xWzZdICsgbTJbNl1cbiAgIF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBBXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggQlxuICogQHJldHVybnMge0FycmF5fSBtYXRyaXggcHJvZHVjdFxuICovXG52YXIgbXVsdGlwbHkgPSBleHBvcnRzLm11bHRpcGx5ID0gZnVuY3Rpb24obTEsIG0yKSB7XG4gICByZXR1cm4gW1xuICAgICAgbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sXG4gICAgICBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXSxcbiAgICAgIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLFxuICAgICAgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sXG4gICAgICBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdLFxuICAgICAgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XVxuICAgXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gZHhcbiAqIEBwYXJhbSB7TnVtYmVyfSBkeVxuICogQHJldHVybnMge0FycmF5fSB0cmFuc2xhdGVkIG1hdHJpeFxuICovXG52YXIgdHJhbnNsYXRlID0gZXhwb3J0cy50cmFuc2xhdGUgPSBmdW5jdGlvbihtMSwgZHgsIGR5KSB7XG4gICByZXR1cm4gbXVsdGlwbHkobTEsIFsxLCAwLCAwLCAxLCBkeCwgZHldKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge0FycmF5fSByb3RhdGVkIG1hdHJpeFxuICovXG52YXIgcm90YXRlID0gZXhwb3J0cy5yb3RhdGUgPSBmdW5jdGlvbihtMSwgYW5nbGUpIHtcbiAgIC8vIHJhZGlhbnNcbiAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgcmV0dXJuIG11bHRpcGx5KG0xLCBbY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMF0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqL1xudmFyIHJvdGF0aW9uID0gZXhwb3J0cy5yb3RhdGlvbiA9IGZ1bmN0aW9uKG0xKSB7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMihtMVsxXSwgbTFbMF0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXl9IHZlY3RvciBbYSwgYl1cbiAqIEByZXR1cm5zIHtBcnJheX0gc2NhbGVkIG1hdHJpeFxuICovXG52YXIgc2NhbGUgPSBleHBvcnRzLnNjYWxlID0gZnVuY3Rpb24obTEsIHN2ZWMpIHtcbiAgIHZhciBzeCA9IHN2ZWNbMF07XG4gICB2YXIgc3kgPSBzdmVjWzFdO1xuICAgcmV0dXJuIG11bHRpcGx5KG0xLCBbc3gsIDAsIDAsIHN5LCAwLCAwXSk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBBIG5vaXNlIGdlbmVyYXRvciBjb21wYXJhYmxlIHRvIFBlcmxpbiBub2lzZSwgd2hpY2ggaXMgdXNlZnVsXG4gKiBmb3IgZ2VuZXJhdGluZyBwcm9jZWR1cmFsIGNvbnRlbnQuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBwcm92aWRlcyAyRCBhbmQgM0Qgbm9pc2U6XG4gKlxuICogICAgdmFyIHNpbXBsZXggPSBuZXcgU2ltcGxleCgpO1xuICogICAgc2ltcGxleC5nZXQoMiwgNCk7XG4gKiAgICBzaW1wbGUuZ2V0M2QoMSwgMiwgNCk7XG4gKlxuICogWW91IGNhbiBvcHRpb25hbGx5XG4gKiBwYXNzIGEgc2VlZGFibGUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIGl0cyBjb25zdHJ1Y3Rvci4gVGhpc1xuICogZ2VuZXJhdG9yIG9iamVjdCBpcyBhc3N1bWVkIHRvIGhhdmUgYSBgcmFuZG9tKClgIG1ldGhvZDsgYE1hdGhgIGlzIHVzZWRcbiAqIHBlciBkZWZhdWx0OlxuICpcbiAqICAgICB2YXIgQWxlYSA9IHJlcXVpcmUoJ2dhbWVqcy9tYXRoL3JhbmRvbScpLkFsZWE7XG4gKiAgICAgdmFyIHNpbXBsZXggPSBuZXcgU2ltcGxleChuZXcgQWxlYSgpKTtcbiAqXG4gKiBBbHNvIHNlZSBgZ2FtZWpzL21hdGgvcmFuZG9tYCBmb3IgYSBzZWVkYWJsZSBwc2V1ZG8gcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAqXG4gKiBAc2VlIGdhbWVqcy91dGlscy9wcm5nXG4gKi9cblxuLy8gUG9ydGVkIHRvIEpTIGJ5IGJ5IHp6ODUgPGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1PiBmcm9tIFN0ZWZhblxuLy8gR3VzdGF2c29uJ3MgamF2YSBpbXBsZW1lbnRhdGlvblxuLy8gPGh0dHA6Ly9zdGFmZnd3dy5pdG4ubGl1LnNlL35zdGVndS9zaW1wbGV4bm9pc2Uvc2ltcGxleG5vaXNlLnBkZj5cbi8vIFJlYWQgU3RlZmFuJ3MgZXhjZWxsZW50IHBhcGVyIGZvciBkZXRhaWxzIG9uIGhvdyB0aGlzIGNvZGUgd29ya3MuXG4vL1xuLy8gU2VhbiBNY0N1bGxvdWdoIGJhbmtzZWFuQGdtYWlsLmNvbVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSByYW5kb21OdW1iZXJHZW5lcmF0b3IgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZTsgbW9zdCBwcm92aWRlIGByYW5kb20oKWAgbWV0aG9kXG4gKiBAdXNhZ2VcbiAqICB2YXIgc2ltcGxleCA9IG5ldyBnYW1lanMubm9pc2UuU2ltcGxleCgpO1xuICogIHNpbXBsZXguZ2V0KHgsIHkpO1xuICogIC8vIG9yIGZvciAzZCBub2lzZVxuICogIHNpbXBsZS5nZXQoeCwgeSwgeSk7XG4gKi9cblxudmFyIFNpbXBsZXggPSBleHBvcnRzLlNpbXBsZXggPSBmdW5jdGlvbihyKSB7XG4gIGlmIChyID09PSB1bmRlZmluZWQpIHtcbiAgICByID0gTWF0aDtcbiAgfVxuICAvKiogQGlnbm9yZSAqL1xuICB0aGlzLmdyYWQzID0gW1sxLDEsMF0sWy0xLDEsMF0sWzEsLTEsMF0sWy0xLC0xLDBdLFxuICAgICAgICAgICAgICAgWzEsMCwxXSxbLTEsMCwxXSxbMSwwLC0xXSxbLTEsMCwtMV0sXG4gICAgICAgICAgICAgICBbMCwxLDFdLFswLC0xLDFdLFswLDEsLTFdLFswLC0xLC0xXV07XG4gIC8qKiBAaWdub3JlICovXG4gIHRoaXMucCA9IFtdO1xuICB2YXIgaTtcbiAgZm9yIChpPTA7IGk8MjU2OyBpKyspIHtcbiAgIHRoaXMucFtpXSA9IE1hdGguZmxvb3Ioci5yYW5kb20oKSoyNTYpO1xuICB9XG4gIC8vIFRvIHJlbW92ZSB0aGUgbmVlZCBmb3IgaW5kZXggd3JhcHBpbmcsIGRvdWJsZSB0aGUgcGVybXV0YXRpb24gdGFibGUgbGVuZ3RoXG4gIC8qKiBAaWdub3JlICovXG4gIHRoaXMucGVybSA9IFtdO1xuICBmb3IoaT0wOyBpPDUxMjsgaSsrKSB7XG4gICAgdGhpcy5wZXJtW2ldPXRoaXMucFtpICYgMjU1XTtcbiAgfVxuXG4gIC8vIEEgbG9va3VwIHRhYmxlIHRvIHRyYXZlcnNlIHRoZSBzaW1wbGV4IGFyb3VuZCBhIGdpdmVuIHBvaW50IGluIDRELlxuICAvLyBEZXRhaWxzIGNhbiBiZSBmb3VuZCB3aGVyZSB0aGlzIHRhYmxlIGlzIHVzZWQsIGluIHRoZSA0RCBub2lzZSBtZXRob2QuXG4gIC8qKiBAaWdub3JlICovXG4gIHRoaXMuc2ltcGxleCA9IFtcbiAgICBbMCwxLDIsM10sWzAsMSwzLDJdLFswLDAsMCwwXSxbMCwyLDMsMV0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzEsMiwzLDBdLFxuICAgIFswLDIsMSwzXSxbMCwwLDAsMF0sWzAsMywxLDJdLFswLDMsMiwxXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMSwzLDIsMF0sXG4gICAgWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxcbiAgICBbMSwyLDAsM10sWzAsMCwwLDBdLFsxLDMsMCwyXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMiwzLDAsMV0sWzIsMywxLDBdLFxuICAgIFsxLDAsMiwzXSxbMSwwLDMsMl0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzIsMCwzLDFdLFswLDAsMCwwXSxbMiwxLDMsMF0sXG4gICAgWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxcbiAgICBbMiwwLDEsM10sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzMsMCwxLDJdLFszLDAsMiwxXSxbMCwwLDAsMF0sWzMsMSwyLDBdLFxuICAgIFsyLDEsMCwzXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMywxLDAsMl0sWzAsMCwwLDBdLFszLDIsMCwxXSxbMywyLDEsMF1dO1xufTtcblxuLyoqIEBpZ25vcmUgKi9cblNpbXBsZXgucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGcsIHgsIHkpIHtcbiAgIHJldHVybiBnWzBdKnggKyBnWzFdKnk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybnMge051bWJlcn0gbm9pc2UgZm9yIGdpdmVuIHBvc2l0aW9uLCBpbiByYW5nZSBbLTEsIDFdXG4gKi9cblNpbXBsZXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHhpbiwgeWluKSB7XG4gIHZhciBuMCwgbjEsIG4yOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcbiAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpblxuICB2YXIgRjIgPSAwLjUqKE1hdGguc3FydCgzLjApLTEuMCk7XG4gIHZhciBzID0gKHhpbit5aW4pKkYyOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG4gIHZhciBpID0gTWF0aC5mbG9vcih4aW4rcyk7XG4gIHZhciBqID0gTWF0aC5mbG9vcih5aW4rcyk7XG4gIHZhciBHMiA9ICgzLjAtTWF0aC5zcXJ0KDMuMCkpLzYuMDtcbiAgdmFyIHQgPSAoaStqKSpHMjtcbiAgdmFyIFgwID0gaS10OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSkgc3BhY2VcbiAgdmFyIFkwID0gai10O1xuICB2YXIgeDAgPSB4aW4tWDA7IC8vIFRoZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gIHZhciB5MCA9IHlpbi1ZMDtcbiAgLy8gRm9yIHRoZSAyRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhbiBlcXVpbGF0ZXJhbCB0cmlhbmdsZS5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuICB2YXIgaTEsIGoxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgKG1pZGRsZSkgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaikgY29vcmRzXG4gIGlmKHgwPnkwKSB7aTE9MTsgajE9MDt9IC8vIGxvd2VyIHRyaWFuZ2xlLCBYWSBvcmRlcjogKDAsMCktPigxLDApLT4oMSwxKVxuICBlbHNlIHtpMT0wOyBqMT0xO30gLy8gdXBwZXIgdHJpYW5nbGUsIFlYIG9yZGVyOiAoMCwwKS0+KDAsMSktPigxLDEpXG4gIC8vIEEgc3RlcCBvZiAoMSwwKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYykgaW4gKHgseSksIGFuZFxuICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuICAvLyBjID0gKDMtc3FydCgzKSkvNlxuICB2YXIgeDEgPSB4MCAtIGkxICsgRzI7IC8vIE9mZnNldHMgZm9yIG1pZGRsZSBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMjtcbiAgdmFyIHgyID0geDAgLSAxLjAgKyAyLjAgKiBHMjsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXG4gIHZhciB5MiA9IHkwIC0gMS4wICsgMi4wICogRzI7XG4gIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXG4gIHZhciBpaSA9IGkgJiAyNTU7XG4gIHZhciBqaiA9IGogJiAyNTU7XG4gIHZhciBnaTAgPSB0aGlzLnBlcm1baWkrdGhpcy5wZXJtW2pqXV0gJSAxMjtcbiAgdmFyIGdpMSA9IHRoaXMucGVybVtpaStpMSt0aGlzLnBlcm1bamorajFdXSAlIDEyO1xuICB2YXIgZ2kyID0gdGhpcy5wZXJtW2lpKzErdGhpcy5wZXJtW2pqKzFdXSAlIDEyO1xuICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG4gIHZhciB0MCA9IDAuNSAtIHgwKngwLXkwKnkwO1xuICBpZih0MDwwKSB7XG4gICAgbjAgPSAwLjA7XG4gIH0gZWxzZSB7XG4gICAgdDAgKj0gdDA7XG4gICAgbjAgPSB0MCAqIHQwICogdGhpcy5kb3QodGhpcy5ncmFkM1tnaTBdLCB4MCwgeTApOyAvLyAoeCx5KSBvZiBncmFkMyB1c2VkIGZvciAyRCBncmFkaWVudFxuICB9XG4gIHZhciB0MSA9IDAuNSAtIHgxKngxLXkxKnkxO1xuICBpZih0MTwwKSB7XG4gICAgbjEgPSAwLjA7XG4gIH0gZWxzZSB7XG4gICAgdDEgKj0gdDE7XG4gICAgbjEgPSB0MSAqIHQxICogdGhpcy5kb3QodGhpcy5ncmFkM1tnaTFdLCB4MSwgeTEpO1xuICB9XG4gIHZhciB0MiA9IDAuNSAtIHgyKngyLXkyKnkyO1xuICBpZih0MjwwKSB7XG4gICAgbjIgPSAwLjA7XG4gIH0gZWxzZSB7XG4gICAgdDIgKj0gdDI7XG4gICAgbjIgPSB0MiAqIHQyICogdGhpcy5kb3QodGhpcy5ncmFkM1tnaTJdLCB4MiwgeTIpO1xuICB9XG4gIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLDFdLlxuICByZXR1cm4gNzAuMCAqIChuMCArIG4xICsgbjIpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IG5vaXNlIGZvciBnaXZlbiBwb3NpdGlvbiwgaW4gcmFuZ2UgWy0xLCAxXVxuICovXG5TaW1wbGV4LnByb3RvdHlwZS5nZXQzZCA9IGZ1bmN0aW9uKHhpbiwgeWluLCB6aW4pIHtcbiAgdmFyIG4wLCBuMSwgbjIsIG4zOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG4gIHZhciBGMyA9IDEuMC8zLjA7XG4gIHZhciBzID0gKHhpbit5aW4remluKSpGMzsgLy8gVmVyeSBuaWNlIGFuZCBzaW1wbGUgc2tldyBmYWN0b3IgZm9yIDNEXG4gIHZhciBpID0gTWF0aC5mbG9vcih4aW4rcyk7XG4gIHZhciBqID0gTWF0aC5mbG9vcih5aW4rcyk7XG4gIHZhciBrID0gTWF0aC5mbG9vcih6aW4rcyk7XG4gIHZhciBHMyA9IDEuMC82LjA7IC8vIFZlcnkgbmljZSBhbmQgc2ltcGxlIHVuc2tldyBmYWN0b3IsIHRvb1xuICB2YXIgdCA9IChpK2oraykqRzM7XG4gIHZhciBYMCA9IGktdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseikgc3BhY2VcbiAgdmFyIFkwID0gai10O1xuICB2YXIgWjAgPSBrLXQ7XG4gIHZhciB4MCA9IHhpbi1YMDsgLy8gVGhlIHgseSx6IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxuICB2YXIgeTAgPSB5aW4tWTA7XG4gIHZhciB6MCA9IHppbi1aMDtcbiAgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxuICB2YXIgaTEsIGoxLCBrMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXG4gIHZhciBpMiwgajIsIGsyOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICBpZih4MD49eTApIHtcbiAgICBpZih5MD49ejApXG4gICAgICB7IGkxPTE7IGoxPTA7IGsxPTA7IGkyPTE7IGoyPTE7IGsyPTA7IH0gLy8gWCBZIFogb3JkZXJcbiAgICAgIGVsc2UgaWYoeDA+PXowKSB7IGkxPTE7IGoxPTA7IGsxPTA7IGkyPTE7IGoyPTA7IGsyPTE7IH0gLy8gWCBaIFkgb3JkZXJcbiAgICAgIGVsc2UgeyBpMT0wOyBqMT0wOyBrMT0xOyBpMj0xOyBqMj0wOyBrMj0xOyB9IC8vIFogWCBZIG9yZGVyXG4gICAgfVxuICBlbHNlIHsgLy8geDA8eTBcbiAgICBpZih5MDx6MCkgeyBpMT0wOyBqMT0wOyBrMT0xOyBpMj0wOyBqMj0xOyBrMj0xOyB9IC8vIFogWSBYIG9yZGVyXG4gICAgZWxzZSBpZih4MDx6MCkgeyBpMT0wOyBqMT0xOyBrMT0wOyBpMj0wOyBqMj0xOyBrMj0xOyB9IC8vIFkgWiBYIG9yZGVyXG4gICAgZWxzZSB7IGkxPTA7IGoxPTE7IGsxPTA7IGkyPTE7IGoyPTE7IGsyPTA7IH0gLy8gWSBYIFogb3JkZXJcbiAgfVxuICAvLyBBIHN0ZXAgb2YgKDEsMCwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jLC1jKSBpbiAoeCx5LHopLFxuICAvLyBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmRcbiAgLy8gYSBzdGVwIG9mICgwLDAsMSkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKC1jLC1jLDEtYykgaW4gKHgseSx6KSwgd2hlcmVcbiAgLy8gYyA9IDEvNi5cbiAgdmFyIHgxID0geDAgLSBpMSArIEczOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gIHZhciB5MSA9IHkwIC0gajEgKyBHMztcbiAgdmFyIHoxID0gejAgLSBrMSArIEczO1xuICB2YXIgeDIgPSB4MCAtIGkyICsgMi4wKkczOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgdmFyIHkyID0geTAgLSBqMiArIDIuMCpHMztcbiAgdmFyIHoyID0gejAgLSBrMiArIDIuMCpHMztcbiAgdmFyIHgzID0geDAgLSAxLjAgKyAzLjAqRzM7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gIHZhciB5MyA9IHkwIC0gMS4wICsgMy4wKkczO1xuICB2YXIgejMgPSB6MCAtIDEuMCArIDMuMCpHMztcbiAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xuICB2YXIgaWkgPSBpICYgMjU1O1xuICB2YXIgamogPSBqICYgMjU1O1xuICB2YXIga2sgPSBrICYgMjU1O1xuICB2YXIgZ2kwID0gdGhpcy5wZXJtW2lpK3RoaXMucGVybVtqait0aGlzLnBlcm1ba2tdXV0gJSAxMjtcbiAgdmFyIGdpMSA9IHRoaXMucGVybVtpaStpMSt0aGlzLnBlcm1bamorajErdGhpcy5wZXJtW2trK2sxXV1dICUgMTI7XG4gIHZhciBnaTIgPSB0aGlzLnBlcm1baWkraTIrdGhpcy5wZXJtW2pqK2oyK3RoaXMucGVybVtraytrMl1dXSAlIDEyO1xuICB2YXIgZ2kzID0gdGhpcy5wZXJtW2lpKzErdGhpcy5wZXJtW2pqKzErdGhpcy5wZXJtW2trKzFdXV0gJSAxMjtcbiAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZm91ciBjb3JuZXJzXG4gIHZhciB0MCA9IDAuNiAtIHgwKngwIC0geTAqeTAgLSB6MCp6MDtcbiAgaWYodDA8MCkge1xuICAgIG4wID0gMC4wO1xuICB9IGVsc2Uge1xuICAgIHQwICo9IHQwO1xuICAgIG4wID0gdDAgKiB0MCAqIHRoaXMuZG90KHRoaXMuZ3JhZDNbZ2kwXSwgeDAsIHkwLCB6MCk7XG4gIH1cbiAgdmFyIHQxID0gMC42IC0geDEqeDEgLSB5MSp5MSAtIHoxKnoxO1xuICBpZih0MTwwKSB7XG4gICAgbjEgPSAwLjA7XG4gIH0gZWxzZSB7XG4gICAgdDEgKj0gdDE7XG4gICAgbjEgPSB0MSAqIHQxICogdGhpcy5kb3QodGhpcy5ncmFkM1tnaTFdLCB4MSwgeTEsIHoxKTtcbiAgfVxuICB2YXIgdDIgPSAwLjYgLSB4Mip4MiAtIHkyKnkyIC0gejIqejI7XG4gIGlmKHQyPDApIHtcbiAgICBuMiA9IDAuMDtcbiAgfSBlbHNlIHtcbiAgICB0MiAqPSB0MjtcbiAgICBuMiA9IHQyICogdDIgKiB0aGlzLmRvdCh0aGlzLmdyYWQzW2dpMl0sIHgyLCB5MiwgejIpO1xuICB9XG4gIHZhciB0MyA9IDAuNiAtIHgzKngzIC0geTMqeTMgLSB6Myp6MztcbiAgaWYodDM8MCkge1xuICAgIG4zID0gMC4wO1xuICB9IGVsc2Uge1xuICAgIHQzICo9IHQzO1xuICAgIG4zID0gdDMgKiB0MyAqIHRoaXMuZG90KHRoaXMuZ3JhZDNbZ2kzXSwgeDMsIHkzLCB6Myk7XG4gIH1cbiAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxuICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byBzdGF5IGp1c3QgaW5zaWRlIFstMSwxXVxuICByZXR1cm4gMzIuMCoobjAgKyBuMSArIG4yICsgbjMpO1xufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBBIHNlZWRhYmxlIHJhbmRvbS1udW1iZXIgZ2VuZXJhdG9yLlxuICpcbiAqIEEgZ2VuZXJhdG9yIGlzIGluaXRpYWxpemVkIGJ5IEdhbWVKcyBhbmQgY2FuIGJlIHVzZWQgd2l0aCB0aGVcbiAqIHN0YXRpYyBmdW5jdGlvbnMgb2YgdGhpcyBtb2R1bGU6XG4gKlxuICogICAgZ2FtZWpzLnJhbmRvbS5jaG9vc2UoWzEsMiw0XSk7XG4gKiAgICAvLyBpbnRlZ2V0IGJldHdlZW4gYW5kIGluY2x1ZGluZyAyIGFuZCA1XG4gKiAgICBnYW1lanMucmFuZG9tLmludGVnZXIoMiwgNSk7XG4gKlxuICogWW91IGNhbiByZS1pbml0aWFsaXplIHRoaXMgZ2VuZXJhdG9yIHdpdGggYSBkaWZmZXJlbnQgc2VlZCBieVxuICogY2FsbGluZyBgZ2FtZWpzLnV0aWxzLnBybmcuaW5pdChzZWVkKWAgYWZ0ZXIgd2hpY2ggdGhlIHN0YXRpY1xuICogZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdXNlIHRoZSBuZXcgc2VlZC5cbiAqXG4gKiBAdXNhZ2VcbiAqICB2YXIgcHJuZyA9IHJlcXVpcmUoJ2dhbWVqcy9tYXRoL3JhbmRvbScpO1xuICogIHBybmcucmFuZG9tKCk7IC8vIDAuNjc2NTg3MTY3MTk1OTc1OFxuICogIHBybmcuaW50ZWdlcigyLCAxMCk7IC8vIDVcbiAqICBwcm5nLmNob29zZShbMSwyLDMsNCw1XSk7IC8vIDNcbiAqL1xuLy8gRnJvbSBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcbi8vIEFQSSBtb2RpZmllZCBieSBTaW1vbiBPYmVyaGFtbWVyIDxzaW1vbkBuZWthcHV6ZXIuYXQ+LCAyMDEyXG4vLyBkaXNjdXNzaW9uIG9mIHRoZSB1c2VkIGFsZ29yaXRobXMgPGh0dHA6Ly9iYWFnb2Uub3JnL2VuL3cvaW5kZXgucGhwL0JldHRlcl9yYW5kb21fbnVtYmVyc19mb3JfamF2YXNjcmlwdD5cblxuXG4vKiogQGlnbm9yZSAqKi9cbnZhciBNYXNoID0gZnVuY3Rpb24gTWFzaCgpIHtcbiAgdmFyIG4gPSAweGVmYzgyNDlkO1xuICB0aGlzLmhhc2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBoICo9IG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgfVxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9O1xuXG4gIHRoaXMudmVyc2lvbiA9ICdNYXNoIDAuOSc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBIHNlZWRhYmxlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gc2VlZCB0aGUgc2VlZCBmb3IgZ2VuZXJhdGluZyB0aGUgbnVtYmVyc1xuICpcbiAqIEB1c2FnZVxuICogIHZhciBwcm5nID0gcmVxdWlyZSgnZ2FtZWpzL21hdGgvcmFuZG9tJyk7XG4gKiAgdmFyIHNlZWQgPSAnZ2FtZWpzJztcbiAqICB2YXIgYWxlYSA9IG5ldyBwcm5nLkFsZWEoc2VlZCk7XG4gKiAgYWxlYS5yYW5kb20oKTsgLy8gMC42NzY1ODcxNjcxOTU5NzU4XG4gKiAgYWxlYS5yYW5kb20oKTsgLy8gMC4xNTg4MTU0NjAyNzk1ODM5M1xuICpcbiAqICAvLyBnZW5lcmF0b3Igd2l0aCB0aGUgc2FtZSBzZWVkIHdpbGwgZ2VuZXJhdGUgdGhlIHNhbWUgc2VxdWVuY2VcbiAqICAvLyBvZiBudW1iZXJzOlxuICogIHZhciBhbGVhVHdvID0gbmV3IHBybmcuQWxlYShzZWVkKTtcbiAqICBhbGVhVHdvLnJhbmRvbSgpOyAvLyAwLjY3NjU4NzE2NzE5NTk3NThcbiAqICBhbGVhVHdvLnJhbmRvbSgpOyAvLyAwLjE1ODgxNTQ2MDI3OTU4MzkzXG4gKi9cbnZhciBBbGVhID0gZXhwb3J0cy5BbGVhID0gZnVuY3Rpb24gQWxlYSgpIHtcbiAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgIHZhciBzMCA9IDA7XG4gICB2YXIgczEgPSAwO1xuICAgdmFyIHMyID0gMDtcbiAgIHZhciBjID0gMTtcbiAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCB8fCAhYXJnc1swXSkge1xuICAgICBhcmdzID0gW0RhdGUubm93KCldO1xuICAgfVxuICAgdmFyIG1hc2ggPSBuZXcgTWFzaCgpO1xuICAgczAgPSBtYXNoLmhhc2goJyAnKTtcbiAgIHMxID0gbWFzaC5oYXNoKCcgJyk7XG4gICBzMiA9IG1hc2guaGFzaCgnICcpO1xuXG4gICB2YXIgaTtcbiAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgIHMwIC09IG1hc2guaGFzaChhcmdzW2ldKTtcbiAgICAgaWYgKHMwIDwgMCkge1xuICAgICAgIHMwICs9IDE7XG4gICAgIH1cbiAgICAgczEgLT0gbWFzaC5oYXNoKGFyZ3NbaV0pO1xuICAgICBpZiAoczEgPCAwKSB7XG4gICAgICAgczEgKz0gMTtcbiAgICAgfVxuICAgICBzMiAtPSBtYXNoLmhhc2goYXJnc1tpXSk7XG4gICAgIGlmIChzMiA8IDApIHtcbiAgICAgICBzMiArPSAxO1xuICAgICB9XG4gICB9XG4gICBtYXNoID0gbnVsbDtcblxuICAgLyoqXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbmV4dCByYW5kb20gbnVtYmVyIGFzIGRldGVybWluZWQgYnkgdGhlIHNlZWRcbiAgICAqL1xuICAgdGhpcy5yYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICAgdmFyIHQgPSAyMDkxNjM5ICogczAgKyBjICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICAgczAgPSBzMTtcbiAgICAgczEgPSBzMjtcbiAgICAgczIgPSB0IC0gKGMgPSB0IHwgMCk7XG4gICAgIHJldHVybiBzMjtcbiAgIH07XG4gICB0aGlzLmludGVnZXIgPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICByZXR1cm4gbWluICsgcGFyc2VJbnQodGhpcy5yYW5kb20oKSAqIChtYXgtbWluKzEpLCAxMCk7XG4gICB9O1xuICAgdGhpcy52ZWN0b3IgPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmludGVnZXIobWluWzBdLCBtYXhbMF0pLCB0aGlzLmludGVnZXIobWluWzFdLCBtYXhbMV0pXTtcbiAgIH07XG4gICB0aGlzLmNob29zZSA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICByZXR1cm4gaXRlbXNbdGhpcy5pbnRlZ2VyKDAsIGl0ZW1zLmxlbmd0aC0xKV07XG4gICB9O1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBhbGVhIGluc3RhbmNlIHBlciBnYW1lanMgaW5zdGFuY2VcbnZhciBhbGVhID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0gbWluXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gKi9cbnZhciBpbnRlZ2VyID0gZXhwb3J0cy5pbnRlZ2VyID0gZnVuY3Rpb24obWluLCBtYXgpe1xuICAgIHJldHVybiBhbGVhLmludGVnZXIobWluLCBtYXgpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBtaW5WZWN0b3IgMiBpbnRlZ2VycywgdGhlIG1pbmltdW0gdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBtYXhWZWN0b3IgMiBpbnRlZ2VycywgdGhlIG1heGltdW0gdmVjdG9yXG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgcmFuZG9tIHZlY3RvciBbbWluWzBdPD14PD1tYXhbMF0sIG1pblsxXTw9eTw9bWF4WzFdXVxuICovXG5leHBvcnRzLnZlY3RvciA9IGZ1bmN0aW9uKG1pbiwgbWF4KXtcbiAgICByZXR1cm4gYWxlYS52ZWN0b3IobWluLCBtYXgpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICogQHJldHVybnMge09iamVjdH0gcmFuZG9tIGl0ZW0gZnJvbSBpdGVtcyBsaXN0XG4gKi9cbmV4cG9ydHMuY2hvb3NlID0gZnVuY3Rpb24oaXRlbXMpe1xuICAgIHJldHVybiBhbGVhLmNob29zZShpdGVtcyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IG5leHQgcmFuZG9tIGZsb2F0IGJldHdlZW4gMCBhbmQgMVxuICovXG5leHBvcnRzLnJhbmRvbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYWxlYS5yYW5kb20oKTtcbn07XG5cbi8qKlxuICogUmUtaW5pdGlhbGl6ZSB0aGUgcGVyIGluc3RhbmNlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHVzZWRcbiAqIGluIHRoZSBzdGF0aWMgZnVuY3Rpb25zIG9uIHRoaXMgbW9kdWxlIChlLmcuIHZlY3RvcigpKVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBzZWVkXG4gKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgYWxlYSA9IG5ldyBBbGVhKHNlZWQpO1xufTsiLCIvKipcbiAqIFZlY3RvciBvcGVyYXRpb25zLlxuXG4gKi9cbnZhciBhbmdsZXMgPSByZXF1aXJlKCcuL2FuZ2xlcycpO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IG9yaWdpbiBwb2ludCBbYjAsIGIxXVxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0IHBvaW50IFtiMCwgYjFdXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqL1xuZXhwb3J0cy5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgIHJldHVybiBsZW4oc3VidHJhY3QoYSwgYikpO1xufTtcblxuLyoqXG4gKiBzdWJ0cmFjdHMgdmVjdG9ycyBbYTAsIGExXSAtIFthMCwgYTFdXG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge0FycmF5fSBiXG4gKiBAcmV0dXJucyB7QXJyYXl9IHZlY3RvclxuICovXG52YXIgc3VidHJhY3QgPSBleHBvcnRzLnN1YnRyYWN0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgcmV0dXJuIFthWzBdIC0gYlswXSwgYVsxXSAtIGJbMV1dO1xufTtcblxuLyoqXG4gKiBhZGRzIHZlY3RvcnMgW2EwLCBhMV0gLSBbYTAsIGExXVxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdmVjdG9yXG4gKiBAcmV0dXJucyB7QXJyYXl9IHZlY3RvclxuICovXG52YXIgYWRkID0gZXhwb3J0cy5hZGQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICByZXR1cm4gW2FbMF0gKyBiWzBdLCBhWzFdICsgYlsxXV07XG59O1xuXG4vKipcbiAqIG11bHRpcGx5IHZlY3RvciB3aXRoIHNjYWxhciBvciBvdGhlciB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IHZlY3RvciBbdjAsIHYxXVxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IHZlY3RvciBvciBudW1iZXJcbiAqIEByZXR1cm5zIHtOdW1iZXJ8QXJyYXl9IHJlc3VsdFxuICovXG52YXIgbXVsdGlwbHkgPSBleHBvcnRzLm11bHRpcGx5ID0gZnVuY3Rpb24oYSwgcykge1xuICAgaWYgKHR5cGVvZiBzID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFthWzBdICogcywgYVsxXSAqIHNdO1xuICAgfVxuXG4gICByZXR1cm4gW2FbMF0gKiBzWzBdLCBhWzFdICogc1sxXV07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gc1xuICovXG5leHBvcnRzLmRpdmlkZSA9IGZ1bmN0aW9uKGEsIHMpIHtcbiAgIGlmICh0eXBlb2YgcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBbYVswXSAvIHMsIGFbMV0gLyBzXTtcbiAgIH1cbiAgIHRocm93IG5ldyBFcnJvcignb25seSBkaXZpZGUgYnkgc2NhbGFyIHN1cHBvcnRlZCcpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZWN0b3IgW3YwLCB2MV1cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiB2ZWN0b3JcbiAqL1xudmFyIGxlbiA9IGV4cG9ydHMubGVuID0gZnVuY3Rpb24odikge1xuICAgcmV0dXJuIE1hdGguc3FydCh2WzBdKnZbMF0gKyB2WzFdKnZbMV0pO1xufTtcblxuLyoqXG4gKlxuICogbm9ybWFsaXplIHZlY3RvciB0byB1bml0IHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gdmVjdG9yIFt2MCwgdjFdXG4gKiBAcmV0dXJucyB7QXJyYXl9IHVuaXQgdmVjdG9yIFt2MCwgdjFdXG4gKi9cbnZhciB1bml0ID0gZXhwb3J0cy51bml0ID0gZnVuY3Rpb24odikge1xuICAgdmFyIGwgPSBsZW4odik7XG4gICBpZihsKSB7XG4gICAgICByZXR1cm4gW3ZbMF0gLyBsLCB2WzFdIC8gbF07XG4gICB9XG4gICByZXR1cm4gWzAsIDBdO1xufTtcblxuLyoqXG4gKlxuICogcm90YXRlIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gdmVjdG9yIFt2MCwgdjFdXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdG8gcm90YXRlIHZlY3RvciBieSwgcmFkaWFucy4gY2FuIGJlIG5lZ2F0aXZlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHJvdGF0ZWQgdmVjdG9yIFt2MCwgdjFdXG4gKi9cbmV4cG9ydHMucm90YXRlPWZ1bmN0aW9uKHYsIGFuZ2xlKXtcbiAgIGFuZ2xlPWFuZ2xlcy5ub3JtYWxpc2VSYWRpYW5zKGFuZ2xlKTtcbiAgIHJldHVybiBbdlswXSogTWF0aC5jb3MoYW5nbGUpLXZbMV0qTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICB2WzBdKiBNYXRoLnNpbihhbmdsZSkrdlsxXSpNYXRoLmNvcyhhbmdsZSldO1xuXG59O1xuXG4vKipcbiAqXG4gKiBjYWxjdWxhdGUgdmVjdG9yIGRvdCBwcm9kdWN0XG4gKiBAcGFyYW0ge0FycmF5fSB2ZWN0b3IgW3YwLCB2MV1cbiAqIEBwYXJhbSB7QXJyYXl9IHZlY3RvciBbdjAsIHYxXVxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgdjEgYW5kIHYyXG4gKi9cbnZhciBkb3QgPSBleHBvcnRzLmRvdD1mdW5jdGlvbih2MSwgdjIpe1xuICAgcmV0dXJuICh2MVswXSAqIHYyWzBdKSArICh2MVsxXSAqIHYyWzFdKTtcbn07XG5cbi8qKlxuICpcbiAqIGNhbGN1bGF0ZSBhbmdsZSBiZXR3ZWVuIHZlY3RvcnNcbiAqIEBwYXJhbSB7QXJyYXl9IHZlY3RvciBbdjAsIHYxXVxuICogQHBhcmFtIHtBcnJheX0gdmVjdG9yIFt2MCwgdjFdXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBhbmdsZSBiZXR3ZWVuIHYxIGFuZCB2MiBpbiByYWRpYW5zXG4gKi9cbmV4cG9ydHMuYW5nbGU9ZnVuY3Rpb24odjEsIHYyKXtcbiAgIHZhciBwZXJwRG90ID0gdjFbMF0gKiB2MlsxXSAtIHYxWzFdICogdjJbMF07XG4gICByZXR1cm4gTWF0aC5hdGFuMihwZXJwRG90LCBkb3QodjEsdjIpKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0FycmF5fSB2ZWN0b3Igd2l0aCBtYXggbGVuZ3RoIGFzIHNwZWNpZmllZC5cbiAqL1xuZXhwb3J0cy50cnVuY2F0ZSA9IGZ1bmN0aW9uKHYsIG1heExlbmd0aCkge1xuICAgaWYgKGxlbih2KSA+IG1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIG11bHRpcGx5KHVuaXQodiksIG1heExlbmd0aCk7XG4gICB9XG4gICByZXR1cm4gdjtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJucyB0aGUgY2VudGVyIG9mIG11bHRpcGxlZCAyZCBwb2ludHNcbiAqIEBwYXJhbSB7QXJyYXl9IGZpcnN0IHBvaW50XG4gKiBAcGFyYW0ge0FycmF5fSBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSB7QXJyYXl9IC4uLlxuICovXG5leHBvcnRzLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMsIFswXSk7XG4gICB2YXIgYyA9IFswLDBdO1xuICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIGNbMF0gKz0gcGFyc2VJbnQocFswXSwgMTApO1xuICAgICAgY1sxXSArPSBwYXJzZUludChwWzFdLCAxMCk7XG4gICB9KTtcbiAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgIHJldHVybiBbXG4gICAgICBjWzBdIC8gbGVuLFxuICAgICAgY1sxXSAvIGxlblxuICAgXTtcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIEEqIHBhdGggZmluZGluZyBhbGdvcml0aG1cbiAqXG4gKiBVc2UgdGhlIGBmaW5kUm91dGUobWFwLCBmcm9tLCB0bywgW3RpbWVvdXRdKWAgZnVuY3Rpb24gdG8gZ2V0IHRoZSBsaW5rZWQgbGlzdFxuICogbGVhZGluZyBgZnJvbWAgYSBwb2ludCBgdG9gIGFub3RoZXIgb24gdGhlIGdpdmVuIGBtYXBgLlxuICpcbiAqIFRoZSBtYXAgbXVzdCBpbXBsZW1lbnQgdGhlIGludGVyZmFjZSBgZ2FtZWpzLnBhdGhmaW5kaW5nLk1hcGAuIFRoaXNcbiAqIGNsYXNzIGFscmVhZHkgaG9sZHMgYW4gZXhhbXBsZSBpbXBsZW1lbnRhdGlvbiBmb3IgZGVidWdnaW5nIHVzZS5cbiAqXG4gKiBPcHRpb25hbGx5LCB0aGUgc2VhcmNoIGlzIGNhbmNlbGxlZCBhZnRlciBgdGltZW91dGAgaW4gbWlsbHNlY29uZHMuXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gcm91dGUgYG51bGxgIGlzIHJldHVybmVkLlxuICpcbiAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BKl9zZWFyY2hfYWxnb3JpdGhtXG4gKiBAc2VlIGh0dHA6Ly9lbG9xdWVudGphdmFzY3JpcHQubmV0L2NoYXB0ZXI3Lmh0bWxcbiAqL1xudmFyIEJpbmFyeUhlYXAgPSByZXF1aXJlKCcuL21hdGgvYmluYXJ5aGVhcCcpLkJpbmFyeUhlYXA7XG5cbi8qKlxuICogaGVscGVyIGZ1bmN0aW9uIGZvciBBKlxuICovXG5mdW5jdGlvbiBSZWFjaGVkTGlzdChoYXNoRm4pIHtcbiAgIHZhciBsaXN0ID0ge307XG5cbiAgIHRoaXMuc3RvcmUgPSBmdW5jdGlvbihwb2ludCwgcm91dGUpIHtcbiAgICAgIGxpc3RbaGFzaEZuKHBvaW50KV0gPSByb3V0ZTtcbiAgICAgIHJldHVybjtcbiAgIH07XG5cbiAgIHRoaXMuZmluZCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICByZXR1cm4gbGlzdFtoYXNoRm4ocG9pbnQpXTtcbiAgIH07XG4gICByZXR1cm4gdGhpcztcbn1cblxuXG4vKiogQSogc2VhcmNoIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZXhwZWN0cyBhIGBNYXBgIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgb3JpZ2luIGFuZCBkZXN0aW5hdGlvblxuICogcG9pbnRzIGdpdmVuLiBJZiB0aGVyZSBpcyBhIHBhdGggYmV0d2VlbiB0aGUgdHdvIGl0IHdpbGwgcmV0dXJuIHRoZSBvcHRpbWFsXG4gKiBwYXRoIGFzIGEgbGlua2VkIGxpc3QuIElmIHRoZXJlIGlzIG5vIHBhdGggaXQgd2lsbCByZXR1cm4gbnVsbC5cbiAqXG4gKiBUaGUgbGlua2VkIGxpc3QgaXMgaW4gcmV2ZXJzZSBvcmRlcjogdGhlIGZpcnN0IGl0ZW0gaXMgdGhlIGRlc3RpbmF0aW9uIGFuZFxuICogdGhlIHBhdGggdG8gdGhlIG9yaWdpbiBmb2xsb3dzLlxuICpcbiAqIEBwYXJhbSB7TWFwfSBtYXAgbWFwIGluc3RhbmNlLCBtdXN0IGZvbGxvdyBpbnRlcmZhY2UgZGVmaW5lZCBpbiB7TWFwfVxuICogQHBhcmFtIHtBcnJheX0gb3JpZ2luXG4gKiBAcGFyYW0ge0FycmF5fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgbWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHNlYXJjaCBzaG91bGQgYmUgY2FuY2VsZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBsaW5rZWQgbGlzdCBsZWFkaW5nIGZyb20gYHRvYCB0byBgZnJvbWAgKHNpYyEpLlxuICoqL1xuZXhwb3J0cy5maW5kUm91dGUgPSBmdW5jdGlvbihtYXAsIGZyb20sIHRvLCB0aW1lb3V0KSB7XG4gICB2YXIgb3BlbiA9IG5ldyBCaW5hcnlIZWFwKHJvdXRlU2NvcmUpO1xuICAgdmFyIGhhc2hGbiA9IHR5cGVvZiBtYXAuaGFzaCA9PT0gJ2Z1bmN0aW9uJyA/IG1hcC5oYXNoIDogZGVmYXVsdEhhc2g7XG4gICB2YXIgcmVhY2hlZCA9IG5ldyBSZWFjaGVkTGlzdChoYXNoRm4pO1xuXG4gICBmdW5jdGlvbiByb3V0ZVNjb3JlKHJvdXRlKSB7XG4gICAgICBpZiAocm91dGUuc2NvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgcm91dGUuc2NvcmUgPSBtYXAuZXN0aW1hdGVkRGlzdGFuY2Uocm91dGUucG9pbnQsIHRvKSArIHJvdXRlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3V0ZS5zY29yZTtcbiAgIH1cbiAgIGZ1bmN0aW9uIGFkZE9wZW5Sb3V0ZShyb3V0ZSkge1xuICAgICAgb3Blbi5wdXNoKHJvdXRlKTtcbiAgICAgIHJlYWNoZWQuc3RvcmUocm91dGUucG9pbnQsIHJvdXRlKTtcbiAgIH1cblxuICAgZnVuY3Rpb24gcHJvY2Vzc05ld1BvaW50cyhkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBrbm93biA9IHJlYWNoZWQuZmluZChkaXJlY3Rpb24pO1xuICAgICAgdmFyIG5ld0xlbmd0aCA9IHJvdXRlLmxlbmd0aCArIG1hcC5hY3R1YWxEaXN0YW5jZShyb3V0ZS5wb2ludCwgZGlyZWN0aW9uKTtcbiAgICAgIGlmICgha25vd24gfHwga25vd24ubGVuZ3RoID4gbmV3TGVuZ3RoKXtcbiAgICAgICAgIGlmIChrbm93bikge1xuICAgICAgICAgICAgb3Blbi5yZW1vdmUoa25vd24pO1xuICAgICAgICAgfVxuICAgICAgICAgYWRkT3BlblJvdXRlKHtcbiAgICAgICAgICAgIHBvaW50OiBkaXJlY3Rpb24sXG4gICAgICAgICAgICBmcm9tOiByb3V0ZSxcbiAgICAgICAgICAgIGxlbmd0aDogbmV3TGVuZ3RoXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgIH1cbiAgIHZhciBzdGFydE1zID0gRGF0ZS5ub3coKTtcbiAgIHZhciByb3V0ZSA9IG51bGw7XG4gICBhZGRPcGVuUm91dGUoe1xuICAgICAgcG9pbnQ6IGZyb20sXG4gICAgICBmcm9tOiBudWxsLFxuICAgICAgbGVuZ3RoOiAwXG4gICB9KTtcbiAgIHZhciBlcXVhbHNGbiA9IHR5cGVvZiBtYXAuZXF1YWxzID09PSAnZnVuY3Rpb24nID8gbWFwLmVxdWFscyA6IGRlZmF1bHRFcXVhbHM7XG4gICB3aGlsZSAob3Blbi5zaXplKCkgPiAwICYmICghdGltZW91dCB8fCBEYXRlLm5vdygpIC0gc3RhcnRNcyA8IHRpbWVvdXQpKSB7XG4gICAgICByb3V0ZSA9IG9wZW4ucG9wKCk7XG4gICAgICBpZiAoZXF1YWxzRm4odG8sIHJvdXRlLnBvaW50KSkge1xuICAgICAgICAgcmV0dXJuIHJvdXRlO1xuICAgICAgfVxuICAgICAgbWFwLmFkamFjZW50KHJvdXRlLnBvaW50KS5mb3JFYWNoKHByb2Nlc3NOZXdQb2ludHMpO1xuICAgfSAvLyBlbmQgd2hpbGVcbiAgIHJldHVybiBudWxsO1xufTtcblxudmFyIGRlZmF1bHRFcXVhbHMgPSBmdW5jdGlvbihhLCBiKSB7XG4gICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufTtcblxudmFyIGRlZmF1bHRIYXNoID0gZnVuY3Rpb24oYSkge1xuICAgcmV0dXJuIGFbMF0gKyAnLScgKyBhWzFdO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBpbnRlcmZhY2UgZm9yIGEgTWFwIHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGZpbmRSb3V0ZSgpYFxuICogZnVuY3Rpb24uIGBNYXBgIGlzIG5vdCBpbnN0YW50aWFibGUgLSBzZWUgdGhlIHVuaXQgdGVzdHMgZm9yIGFuIGV4YW1wbGVcbiAqIGltcGxlbWVudGF0aW9uIG9mIE1hcC5cbiAqL1xudmFyIE1hcCA9IGV4cG9ydHMuTWFwID0gZnVuY3Rpb24oKSB7XG4gICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbnN0YW50aWFibGUsIHRoaXMgaXMgYW4gaW50ZXJmYWNlJyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IG9yaWdpblxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIHBvaW50cyBhY2Nlc3NpYmxlIGZyb20gZ2l2ZW4gUG9pbnRcbiAqL1xuTWFwLnByb3RvdHlwZS5hZGphY2VudCA9IGZ1bmN0aW9uKG9yaWdpbikge1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBvbmUgb2YgdGhlIHBvaW50cyBvdCB0ZXN0IGZvciBlcXVhbGl0eVxuICogQHBhcmFtIHtPYmplY3R9IGIgLi4uIHRoZSBvdGhlciBwb2ludFxuICogQHJldHVybnMgV2hldGVyIHRoZSB0d28gcG9pbnRzIGFyZSBlcXVhbC5cbiAqL1xuTWFwLnByb3RvdHlwZS5lcXVhbHMgPSBkZWZhdWx0RXF1YWxzO1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIHBvaW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoYXNoIGZvciB0aGUgcG9pbnRcbiAqL1xuTWFwLnByb3RvdHlwZS5oYXNoID0gZGVmYXVsdEhhc2g7XG5cbi8qKlxuICogRXN0aW1hdGVkIGxvd2VyIGJvdW5kIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBlc3RpbWF0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKi9cbk1hcC5wcm90b3R5cGUuZXN0aW1hdGVkRGlzdGFuY2UgPSBmdW5jdGlvbihwb2ludEEsIHBvaW50Qikge1xuICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIEFjdHVhbCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gKiBAcGFyYW0ge09iamVjdH0gcG9pbnRBXG4gKiBAcGFyYW0ge09iamVjdH0gcG9pbnRCXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgYWN0dWFsIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICovXG5NYXAucHJvdG90eXBlLmFjdHVhbERpc3RhbmNlID0gZnVuY3Rpb24ocG9pbnRBLCBwb2ludEIpIHtcbiAgIHJldHVybiAxO1xufTtcbiIsInZhciBnYW1lanMgPSByZXF1aXJlKCcuLi9nYW1lanMnKTtcbnZhciBvYmplY3RzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3RzJyk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBJbWFnZSBtYXNrLiBVc2VmdWxsIGZvciBwaXhlbCBwZXJmZWN0IGNvbGxpc2lvbiBkZXRlY3Rpb246XG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB1bml0TWFzayA9IG5ldyBNYWtzKHVuaXRTdXJmYWNlLCBjb2xsaXNpb25UaHJlc2hvbGRBbHBoYVZhbHVlKTtcbiAqIHZhciBzcGVhck1hc2sgPSBuZXcgTWFrcyh1bml0U3VyZmFjZSwgY29sbGlzaW9uVGhyZXNob2xkQWxwaGFWYWx1ZSk7XG4gKiB2YXIgY29sbGlkZSA9IHVuaXRNYXNrLm92ZXJsYXAoc3BlYXJNYXNrKTtcbiAqL1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbWFnZSBtYXNrIGZyb20gdGhlIGdpdmVuIFN1cmZhY2UuIFRoZSBhbHBoYSBvZiBlYWNoIHBpeGVsIGlzIGNoZWNrZWRcbiAqIHRvIHNlZSBpZiBpdCBpcyBncmVhdGVyIHRoYW4gdGhlIGdpdmVuIHRocmVzaG9sZC4gSWYgaXQgaXMgZ3JlYXRlciB0aGVuXG4gKiB0aGF0IHBpeGVsIGlzIHNldCBhcyBub3QgY29sbGlkaW5nLlxuICpcbiAqIEBwYXJhbSB7U3VyZmFjZX0gc3VyZmFjZSB1c2VkIGZvciBpbWFnZSBtYXNrXG4gKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIDAgdG8gMjU1LiBkZWZhdWx0cyB0bzogMjU1LCBmdWxseSB0cmFuc3BhcmVudFxuICpcbiAqL1xudmFyIE1hc2sgPSBleHBvcnRzLk1hc2sgPSBmdW5jdGlvbihzdXJmYWNlLCB0aHJlc2hvbGQpIHtcbiAgIC8qKlxuICAgICogQGlnbm9yZVxuICAgICovXG4gICB0aGlzLl9iaXRzID0gW107XG5cbiAgIHRocmVzaG9sZCA9ICh0aHJlc2hvbGQgJiYgKDI1NSAtIHRocmVzaG9sZCkpIHx8IDI1NTtcbiAgIHZhciBpbWdEYXRhID0gc3VyZmFjZS5nZXRJbWFnZURhdGEoKS5kYXRhO1xuICAgdmFyIGRpbXMgPSBzdXJmYWNlLmdldFNpemUoKTtcbiAgIC8qKlxuICAgICogQGlnbm9yZVxuICAgICovXG4gICB0aGlzLndpZHRoID0gZGltc1swXTtcbiAgIC8qKlxuICAgICogQGlnbm9yZVxuICAgICovXG4gICB0aGlzLmhlaWdodCA9IGRpbXNbMV07XG5cbiAgIHZhciBpLGo7XG4gICBmb3IgKGk9MDtpPHRoaXMud2lkdGg7aSsrKSB7XG4gICAgICB0aGlzLl9iaXRzW2ldID0gW107XG4gICAgICBmb3IgKGo9MDtqPHRoaXMuaGVpZ2h0O2orKykge1xuICAgICAgICAgdGhpcy5fYml0c1tpXVtqXSA9IGZhbHNlO1xuICAgICAgfVxuICAgfVxuICAgZm9yIChpPTA7aTxpbWdEYXRhLmxlbmd0aDtpICs9IDQpIHtcbiAgICAgIC8vIHk6IHBpeGVsICMgLyB3aWR0aFxuICAgICAgdmFyIHkgPSBwYXJzZUludCgoaSAvIDQpIC8gZGltc1swXSwgMTApO1xuICAgICAgLy8geDogcGl4ZWwgIyAlIHdpZHRoXG4gICAgICB2YXIgeCA9IHBhcnNlSW50KChpIC8gNCkgJSBkaW1zWzBdLCAxMCk7XG4gICAgICB2YXIgYWxwaGEgPSBpbWdEYXRhW2krM107XG4gICAgICBpZiAoYWxwaGEgPj0gdGhyZXNob2xkKSB7XG4gICAgICAgICB0aGlzLnNldEF0KHgsIHkpO1xuICAgICAgfVxuICAgfVxuICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2dhbWVqcy5tYXNrLk1hc2t9IG90aGVyTWFza1xuICogQHBhcmFtIHtBcnJheX0gb2Zmc2V0IFt4LHldXG4gKiBAcmV0dXJucyB0aGUgb3ZlcmxhcHBpbmcgcmVjdGFuZ2xlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gb3ZlcmxhcDtcbiAqL1xuTWFzay5wcm90b3R5cGUub3ZlcmxhcFJlY3QgPSBmdW5jdGlvbihvdGhlck1hc2ssIG9mZnNldCkge1xuICAgdmFyIGFyZWN0ID0gdGhpcy5yZWN0O1xuICAgdmFyIGJyZWN0ID0gb3RoZXJNYXNrLnJlY3Q7XG4gICBpZiAob2Zmc2V0KSB7XG4gICAgICBicmVjdC5tb3ZlSXAob2Zmc2V0KTtcbiAgIH1cbiAgIC8vIGJvdW5kaW5nIGJveCBpbnRlcnNlY3RcbiAgIGlmICghYnJlY3QuY29sbGlkZVJlY3QoYXJlY3QpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgIH1cbiAgIHZhciB4U3RhcnQgPSBNYXRoLm1heChhcmVjdC5sZWZ0LCBicmVjdC5sZWZ0KTtcbiAgIHZhciB4RW5kID0gTWF0aC5taW4oYXJlY3QucmlnaHQsIGJyZWN0LnJpZ2h0KTtcblxuICAgdmFyIHlTdGFydCA9IE1hdGgubWF4KGFyZWN0LnRvcCwgYnJlY3QudG9wKTtcbiAgIHZhciB5RW5kID0gTWF0aC5taW4oYXJlY3QuYm90dG9tLCBicmVjdC5ib3R0b20pO1xuXG4gICByZXR1cm4gbmV3IGdhbWVqcy5SZWN0KFt4U3RhcnQsIHlTdGFydF0sIFt4RW5kIC0geFN0YXJ0LCB5RW5kIC0geVN0YXJ0XSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvdGhlck1hc2sgb3ZlcmxhcHMgd2l0aCB0aGlzIG1hcC5cbiAqIEBwYXJhbSB7TWFza30gb3RoZXJNYXNrXG4gKiBAcGFyYW0ge0FycmF5fSBvZmZzZXRcbiAqL1xuTWFzay5wcm90b3R5cGUub3ZlcmxhcCA9IGZ1bmN0aW9uKG90aGVyTWFzaywgb2Zmc2V0KSB7XG4gICB2YXIgb3ZlcmxhcFJlY3QgPSB0aGlzLm92ZXJsYXBSZWN0KG90aGVyTWFzaywgb2Zmc2V0KTtcbiAgIGlmIChvdmVybGFwUmVjdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxuXG4gICB2YXIgYXJlY3QgPSB0aGlzLnJlY3Q7XG4gICB2YXIgYnJlY3QgPSBvdGhlck1hc2sucmVjdDtcbiAgIGlmIChvZmZzZXQpIHtcbiAgICAgIGJyZWN0Lm1vdmVJcChvZmZzZXQpO1xuICAgfVxuXG4gICB2YXIgY291bnQgPSAwO1xuICAgdmFyIHgseTtcbiAgIGZvciAoeT1vdmVybGFwUmVjdC50b3A7IHk8PW92ZXJsYXBSZWN0LmJvdHRvbTsgeSsrKSB7XG4gICAgICBmb3IgKHg9b3ZlcmxhcFJlY3QubGVmdDsgeDw9b3ZlcmxhcFJlY3QucmlnaHQ7IHgrKykge1xuICAgICAgICAgaWYgKHRoaXMuZ2V0QXQoeCAtIGFyZWN0LmxlZnQsIHkgLSBhcmVjdC50b3ApICYmXG4gICAgICAgICAgICAgb3RoZXJNYXNrLmdldEF0KHggLSBicmVjdC5sZWZ0LCB5IC0gYnJlY3QudG9wKSkge1xuICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuICAgLy8gTk9URSB0aGlzIHNob3VsZCBub3QgaGFwcGVuIGJlY2F1c2UgZWl0aGVyIHdlIGJhaWxlZCBvdXRcbiAgIC8vIGxvbmcgYWdvIGJlY2F1c2UgdGhlIHJlY3RzIGRvIG5vdCBvdmVybGFwIG9yIHRoZXJlIGlzIGFuXG4gICAvLyBvdmVybGFwIGFuZCB3ZSBzaG91bGQgbm90IGhhdmUgZ290dGVuIHRoaXMgZmFyLlxuICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiTWFrcy5vdmVybGFwOiBvdmVybGFwIGRldGVjdGVkIGJ1dCBjb3VsZCBub3QgY3JlYXRlIG1hc2sgZm9yIGl0LlwiKTtcbiAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtnYW1lanMubWFzay5NYXNrfSBvdGhlck1hc2tcbiAqIEBwYXJhbSB7QXJyYXl9IG9mZnNldCBbeCx5XVxuICogQHJldHVybnMgdGhlIG51bWJlciBvZiBvdmVybGFwcGluZyBwaXhlbHNcbiAqL1xuTWFzay5wcm90b3R5cGUub3ZlcmxhcEFyZWEgPSBmdW5jdGlvbihvdGhlck1hc2ssIG9mZnNldCkge1xuICAgdmFyIG92ZXJsYXBSZWN0ID0gdGhpcy5vdmVybGFwUmVjdChvdGhlck1hc2ssIG9mZnNldCk7XG4gICBpZiAob3ZlcmxhcFJlY3QgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgfVxuXG4gICB2YXIgYXJlY3QgPSB0aGlzLnJlY3Q7XG4gICB2YXIgYnJlY3QgPSBvdGhlck1hc2sucmVjdDtcbiAgIGlmIChvZmZzZXQpIHtcbiAgICAgIGJyZWN0Lm1vdmVJcChvZmZzZXQpO1xuICAgfVxuXG4gICB2YXIgY291bnQgPSAwO1xuICAgdmFyIHgseTtcbiAgIGZvciAoeT1vdmVybGFwUmVjdC50b3A7IHk8PW92ZXJsYXBSZWN0LmJvdHRvbTsgeSsrKSB7XG4gICAgICBmb3IgKHg9b3ZlcmxhcFJlY3QubGVmdDsgeDw9b3ZlcmxhcFJlY3QucmlnaHQ7IHgrKykge1xuICAgICAgICAgaWYgKHRoaXMuZ2V0QXQoeCAtIGFyZWN0LmxlZnQsIHkgLSBhcmVjdC50b3ApICYmXG4gICAgICAgICAgICAgb3RoZXJNYXNrLmdldEF0KHggLSBicmVjdC5sZWZ0LCB5IC0gYnJlY3QudG9wKSkge1xuICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG4gICByZXR1cm4gY291bnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Z2FtZWpzLm1hc2suTWFza30gb3RoZXJNYXNrXG4gKiBAcGFyYW0ge0FycmF5fSBvZmZzZXQgW3gseV1cbiAqIEByZXR1cm5zIGEgbWFzayBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzXG4gKi9cbk1hc2sucHJvdG90eXBlLm92ZXJsYXBNYXNrID0gZnVuY3Rpb24ob3RoZXJNYXNrLCBvZmZzZXQpIHtcbiAgIHZhciBvdmVybGFwUmVjdCA9IHRoaXMub3ZlcmxhcFJlY3Qob3RoZXJNYXNrLCBvZmZzZXQpO1xuICAgaWYgKG92ZXJsYXBSZWN0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgIH1cblxuICAgdmFyIGFyZWN0ID0gdGhpcy5yZWN0O1xuICAgdmFyIGJyZWN0ID0gb3RoZXJNYXNrLnJlY3Q7XG4gICBpZiAob2Zmc2V0KSB7XG4gICAgICBicmVjdC5tb3ZlSXAob2Zmc2V0KTtcbiAgIH1cblxuICAgdmFyIG1hc2sgPSBuZXcgTWFzayhuZXcgZ2FtZWpzLmdyYXBoaWNzLlN1cmZhY2UoW292ZXJsYXBSZWN0LndpZHRoLCBvdmVybGFwUmVjdC5oZWlnaHRdKSk7XG4gICB2YXIgeCx5O1xuICAgZm9yICh5PW92ZXJsYXBSZWN0LnRvcDsgeTw9b3ZlcmxhcFJlY3QuYm90dG9tOyB5KyspIHtcbiAgICAgIGZvciAoeD1vdmVybGFwUmVjdC5sZWZ0OyB4PD1vdmVybGFwUmVjdC5yaWdodDsgeCsrKSB7XG4gICAgICAgICBpZiAodGhpcy5nZXRBdCh4IC0gYXJlY3QubGVmdCwgeSAtIGFyZWN0LnRvcCkgJiZcbiAgICAgICAgICAgICBvdGhlck1hc2suZ2V0QXQoeCAtIGJyZWN0LmxlZnQsIHkgLSBicmVjdC50b3ApKSB7XG4gICAgICAgICAgICAgbWFzay5zZXRBdCh4LCB5KTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbiAgIHJldHVybiBtYXNrO1xufTtcblxuLyoqXG4gKiBTZXQgYml0IGF0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKi9cbk1hc2sucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgdGhpcy5fYml0c1t4XVt5XSA9IHRydWU7XG59O1xuXG4vKipcbiAqIEdldCBiaXQgYXQgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKi9cbk1hc2sucHJvdG90eXBlLmdldEF0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgeCA9IHBhcnNlSW50KHgsIDEwKTtcbiAgIHkgPSBwYXJzZUludCh5LCAxMCk7XG4gICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+PSB0aGlzLndpZHRoIHx8IHkgPj0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIHJldHVybiB0aGlzLl9iaXRzW3hdW3ldO1xufTtcblxuXG4vKipcbiAqIEZsaXAgdGhlIGJpdHMgaW4gdGhpcyBtYXAuXG4gKi9cbk1hc2sucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xuICAgdGhpcy5fYml0cyA9IHRoaXMuX2JpdHMubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24oYikge1xuICAgICAgICAgcmV0dXJuICFiO1xuICAgICAgfSk7XG4gICB9KTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge0FycmF5fSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgbWFwXG4gKi9cbk1hc2sucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdO1xufTtcblxub2JqZWN0cy5hY2Nlc3NvcnMoTWFzay5wcm90b3R5cGUsIHtcbiAgIC8qKlxuICAgICogUmVjdCBvZiB0aGlzIE1hc2suXG4gICAgKi9cbiAgICdyZWN0Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgIHJldHVybiBuZXcgZ2FtZWpzLlJlY3QoWzAsIDBdLCBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdKTtcbiAgICAgIH1cbiAgIH0sXG4gICAvKipcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IG51bWJlciBvZiBzZXQgcGl4ZWxzIGluIHRoaXMgbWFzay5cbiAgICAqL1xuICAgJ2xlbmd0aCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgICB0aGlzLl9iaXRzLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9KTtcbiAgICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgfVxufSk7XG4iLCJ2YXIgZ2FtZWpzID0gcmVxdWlyZSgnLi4vZ2FtZWpzJyk7XG52YXIgdXJpID0gcmVxdWlyZSgnLi91dGlscy91cmknKTtcbnZhciBDYWxsYmFjayA9IHJlcXVpcmUoJy4vdXRpbHMvY2FsbGJhY2snKS5DYWxsYmFjaztcblxuLyoqXG4gKiBpZ25vcmVcbiAqL1xudmFyIF9FVkVOVFMgPSBleHBvcnRzLl9FVkVOVFMgPSB7XG4gICBSRVNVTFQ6IDEwMDEsXG4gICBBTElWRTogMTAwMixcbiAgIExPRzogMTAwNFxufTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKlxuICogZ2FtZWpzLndvcmtlciBtYWtlcyBpdCBtb3JlIGNvbnZpbmllbnQgdG8gd29yayB3aXRoIFczQyBXZWJXb3JrZXJzIGJ5IHByb3ZpZGluZyBhIHdheSB0byBydW5cbiAqIENvbW1vbkpzIG1vZHVsZXMgaW5zaWRlIG9mIHRoZW0uIEdhbWVKcyBhbHNvIHByb3ZpZGVzIHRoZSB0eXBpY2FsbHkgYGdhbWVqcy5yZWFkeSgpYCBhbmRcbiAqIGV2ZW50IGxvb3AgdG8gZmFjaWxpdGF0ZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gd29ya2VycyBhbmQgdGhlIG1haW4gYXBwbGljYXRpb24uXG4gKlxuICogU2VlIHRoZSBgZXhhbXBsZXMvd29ya2Vyc2AgZGlyZWN0b3J5IGZvciBhIHJ1bm5pbmcgZXhhbXBsZS5cbiAqXG4gKiBDcmVhdGUgYSB3b3JrZXIgd2l0aCB0aGUgbWFpbiBtb2R1bGUgXCJmb28td29ya2VyXCIgKHNlZSBiZWxvdyBmb3IgaG93IHRoZSB3b3JrZXIncyBtb2R1bGUgbG9va3MgbGlrZSk6XG4gKlxuICogICAgIHZhciBmb29Xb3JrZXIgPSBuZXcgV29ya2VyKCcuL2Zvby13b3JrZXInKTtcbiAqICAgICAvLyBTZW5kIGEgbWVzc2FnZSB0byB5b3VyIHdvcmtlci5cbiAqICAgICAvLyBUaGUgTWVzc2FnZSBkb2Vzbid0IGhhdmUgdG8gYmUgYSBzdHJpbmcgYnV0IGl0XG4gKiAgICAgLy8gbXVzdCBiZSBgSlNPTi5zdHJpbmdpZnkoKWAtYWJsZVxuICogICAgIGZvb1dvcmtlci5wb3N0KFwiZm9vYmFyXCIpO1xuICpcbiAqIFlvdSBjYW4gYWxzbyByZWNpZXZlIG1lc3NhZ2VzIGZyb20gdGhlIHdvcmtlcjpcbiAqXG4gKiAgICAgLy8gcmVjaWV2ZSBldmVudHMgZnJvbSB0aGUgd29ya2VyXG4gKiAgICAgZm9vV29ya2VyLm9uRXZlbnQoZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICAgICAgaWYoZXZlbnQudGltZXN0YW1wID4gLi4uKVxuICogICAgICB9KTtcbiAqXG4gKiBBbmQgdGhpcyBpcyBob3cgdGhlIGFib3ZlIHJlZmVyZW5jZWQgXCJmb28td29ya2VyXCIgbW9kdWxlIHdvdWxkIGxvb2tlIGxpa2UuIEFzIHVzdWFsLCB3ZSBuZWVkIGFcbiAqIGBnYW1lanMucmVhZHkoKWAgdG8gZ2V0IHN0YXJ0ZWQgYW5kIHdpdGhpbiB0aGF0IHdlIGJpbmQgYW4gZXZlbnQgaGFuZGxlcjpcbiAqXG4gKiAgICAgdmFyIGdhbWVqcyA9IHJlcXVpcmUoJ2dhbWVqcycpO1xuICogICAgIGdhbWVqcy5yZWFkeShmdW5jdGlvbigpIHtcbiAqICAgICAgICAgZ2FtZWpzLmV2ZW50Lm9uRXZlbnQoZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gZmFzdENyYWNrKGV2ZW50LnBhc3N3b3JkKVxuICogICAgICAgICAgICAgIC4uLi5cbiAqICAgICAgICAgIH0pO1xuICogICAgIH0pO1xuICpcbiAqIE91ciBldmVudCB3b3JrZXIgY291bGQgZG8gZXhwZW5zaXZlIGNhbGN1bGF0aW9ucyAoc2VwZXJhdGUgYW5kIG5vdCBibG9ja2luZyB0aGUgbWFpbiBnYW1lKSB3aGVuXG4gKiByZWNpZXZpbmcgYW4gZXZlbnQuIE9uY2UgdGhlIHJlc3VsdCBpcyBjYWN1bGF0ZWQsIGl0IGNhbiBiZSBzZW50IGJhY2sgdG8gdGhlIG1haW4gYXBwbGljYXRpb25cbiAqIHdpdGggYGdhbWVqcy50aHJlYWQucG9zdCgpYDpcbiAqXG4gKiAgICAgZ2FtZWpzLnRocmVhZC5wb3N0KHtcbiAqICAgICAgICBpbmZvOiBcImltcG9ydGFudCBtZXNzYWdlIGZyb20gd29ya2VyXCIsXG4gKiAgICAgICAgdGltZXN0YW1wOiAxMjIzMjQzNTIzNFxuICogICAgICB9KTtcbiAqXG4gKiBUaGUgbWFpbiBhcHBsaWNhdGlvbiB3b3VsZCBpbiB0dXJuIHJlY2lldmUgYW4gZXZlbnQgcG9zdGVkIGxpa2UgdGhpcyBmcm9tIGBmb29Xb3JrZXIub25FdmVudGAsIGFzIHNlZW4gYWJvdmUuXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgdXNlZnVsIGZvciBleHBlbnNpdmUgYWxnb3JpdGhtcyB3aGVyZSB0aGUgcmVzdWx0IGRvZXMgbm90IGhhdmUgdG8gYXZhaWxhYmxlIGluc3RhbnRpb3VzbHlcbiAqIChlLmcuLCBwYXRoLWZpbmRpbmcpIG9yIGZvciBjb250aW5vdXMgbG9naWMgd2hpY2ggY2FuIGJlXG4gKiBjYWxjdWxhdGVkIHNlcGVyYXRlbHkgZnJvbSB0aGUgcmVuZGVyaW5nIGxvb3AsIGFuZCB3aGljaCBvbmx5IG5lZWRzIHRvIGZlZWQgYmFjayBpbnRvIHRoZSBtb2RlbCBvZiB0aGUgcmVuZGVyaW5nIGV2ZXJ5XG4gKiBub3cgYW5kIHRoZW4gKGUuZy4gcGh5c2ljcykgVGhlIG1haW4gZHJhdyBiYWNrIG9mIHRoZSBgV29ya2VyYCBtb2RlbCBpcyB0aGF0XG4gKiB5b3UgY2FuIG9ubHkgY29tbXVuaWNhdGUgd2l0aCB0aGVtIHZpYSB0ZXh0IG1lc3NhZ2VzICh0eXBpY2FsbHkgSlNPTi5zdHJpbmdpZnkoKWVkIG1lc3NhZ2VzKS5cbiAqL1xuXG4vKipcbiAqIHRydWUgaWYgdGhpcyBHYW1lSnMgaW5zdGFuY2UgaXMgYmVpbmcgZXhlY3V0ZWQgd2l0aGluIGEgV2ViV29ya2VyXG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cbnZhciBpbldvcmtlciA9IGV4cG9ydHMuaW5Xb3JrZXIgPSAodGhpcy5pbXBvcnRTY3JpcHRzICE9PSB1bmRlZmluZWQpO1xuXG4vKipcbiAqIGV4ZWN1dGVkIGluIHNjb3BlIG9mIHdvcmtlclxuICogQGlnbm9yZVxuICovXG5leHBvcnRzLl9yZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgZ2FtZWpzLmV2ZW50Ll90cmlnZ2VyQ2FsbGJhY2tzKGV2ZW50LmRhdGEpO1xuICAgfTtcbiAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICB0eXBlOiBfRVZFTlRTLkFMSVZFXG4gICB9KTtcbn07XG5cbi8qKlxuICogU2VuZCBhbiBldmVudCBiYWNrIHRvIHRoZSBtYWluIHNjcmlwdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRvIGJlIHNlbnQgYmFjayB0byBtYWluIHNjcmlwdFxuICovXG5leHBvcnRzLnBvc3QgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmIChpbldvcmtlcikge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgIHR5cGU6IF9FVkVOVFMuUkVTVUxULFxuICAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dhbWVqcy5wb3N0TWVzc2FnZSBvbmx5IGF2YWlsYWJsZSBpbiBhIHRocmVhZC93b3JrZXIgbW9kdWxlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZCBtZXNzYWdlIHRvIG1haW4gY29udGV4dCBmb3IgbG9nZ2luZ1xuICogQGlnbm9yZVxuICoqL1xuZXhwb3J0cy5fbG9nTWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgdmFyIGFyZ3MgPSBbXTtcbiAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhKSB7XG4gICAgIGFyZ3MucHVzaChhKTtcbiAgIH0pO1xuICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBfRVZFTlRTLkxPRyxcbiAgICAgIGFyZ3VtZW50czogYXJnc1xuICAgfSk7XG59O1xuXG5cbi8qKlxuICAqIGV4ZWN1dGVkIGluIHNjb3BlIG9mIHdvcmtlciBiZWZvcmUgdXNlcidzIG1haW4gbW9kdWxlXG4gICogQGlnbm9yZVxuICAqL1xudmFyIHdvcmtlclByZWZpeCA9IGZ1bmN0aW9uIHdvcmtlclByZWZpeCgpIHtcbiAgIF9fc2NyaXB0cy5mb3JFYWNoKGZ1bmN0aW9uKHNjcmlwdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgIGltcG9ydFNjcmlwdHMoc2NyaXB0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgIC8vIGNhbid0IGhlbHAgdGhlIHdvcmtlclxuICAgICAgfVxuICAgfSk7XG59O1xuXG4vKipcbiAqIFNldHVwIGEgd29ya2VyIHdoaWNoIGhhcyBgcmVxdWlyZSgpYCBkZWZpbmVkXG4gKiBAaWdub3JlXG4gKiovXG52YXIgY3JlYXRlID0gZnVuY3Rpb24od29ya2VyTW9kdWxlSWQpIHtcbiAgIHZhciBtb2R1bGVSb290ID0gdXJpLnJlc29sdmUoZG9jdW1lbnQubG9jYXRpb24uaHJlZiwgd2luZG93LnJlcXVpcmUuZ2V0TW9kdWxlUm9vdCgpKTtcbiAgIHZhciBpbml0aWFsU2NyaXB0cyA9IFtdO1xuICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSwgWzBdKS5mb3JFYWNoKGZ1bmN0aW9uKHNjcmlwdCkge1xuICAgICAgaWYgKHNjcmlwdC5zcmMpIHtcbiAgICAgICAgIGluaXRpYWxTY3JpcHRzLnB1c2goc2NyaXB0LnNyYyk7XG4gICAgICB9XG4gICB9KTtcblxuICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcbiAgIHZhciBwcmVmaXhTdHJpbmcgPSB3b3JrZXJQcmVmaXgudG9TdHJpbmcoKTtcbiAgIC8vIGRvbid0IGJlIGFmcmFpZC4uLlxuICAgcHJlZml4U3RyaW5nID0gcHJlZml4U3RyaW5nLnN1YnN0cmluZyhwcmVmaXhTdHJpbmcuaW5kZXhPZihcIntcIikgKyAxLCBwcmVmaXhTdHJpbmcubGFzdEluZGV4T2YoXCJ9XCIpKTtcbiAgIHZhciBibG9iID0gbmV3IEJsb2IoW1xuICAgICAgJ3ZhciBfX3NjcmlwdHMgPSBbXCInICsgaW5pdGlhbFNjcmlwdHMuam9pbignXCIsXCInKSArICdcIl07JyxcbiAgICAgIHByZWZpeFN0cmluZyxcbiAgICAgICc7c2VsZi5yZXF1aXJlLnNldE1vZHVsZVJvb3QoXCInICsgbW9kdWxlUm9vdCArICdcIik7JyxcbiAgICAgICdzZWxmLnJlcXVpcmUucnVuKFwiJysgd29ya2VyTW9kdWxlSWQgKydcIik7J1xuICAgXSwge3R5cGU6ICdhcHBsaWNhdGlvblxcL2phdmFzY3JpcHQnfSk7XG5cbiAgIHZhciBibG9iVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgIHJldHVybiBuZXcgV29ya2VyKGJsb2JVUkwpO1xufTtcblxuLyoqXG4gKiBUaGUgYFdvcmtlcmAgY29uc3RydWN0b3IgdGFrZXMgb25seSBvbmUgYXJndW1lbnQ6IGEgbW9kdWxlIGlkLiBUaGlzIG1vZHVsZVxuICogd2lsbCBiZSBleGVjdXRlZCBpbnNpZGUgdGhlIG5ld2x5IGNyZWF0ZWQgV29ya2VyLiBJdCBpcyBlZmZlY3RpdmVseSB0aGVcbiAqIG1haW4gbW9kdWxlIG9mIHRoZSBXb3JrZXIuXG4gKlxuICogSW5zaWRlIGEgV29ya2VyLCB5b3UgY2FuIHVzZSBgcmVxdWlyZSgpYCB0byBpbXBvcnQgb3RoZXIgc2NyaXB0cyBvclxuICogR2FtZUpzIG1vZHVsZXMuXG4gKlxuICogKipOb3RlOioqIEEgV29ya2VyIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIHRoZSBicm93c2VyJ3MgYGRvY3VtZW50YC4gU29cbiAqIGEgbG90IG9mIEdhbWVKcyBtb2R1bGVzIC0gZXZlcnl0aGluZyByZWxhdGVkIHRvIGRyYXdpbmcgdG8gdGhlIGNhbnZhcyAtXG4gKiBkbyBub3Qgd29yayBpbiB0aGUgV29ya2VyLlxuICpcbiAqIFlvdSBjYW4gdXNlIGBnYW1lanMudGltZS4qYCwgYGdhbWVqcy51dGlscy4qYCwgYGdhbWVqcy5ldmVudC4qYCBhbmQgcHJvYmFibHkgb3RoZXJzXG4gKiAoYXMgd2VsbCBhcyBhbnkgbW9kdWxlIHlvdSB3cml0ZSB5b3Vyc2VsZiBmb3IgdGhpcyBwdXJwb3NlLCBvZiBjb3Vyc2UpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGVJZCBUaGUgV29ya2VyJ3MgbWFpbiBtb2R1bGUgaWQuIFRoZSBtYWluIG1vZHVsZSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSB3b3JrZXJcbiAqL1xuZXhwb3J0cy5Xb3JrZXIgPSBmdW5jdGlvbihtb2R1bGVJZCkge1xuICAgLy8gRklYTUUgaWQgc2hvdWxkIGJlIHVuY2hhbmdlYWJsZVxuICAgLyoqXG4gICAgKiBVbmlxdWUgaWQgb2YgdGhpcyB3b3JrZXJcbiAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfVxuICAgICovXG4gICB2YXIgaWQgPSB0aGlzLmlkID0gZ3VpZChtb2R1bGVJZCk7XG4gICB2YXIgd29ya2VyID0gY3JlYXRlKG1vZHVsZUlkKTtcbiAgIHZhciBkZWFkUXVldWUgPSBbXTtcbiAgIHZhciBhbGl2ZSA9IGZhbHNlO1xuICAgdmFyIHNlbGYgID0gdGhpcztcbiAgIHZhciBfQ0FMTEJBQ0tTID0gW107XG4gICB2YXIgX0VSUk9SX0NBTExCQUNLUyA9IFtdO1xuXG4gICBmdW5jdGlvbiB0cmlnZ2VyQ2FsbGJhY2tzKGNhbGxiYWNrcywgZXZlbnQpIHtcbiAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgIGMudHJpZ2dlcihldmVudCk7XG4gICAgICB9KTtcbiAgIH1cblxuICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSBfRVZFTlRTLkFMSVZFKSB7XG4gICAgICAgICAvLyBpZiB3b3JrZXIgc2F5cyBoZSBpcyBhbGl2ZSAtPiBzZW5kIGhpbSB0aGUgZXZlbnQgcXVldWUgc28gZmFyXG4gICAgICAgICBhbGl2ZSA9IHRydWU7XG4gICAgICAgICBkZWFkUXVldWUuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBzZWxmLnBvc3QoZGF0YSk7XG4gICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS50eXBlID09PSBfRVZFTlRTLkxPRykge1xuICAgICAgICAgZ2FtZWpzLmxvZ2dpbmcubG9nLmFwcGx5KG51bGwsIFtpZF0uY29uY2F0KGV2ZW50LmRhdGEuYXJndW1lbnRzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgdHJpZ2dlckNhbGxiYWNrcyhfQ0FMTEJBQ0tTLCBldmVudC5kYXRhLmRhdGEpO1xuICAgICAgfVxuICAgfTtcbiAgIHdvcmtlci5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGdhbWVqcy5sb2dnaW5nLmVycm9yKCdFcnJvciBpbiB3b3JrZXIgXCInICsgaWQgKyAnXCIgbGluZSAnICsgZXZlbnQubGluZW5vICsgJzogJywgZXZlbnQubWVzc2FnZSk7XG4gICAgICB0cmlnZ2VyQ2FsbGJhY2tzKF9FUlJPUl9DQUxMQkFDS1MsIHtcbiAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICB3b3JrZXI6IHNlbGYsXG4gICAgICAgICBldmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgfTtcblxuICAgdGhpcy5vbkV2ZW50ID0gZnVuY3Rpb24oZm4sIHNjb3BlKSB7XG4gICAgICBfQ0FMTEJBQ0tTLnB1c2gobmV3IENhbGxiYWNrKGZuLCBzY29wZSkpO1xuICAgfTtcblxuICAgdGhpcy5vbkVycm9yID0gZnVuY3Rpb24oZm4sIHNjb3BlKSB7XG4gICAgICBfRVJST1JfQ0FMTEJBQ0tTLnB1c2gobmV3IENhbGxiYWNrKGZuLCBzY29wZSkpO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgd29ya2VyXG4gICAgKlxuICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUGF5bG9hZCBvYmplY3Qgd2hpY2ggZ2V0cyBzZW50IHRvIHRoZSBXb3JrZXJcbiAgICAqL1xuICAgdGhpcy5wb3N0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKGFsaXZlKSB7XG4gICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgZGVhZFF1ZXVlLnB1c2goZGF0YSk7XG4gICAgICB9XG4gICB9O1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIG5vdCBhIHJlYWwgR1VJRFxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBndWlkKG1vZHVsZUlkKSB7XG4gICB2YXIgUzQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoKCgxK01hdGgucmFuZG9tKCkpKjB4MTAwMDApfDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICB9O1xuICAgcmV0dXJuIG1vZHVsZUlkICsgJ0AnICsgKFM0KCkrUzQoKSk7XG59IiwidmFyIGdhbWVqcyA9IHJlcXVpcmUoJy4uL2dhbWVqcycpO1xudmFyIG9iamVjdHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdHMnKTtcbnZhciB4bWwgPSByZXF1aXJlKCcuL3V0aWxzL3htbCcpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vdXRpbHMvYmFzZTY0Jyk7XG52YXIgdXJpID0gcmVxdWlyZSgnLi91dGlscy91cmknKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBUaGlzIGlzIGEgbG9hZGVyIGZvciB0aGUgZ2VuZXJhbCBwdXJwb3NlIHRpbGUgbWFwIGVkaXRvciBcIlRpbGVkXCIuXG4gKlxuICogVGhpcyBtb2R1bGUgY2FuIGxvYWQgYWxsIFwiLnRteFwiIGZpbGVzIGV2ZW4gaWYgYWRkaXRpb25hbGx5IGJhc2U2NCBlbmNvZGVkXG4gKiAoY2FuIGJlIGNvbmZpZ3VyZWQgaW4gVGlsZWQpLlxuICpcbiAqIFRoaXMgbW9kdWxlIGxvYWRzIHRoZSB3aG9sZSBtYXAgZGVmaW5pdGlvbiwgaW5jbHVkaW5nIHRoZSBUaWxlU2V0cyB3aXRoXG4gKiBhbGwgbmVjZXNzYXJ5IGltYWdlcy4gRm9yIGFuIGV4YW1wbGUgb24gaG93IHRvIHJlbmRlciBhIG1hcCBsb2FkZWQgd2l0aFxuICogdGhpcyBtb2R1bGUsIHNlZSBgZXhhbXBsZXMvdGlsZWRtYXBgLlxuICpcbiAqIFlvdSB3aWxsIHR5cGljYWxseSBjcmVhdGUgYSBNYXAgaW5zdGFuY2Ugd2l0aCBgTWFwKHVybClgIGFuZCBkZWFsXG4gKiB3aXRoIHRoZSBsYXllcnMsIHRpbGVzZXRzLCBldGMuIHRocm91Z2ggdGhlIE1hcCBpbnN0YW5jZVxuICogaW5zdGVhZCBvZiBsb2FkaW5nICYgY3JlYXRpbmcgdGhlbSB5b3Vyc2VsZi5cbiAqXG4gKiBPbmx5IG9ydGhvZ29ub2wgbWFwcyBhcmUgc3VwcG9ydGVkIChubyBpc29tZXRyaWMgbWFwcykuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3Lm1hcGVkaXRvci5vcmcvXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybi90aWxlZC93aWtpL1RNWC1NYXAtRm9ybWF0XG4gKi9cblxuLyoqXG4gKiBNeSBjb2RlIGlzIGluc3BpcmVkIGJ5OlxuICogICAqIGh0dHBzOi8vYml0YnVja2V0Lm9yZy9tYWlrZy90aWxlZDJjb2Nvcy9cbiAqICAgKiBodHRwczovL2dpdGh1Yi5jb20vb2Jpb3QvbWVsb25KUy9cbiAqXG4gKi9cblxuLyoqXG4gKiBBIFRpbGVkIE1hcCBob2xkcyBhbGwgbGF5ZXJzIGRlZmluZWQgaW4gdGhlIHRteCBmaWxlIGFzIHdlbGxcbiAqIGFzIHRoZSBuZWNlc3NhcnkgdGlsZXMgdG8gcmVuZGVyIHRoZSBtYXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFJlbGF0aXZlIG9yIGFic29sdXRlIFVSTCB0byB0aGUgdG14IGZpbGVcbiAqL1xudmFyIE1hcCA9IGV4cG9ydHMuTWFwID0gZnVuY3Rpb24odXJsKSB7XG5cbiAgIHVybCA9IHVyaS5yZXNvbHZlKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYsIHVybCk7XG4gICB2YXIgeG1sRG9jID0geG1sLkRvY3VtZW50LmZyb21VUkwodXJsKTtcbiAgIHZhciBtYXBOb2RlID0geG1sRG9jLmVsZW1lbnQoJ21hcCcpO1xuXG4gICAvKipcbiAgICAqIFdpZHRoIG9mIGEgc2luZ2xlIHRpbGUgaW4gcGl4ZWxzXG4gICAgKiBAdHlwZSBOdW1iZXJcbiAgICAqL1xuICAgdGhpcy50aWxlV2lkdGggPSBtYXBOb2RlLmF0dHJpYnV0ZSgndGlsZXdpZHRoJyk7XG4gICAvKipcbiAgICAqIEhlaWdodCBvZiBhIHNpbmdsZSB0aWxlIGluIHBpeGVsc1xuICAgICogQHR5cGUgTnVtYmVyXG4gICAgKi9cbiAgIHRoaXMudGlsZUhlaWdodCA9IG1hcE5vZGUuYXR0cmlidXRlKCd0aWxlaGVpZ2h0Jyk7XG4gICAvKipcbiAgICAqIFdpZHRoIG9mIHRoZSBtYXAgaW4gdGlsZXNcbiAgICAqIEB0eXBlIE51bWJlclxuICAgICovXG4gICB0aGlzLndpZHRoID0gbWFwTm9kZS5hdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAvKipcbiAgICAqIEhlaWdodCBvZiB0aGUgbWFwIGluIHRpbGVzXG4gICAgKiBAdHlwZSBOdW1iZXJcbiAgICAqL1xuICAgdGhpcy5oZWlnaHQgPSBtYXBOb2RlLmF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG5cbiAgIHZhciBvcmllbnRhdGlvbiA9IG1hcE5vZGUuYXR0cmlidXRlKCdvcmllbnRhdGlvbicpO1xuICAgaWYgKG9yaWVudGF0aW9uICE9PSAnb3J0aG9nb25hbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBvcnRob2dvbm9sIG1hcHMgc3VwcG9ydGVkJyk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3VzdG9tIHByb3BlcnRpZXMgb2YgdGhlIG1hcFxuICAgICovXG4gICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgIHNldFByb3BlcnRpZXModGhpcy5wcm9wZXJ0aWVzLCBtYXBOb2RlKTtcblxuICAgLyoqXG4gICAgKiBBbGwgdGlsZXMgb2YgdGhpcyBtYXAuXG4gICAgKiBAdHlwZSB7VGlsZVNldH1cbiAgICAqL1xuICAgdGhpcy50aWxlcyA9IG5ldyBUaWxlU2V0cyhtYXBOb2RlLCB1cmwpO1xuICAgdGhpcy5sYXllcnMgPSBsb2FkTGF5ZXJzKG1hcE5vZGUpO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEEgVGlsZS4gQ2FuIG5vdCBiZSBpbnN0YW50aWF0ZWQuIEdldCBhIFRpbGUgYnkgY2FsbGluZyBgZ2V0VGlsZShnaWQpYFxuICogb24gYSBgVGlsZVNldHNgIGluc3RhbmNlLlxuICovXG52YXIgVGlsZSA9IGV4cG9ydHMuVGlsZSA9IGZ1bmN0aW9uKCkge1xuICAgLyoqXG4gICAgKiBAdHlwZSB7Z2FtZWpzLmdyYXBoaWNzLlN1cmZhY2V9XG4gICAgKi9cbiAgIHRoaXMuc3VyZmFjZSA9IG51bGw7XG4gICAvKipcbiAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgKi9cbiAgIHRoaXMucHJvcGVydGllcyA9IG51bGw7XG4gICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYmUgaW5zdGFudGlhdGVkLicpO1xufTtcblxuLyoqXG4gKiBBIFRpbGVTZXRzIGluc3RhbmNlIGhvbGRzIGFsbCB0aWxlc2V0cyBvZiBhIG1hcC4gVGhpcyBjbGFzc1xuICogbWFrZXMgaXQgZWFzeSB0byBnZXQgdGhlIGltYWdlIGZvciBhIGNlcnRhaW4gdGlsZSBJRC4gWW91IHVzdWFsbHlcbiAqIGRvbid0IGNhcmUgYWJvdXQgaW4gd2hpY2ggc3BlY2lmaWMgVGlsZVNldCBhbiBpbWFnZSBpcyBzbyB0aGlzXG4gKiBjbGFzcyBob2xkcyB0aGVtIGFsbCBhbmQgZGVhbHMgd2l0aCB0aGUgbG9va3VwLlxuICpcbiAqIFlvdSBkb24ndCB1c3VhbGx5IGNyZWF0ZSBhIGBUaWxlU2V0c2AgaW5zdGFuY2UgeW91cnNlbGYsIGluc3RlYWRcbiAqIGl0IGlzIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBhbmQgYXR0YWNoZWQgdG8gYSBgTWFwYC5cbiAqL1xudmFyIFRpbGVTZXRzID0gZXhwb3J0cy5UaWxlU2V0cyA9IGZ1bmN0aW9uKG1hcE5vZGUsIG1hcFVybCkge1xuICAgdmFyIHRpbGVTZXRzID0gW107XG5cbiAgIC8qKlxuICAgICogUmV0cmlldmUgdGhlIGltYWdlIGZvciBhIHRpbGUgSUQgKGdpZCkuXG4gICAgKlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGdpZCBnbG9iYWwgdGlsZSBpZCB0byByZXRyaWV2ZVxuICAgICogQHJldHVybnMge2dhbWVqcy5ncmFwaGljcy5TdXJmYWNlfSB0aGUgU3VyZmFjZSBmb3IgdGhlIGdpZFxuICAgICovXG4gICB0aGlzLmdldFN1cmZhY2UgPSBmdW5jdGlvbihnaWQpIHtcbiAgICAgIHZhciB0aWxlID0gdGhpcy5nZXRUaWxlKGdpZCk7XG4gICAgICByZXR1cm4gdGlsZSAmJiB0aWxlLnN1cmZhY2UgfHwgbnVsbDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGdpZCBnbG9iYWwgdGlsZSBpZFxuICAgICogQHJldHVybnMge09iamVjdH0gdGhlIGN1c3RvbSBwcm9wZXJ0aWVzIG9mIHRoaXMgdGlsZVxuICAgICovXG4gICB0aGlzLmdldFByb3BlcnRpZXMgPSBmdW5jdGlvbihnaWQpIHtcbiAgICAgIHZhciB0aWxlID0gdGhpcy5nZXRUaWxlKGdpZCk7XG4gICAgICByZXR1cm4gdGlsZSAmJiB0aWxlLnByb3BlcnRpZXMgfHwge307XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBnaWQgZ2xvYmFsIHRpbGUgaWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBUaWxlIG9iamVjdCBmb3IgdGhpcyBnaWRcbiAgICAqL1xuICAgdGhpcy5nZXRUaWxlID0gZnVuY3Rpb24oZ2lkKSB7XG4gICAgICB2YXIgdGlsZSA9IG51bGw7XG4gICAgICB0aWxlU2V0cy5zb21lKGZ1bmN0aW9uKHRpbGVTZXQsIGlkeCkge1xuICAgICAgICAgaWYgKHRpbGVTZXQuZmlyc3RHaWQgPD0gZ2lkKSB7XG4gICAgICAgICAgICB0aWxlID0gdGlsZVNldC50aWxlc1tnaWQgLSB0aWxlU2V0LmZpcnN0R2lkXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICByZXR1cm4gdGlsZTtcbiAgIH07XG5cbiAgIHZhciBsb2FkVGlsZVNldCA9IGZ1bmN0aW9uKHRpbGVTZXROb2RlKSB7XG4gICAgICB2YXIgdGlsZXMgPSBbXTtcbiAgICAgIHZhciB0aWxlV2lkdGggPSB0aWxlU2V0Tm9kZS5hdHRyaWJ1dGUoJ3RpbGV3aWR0aCcpO1xuICAgICAgdmFyIHRpbGVIZWlnaHQgPSB0aWxlU2V0Tm9kZS5hdHRyaWJ1dGUoJ3RpbGVoZWlnaHQnKTtcbiAgICAgIHZhciBzcGFjaW5nID0gdGlsZVNldE5vZGUuYXR0cmlidXRlKCdzcGFjaW5nJykgfHwgMDtcbiAgICAgIC8vIGJyb2tlbiBpbiB0aWxlZD9cbiAgICAgIHZhciBtYXJnaW4gPSAwO1xuXG4gICAgICB2YXIgaW1hZ2VOb2RlID0gdGlsZVNldE5vZGUuZWxlbWVudCgnaW1hZ2UnKTtcbiAgICAgIHZhciBpbWFnZUF0bGFzRmlsZSA9IGltYWdlTm9kZS5hdHRyaWJ1dGUoJ3NvdXJjZScpO1xuICAgICAgdmFyIGltYWdlVXJsID0gdXJpLm1ha2VSZWxhdGl2ZSh1cmkucmVzb2x2ZShtYXBVcmwsIGltYWdlQXRsYXNGaWxlKSk7XG4gICAgICB2YXIgYXRsYXMgPSBnYW1lanMuaW1hZ2UubG9hZChpbWFnZVVybCk7XG4gICAgICAvLyBGSVhNRSBzZXQgdHJhbnNwYXJlbmN5IGlmIGltYWdlTm9kZS5hdHRyaWJ1dGUoJ3RyYW5zJykgaXMgc2V0XG5cbiAgICAgIHZhciB0aWxlTm9kZXMgPSB0aWxlU2V0Tm9kZS5lbGVtZW50cygndGlsZScpO1xuICAgICAgdmFyIGRpbXMgPSBhdGxhcy5nZXRTaXplKCk7XG4gICAgICB2YXIgaW1nU2l6ZSA9IG5ldyBnYW1lanMuUmVjdChbMCwwXSwgW3RpbGVXaWR0aCwgdGlsZUhlaWdodF0pO1xuICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICB2YXIgeSA9IDA7XG4gICAgICB3aGlsZSAoeSArIHRpbGVIZWlnaHQgPD0gZGltc1sxXSkge1xuICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgd2hpbGUgKHggKyB0aWxlV2lkdGggPD0gZGltc1swXSkge1xuICAgICAgICAgICAgdmFyIHRpbGVJbWFnZSA9IG5ldyBnYW1lanMuZ3JhcGhpY3MuU3VyZmFjZSh0aWxlV2lkdGgsIHRpbGVIZWlnaHQpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ2FtZWpzLlJlY3QoW3gsIHldLCBbdGlsZVdpZHRoLCB0aWxlSGVpZ2h0XSk7XG4gICAgICAgICAgICB0aWxlSW1hZ2UuYmxpdChhdGxhcywgaW1nU2l6ZSwgcmVjdCk7XG4gICAgICAgICAgICB2YXIgdGlsZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHdpdGhpbiBsb29wXG4gICAgICAgICAgICB0aWxlTm9kZXMuc29tZShmdW5jdGlvbih0aWxlTm9kZSkge1xuICAgICAgICAgICAgICAgaWYgKHRpbGVOb2RlLmF0dHJpYnV0ZSgnaWQnKSA9PT0gaWR4KSB7XG4gICAgICAgICAgICAgICAgICBzZXRQcm9wZXJ0aWVzKHRpbGVQcm9wZXJ0aWVzLCB0aWxlTm9kZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiAgICAgICAgICAgIHRpbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgc3VyZmFjZTogdGlsZUltYWdlLFxuICAgICAgICAgICAgICAgcHJvcGVydGllczogdGlsZVByb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeCArPSB0aWxlV2lkdGggKyBzcGFjaW5nO1xuICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICB9XG4gICAgICAgICB5ICs9IHRpbGVIZWlnaHQgKyBzcGFjaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpbGVzO1xuICAgfTtcblxuICAgLyoqXG4gICAgKlxuICAgICogY29uc3RydWN0b3JcbiAgICAqKi9cbiAgIG1hcE5vZGUuZWxlbWVudHMoJ3RpbGVzZXQnKS5mb3JFYWNoKGZ1bmN0aW9uKHRpbGVTZXROb2RlKSB7XG4gICAgICB2YXIgZmlyc3RHaWQgPSB0aWxlU2V0Tm9kZS5hdHRyaWJ1dGUoJ2ZpcnN0Z2lkJyk7XG4gICAgICB2YXIgZXh0ZXJuYWxTb3VyY2UgPSB0aWxlU2V0Tm9kZS5hdHRyaWJ1dGUoJ3NvdXJjZScpO1xuICAgICAgaWYgKGV4dGVybmFsU291cmNlKSB7XG4gICAgICAgICB2YXIgdGlsZVNldERvY3VtZW50ID0geG1sLkRvY3VtZW50LmZyb21VUkwodXJpLnJlc29sdmUobWFwVXJsLCBleHRlcm5hbFNvdXJjZSkpO1xuICAgICAgICAgdGlsZVNldE5vZGUgPSB0aWxlU2V0RG9jdW1lbnQuZWxlbWVudCgndGlsZXNldCcpO1xuICAgICAgfVxuICAgICAgdGlsZVNldHMucHVzaCh7XG4gICAgICAgICB0aWxlczogbG9hZFRpbGVTZXQodGlsZVNldE5vZGUpLFxuICAgICAgICAgZmlyc3RHaWQ6IGZpcnN0R2lkXG4gICAgICB9KTtcbiAgIH0pO1xuICAgdGlsZVNldHMucmV2ZXJzZSgpO1xuXG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogbG9hZExheWVyc1xuICovXG52YXIgSF9GTElQID0gMHg4MDAwMDAwMDtcbnZhciBWX0ZMSVAgPSAweDQwMDAwMDAwO1xudmFyIGxvYWRMYXllcnMgPSBmdW5jdGlvbihtYXBOb2RlKSB7XG4gICB2YXIgbGF5ZXJzID0gW107XG5cbiAgIHZhciBnZXRHaWRzID0gZnVuY3Rpb24obGF5ZXJOb2RlKSB7XG4gICAgICB2YXIgZGF0YU5vZGUgPSBsYXllck5vZGUuZWxlbWVudCgnZGF0YScpO1xuICAgICAgdmFyIGVuY29kaW5nID0gZGF0YU5vZGUuYXR0cmlidXRlKCdlbmNvZGluZycpO1xuICAgICAgdmFyIGNvbXByZXNzaW9uID0gZGF0YU5vZGUuYXR0cmlidXRlKCdjb21wcmVzc2lvbicpO1xuICAgICAgdmFyIGRhdGEgPSBcIlwiO1xuICAgICAgZGF0YU5vZGUuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uKHRleHROb2RlKSB7XG4gICAgICAgICBkYXRhICs9IHRleHROb2RlLnZhbHVlKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBieXRlRGF0YSA9IFtdO1xuICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgaWYgKGNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXByZXNzaW9uIG9mIG1hcCBkYXRhIHVuc3VwcG9ydGVkJyk7XG4gICAgICAgICB9XG4gICAgICAgICBieXRlRGF0YSA9IGJhc2U2NC5kZWNvZGVBc0FycmF5KGRhdGEsIDQpO1xuICAgICAgfSBlbHNlIGlmIChlbmNvZGluZyA9PT0gJ2NzdicpIHtcbiAgICAgICAgIGRhdGEudHJpbSgpLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgcm93LnNwbGl0KCcsJywgd2lkdGgpLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgIGJ5dGVEYXRhLnB1c2gocGFyc2VJbnQoZW50cnksIDEwKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIC8vIEZJWE1FIGluZGl2aWR1YWwgWE1MIHRpbGUgZWxlbWVudHNcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5kaXZpZHVhbCB0aWxlIGZvcm1hdCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZURhdGE7XG4gICB9O1xuXG4gICB2YXIgd2lkdGggPSBtYXBOb2RlLmF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgIHZhciBoZWlnaHQgPSBtYXBOb2RlLmF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gICBtYXBOb2RlLmVsZW1lbnRzKCdsYXllcicpLmZvckVhY2goZnVuY3Rpb24obGF5ZXJOb2RlKSB7XG4gICAgICAvLyBjcmVhdGUgZW1wdHkgZ2lkIG1hdHJpeFxuICAgICAgdmFyIGdpZE1hdHJpeCA9IFtdO1xuICAgICAgdmFyIGkgPSBoZWlnaHQ7XG4gICAgICB3aGlsZSAoaS0tPjApIHtcbiAgICAgICAgIHZhciBqID0gd2lkdGg7XG4gICAgICAgICBnaWRNYXRyaXhbaV0gPSBbXTtcbiAgICAgICAgIHdoaWxlIChqLS0+MCkge1xuICAgICAgICAgICAgZ2lkTWF0cml4W2ldW2pdID0gMDtcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2V0R2lkcyhsYXllck5vZGUpLmZvckVhY2goZnVuY3Rpb24oZ2lkLCBpZHgpIHtcbiAgICAgICAgIC8vIEZJWE1FIGZsaXBYL1kgY3VycmVudGx5IGlnbm9yZWRcbiAgICAgICAgIHZhciBmbGlwWCA9IGdpZCAmIEhfRkxJUDtcbiAgICAgICAgIHZhciBmbGlwWSA9IGdpZCAmIFZfRkxJUDtcbiAgICAgICAgIC8vIGNsZWFyIGZsYWdzXG4gICAgICAgICBnaWQgJj0gfihIX0ZMSVAgfCBWX0ZMSVApO1xuICAgICAgICAgZ2lkTWF0cml4W3BhcnNlSW50KGlkeCAvIHdpZHRoLCAxMCldW3BhcnNlSW50KGlkeCAlIHdpZHRoLCAxMCldID0gZ2lkO1xuICAgICAgfSk7XG4gICAgICBsYXllcnMucHVzaCh7XG4gICAgICAgICBnaWRzOiBnaWRNYXRyaXgsXG4gICAgICAgICBvcGFjaXR5OiBsYXllck5vZGUuYXR0cmlidXRlKCdvcGFjaXR5JyksXG4gICAgICAgICB2aXNpYmxlOiBsYXllck5vZGUuYXR0cmlidXRlKCd2aXNpYmxlJyksXG4gICAgICAgICBwcm9wZXJ0aWVzOiBzZXRQcm9wZXJ0aWVzKHt9LCBsYXllck5vZGUpXG4gICAgICB9KTtcbiAgIH0pO1xuICAgcmV0dXJuIGxheWVycztcbn07XG5cbi8qKlxuICogc2V0IGdlbmVyaWMgPHByb3BlcnRpZXM+PHByb3BlcnR5IG5hbWU9XCJcIiB2YWx1ZT1cIlwiPi4uLiBvbiBnaXZlbiBvYmplY3RcbiAqL1xudmFyIHNldFByb3BlcnRpZXMgPSBmdW5jdGlvbihvYmplY3QsIG5vZGUpIHtcbiAgIHZhciBwcm9wcyA9IG5vZGUuZWxlbWVudCgncHJvcGVydGllcycpO1xuICAgaWYgKCFwcm9wcykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgcHJvcHMuZWxlbWVudHMoJ3Byb3BlcnR5JykuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eU5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcGVydHlOb2RlLmF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcGVydHlOb2RlLmF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgfSk7XG4gICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKipcbiAqIEZJWE1FIGV4cGxhaW4gdmlld1JlY3QgKGNoYW5nZSBpdCB0byBzcm9sbCEpIGFuZCBpbWFnZSwgbWFwSW1hZ2UgYW5kIGhvdyB0byB1cGRhdGUsIHJlZHJhd1xuICovXG52YXIgTWFwVmlldyA9IGV4cG9ydHMuTWFwVmlldyA9IGZ1bmN0aW9uKG1hcCkge1xuXG4gICAgdGhpcy50aW1lb3V0ID0gMDtcblxuICAgIHRoaXMubGF5ZXJWaWV3cyA9IG1hcC5sYXllcnMubWFwKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICByZXR1cm4gbmV3IExheWVyVmlldyhsYXllciwge1xuICAgICAgICAgdGlsZVdpZHRoOiBtYXAudGlsZVdpZHRoLFxuICAgICAgICAgdGlsZUhlaWdodDogbWFwLnRpbGVIZWlnaHQsXG4gICAgICAgICB3aWR0aDogbWFwLndpZHRoLFxuICAgICAgICAgaGVpZ2h0OiBtYXAuaGVpZ2h0LFxuICAgICAgICAgdGlsZXM6IG1hcC50aWxlc1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy52aWV3UmVjdCA9IG5ldyBnYW1lanMuUmVjdChbMCwwXSwgW21hcC53aWR0aCAqIG1hcC50aWxlV2lkdGgsIG1hcC5oZWlnaHQqbWFwLnRpbGVXaWR0aF0pO1xuICAgIHRoaXMuaW1hZ2UgPSBuZXcgZ2FtZWpzLmdyYXBoaWNzLlN1cmZhY2UoW3RoaXMudmlld1JlY3Qud2lkdGgsIHRoaXMudmlld1JlY3QuaGVpZ2h0XSk7XG4gICAgdGhpcy5tYXBJbWFnZSA9IHRoaXMuaW1hZ2UuY2xvbmUoKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuTWFwVmlldy5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sYXllclZpZXdzLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuZHJhdyh0aGlzLm1hcEltYWdlKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbk1hcFZpZXcucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihkaXNwbGF5LCBvZmZzZXQpIHtcbiAgZGlzcGxheS5ibGl0KHRoaXMubWFwSW1hZ2UsIG9mZnNldCB8fCBbMCwwXSwgdGhpcy52aWV3UmVjdCk7XG59O1xuXG5cblxuLyoqXG4gKiBMYXllclZpZXdcbiAqIFJlbmRlcnMgdGhlIGxheWVyIHRvIGEgYmlnIHN1cmZhY2UuXG4gKi9cbnZhciBMYXllclZpZXcgPSBleHBvcnRzLkxheWVyVmlldyA9IGZ1bmN0aW9uKGxheWVyLCBvcHRzKSB7XG5cbiAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uKGRpc3BsYXkpIHtcbiAgICAgIGRpc3BsYXkuYmxpdCh0aGlzLnN1cmZhY2UpO1xuICAgfTtcbiAgIC8qKlxuICAgICogY29uc3RydWN0b3JcbiAgICAqL1xuICAgdGhpcy5zdXJmYWNlID0gbmV3IGdhbWVqcy5ncmFwaGljcy5TdXJmYWNlKG9wdHMud2lkdGggKiBvcHRzLnRpbGVXaWR0aCwgb3B0cy5oZWlnaHQgKiBvcHRzLnRpbGVIZWlnaHQpO1xuICAgdGhpcy5zdXJmYWNlLnNldEFscGhhKGxheWVyLm9wYWNpdHkpO1xuXG4gICAvKipcbiAgICAqIE5vdGUgaG93IGJlbG93IHdlIGxvb2sgdXAgdGhlIFwiZ2lkXCIgb2YgdGhlIHRpbGUgaW1hZ2VzIGluIHRoZSBUaWxlU2V0IGZyb20gdGhlIE1hcFxuICAgICogKCdvcHQudGlsZXMnKSB0byBnZXQgdGhlIGFjdHVhbCBTdXJmYWNlcy5cbiAgICAqL1xuICAgbGF5ZXIuZ2lkcy5mb3JFYWNoKGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24oZ2lkLCBqKSB7XG4gICAgICAgICBpZiAoZ2lkID09PTApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIHRpbGVTdXJmYWNlID0gb3B0cy50aWxlcy5nZXRTdXJmYWNlKGdpZCk7XG4gICAgICAgICBpZiAodGlsZVN1cmZhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuc3VyZmFjZS5ibGl0KHRpbGVTdXJmYWNlLFxuICAgICAgICAgICAgICAgbmV3IGdhbWVqcy5SZWN0KFtqICogb3B0cy50aWxlV2lkdGgsIGkgKiBvcHRzLnRpbGVIZWlnaHRdLCBbb3B0cy50aWxlV2lkdGgsIG9wdHMudGlsZUhlaWdodF0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdhbWVqcy5sb2coJ25vIGdpZCAnLCBnaWQsIGksIGosICdsYXllcicsIGkpO1xuICAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICB9LCB0aGlzKTtcbiAgIHJldHVybiB0aGlzO1xufTtcblxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBPbmx5IHVzZWQgYnkgR2FtZUpzIGludGVybmFsbHkgdG8gcHJvdmlkZSBhIGdhbWUgbG9vcC5cbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgQ2FsbGJhY2sgPSByZXF1aXJlKCcuL3V0aWxzL2NhbGxiYWNrJykuQ2FsbGJhY2s7XG5cbnZhciBUSU1FUl9MQVNUQ0FMTCA9IG51bGw7XG52YXIgU1RBUlRUSU1FID0gbnVsbDtcblxuLyoqIEBpZ25vcmUgKiovXG52YXIgX0NBTExCQUNLUyA9IGV4cG9ydHMuX0NBTExCQUNLUyA9IFtdO1xuLy8gYHdpbmRvd2AgaXMgbm90IGFjY2Vzc2libGUgaW4gd2Vid29ya2VyICh3b3VsZCBsZWFkIHRvIFR5cGVFcnJvcilcbi8vIEBAIHRoaXMgY3Jvc3MtYnJvd3NlciBmdWNrZXJ5IGhhcyB0byBnbyBhd2F5IEFTQVAuXG52YXIgcmVxQW5pbWF0aW9uRnJhbWUgPSB0eXBlb2Yod2luZG93KSAhPSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsIDogbnVsbDtcblxudmFyIHJlcUFuaUZyYW1lUmVjdXJzaXZlID0gZnVuY3Rpb24oKSB7XG4gICBwZXJJbnRlcnZhbCgpO1xuICAgcmVxQW5pbWF0aW9uRnJhbWUocmVxQW5pRnJhbWVSZWN1cnNpdmUpO1xufTtcblxudmFyIHRyaWdnZXJDYWxsYmFja3MgPSBmdW5jdGlvbihtc0R1cmF0aW9uKSB7XG4gICBfQ0FMTEJBQ0tTLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgYy50cmlnZ2VyKG1zRHVyYXRpb24pO1xuICAgfSk7XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICBTVEFSVFRJTUUgPSBEYXRlLm5vdygpO1xuXG4gICBpZiAocmVxQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlcUFuaW1hdGlvbkZyYW1lKHJlcUFuaUZyYW1lUmVjdXJzaXZlKTtcbiAgIH0gZWxzZSB7XG4gICAgICBzZXRJbnRlcnZhbChwZXJJbnRlcnZhbCwgMTApO1xuICAgfVxuICAgcmV0dXJuO1xufTtcblxudmFyIHBlckludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgbXNOb3cgPSBEYXRlLm5vdygpO1xuICAgdHJpZ2dlckNhbGxiYWNrcyhtc05vdyAtIChUSU1FUl9MQVNUQ0FMTCB8fCBtc05vdykpO1xuICAgVElNRVJfTEFTVENBTEwgPSBtc05vdztcbiAgIHJldHVybjtcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBPYmllY3RzXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXR1cm5zIHJlbW92ZWQgaXRlbSBvciBudWxsXG4gKi9cblxuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbihpdGVtLCBhcnJheSkge1xuICAgdmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBhcnJheS5zcGxpY2UoYXJyYXkuaW5kZXhPZihpdGVtKSwgMSk7XG4gICB9XG4gICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU2h1ZmZsZXMgdGhlIGFycmF5ICppbiBwbGFjZSouXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyJUUyJTgwJTkzWWF0ZXNfc2h1ZmZsZVxuICovXG5leHBvcnRzLnNodWZmbGUgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGggLTE7XG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA+IDA7IGktLSkge1xuICAgICAgICB2YXIgaWR4ID0gcGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIChpICsgMSksIDEwKTtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpZHhdO1xuICAgICAgICBhcnJheVtpZHhdID0gaXRlbTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlld1xuICogQmFzZTY0IGVuY29kZSAvIGRlY29kZVxuICogQGF1dGhvciBodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mb1xuICovXG5cblxudmFyIGtleVN0ciA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgc3RyaW5nLlxuICovXG52YXIgZGVjb2RlID0gZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgdmFyIG91dHB1dCA9IFtdLCBjaHIxLCBjaHIyLCBjaHIzLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0LCBpID0gMDtcbiAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csIFwiXCIpO1xuXG4gICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgZW5jMSA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgIGVuYzIgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICBlbmMzID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgZW5jNCA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcblxuICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuXG4gICAgICBvdXRwdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpKTtcblxuICAgICAgaWYgKGVuYzMgIT0gNjQpIHtcbiAgICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMikpO1xuICAgICAgfVxuICAgICAgaWYgKGVuYzQgIT0gNjQpIHtcbiAgICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMykpO1xuICAgICAgfVxuICAgfVxuXG4gICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIGludG8gYSBieXRlIGFycmF5XG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7QXJyYXl9IGJ5dGVzIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGRlZmF1bHRzIHRvIDFcbiAqL1xuZXhwb3J0cy5kZWNvZGVBc0FycmF5ID0gZnVuY3Rpb24oaW5wdXQsIGJ5dGVzKSB7XG4gICBieXRlcyA9IGJ5dGVzIHx8IDE7XG4gICB2YXIgZGVjb2RlZCA9IGRlY29kZShpbnB1dCk7XG4gICB2YXIgbGVuID0gZGVjb2RlZC5sZW5ndGggLyBieXRlcztcbiAgIHZhciBhcnJheSA9IFtdO1xuICAgdmFyIGksajtcbiAgIGZvciAoaT0wOyBpPCBsZW47IGkrKykge1xuICAgICAgYXJyYXlbaV0gPSAwO1xuICAgICAgZm9yIChqID0gYnl0ZXMgLSAxOyBqID49MDsgLS1qKSB7XG4gICAgICAgICBhcnJheVtpXSArPSBkZWNvZGVkLmNoYXJDb2RlQXQoKGkgKiBieXRlcykgKyBqKSA8PCAoaiA8PDMgKTtcbiAgICAgIH1cbiAgIH1cbiAgIHJldHVybiBhcnJheTtcbn1cbjsiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIE1hbmFnZSBhIGNhbGxiYWNrIHdpdGggaW52b2NhdGlvbiBzY29wZS4gVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnkgR2FtZUpzIGJ1dCBtaWdodCBiZSB1c2VmdWwgZm9yIG90aGVycy5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgd2l0aCB3aGljaCB0aGUgY2FsbGJhY2sgd2lsbCBiZSB0cmlnZ2VyZWRcbiAqL1xudmFyIENhbGxiYWNrID0gZXhwb3J0cy5DYWxsYmFjayA9IGZ1bmN0aW9uKGZuLCBzY29wZSkge1xuXHR0aGlzLmZuID0gZm47XG5cdHRoaXMuZm5TY29wZSA9IHNjb3BlIHx8IHt9O1xuXHRyZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEFueSBhcmd1bWVudHMgcGFzc2VkIHRvIGB0cmlnZ2VyYCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG4gKi9cbkNhbGxiYWNrLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuZm4uYXBwbHkodGhpcy5mblNjb3BlLCBhcmd1bWVudHMpO1xufTsiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBPYmplY3RzXG4gKi9cblxuLyoqXG4gKiBQdXQgYSBwcm90b3R5cGUgaW50byB0aGUgcHJvdG90eXBlIGNoYWluIG9mIGFub3RoZXIgcHJvdG90eXBlLlxuICogQHBhcmFtIHtPYmplY3R9IHN1YkNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gc3VwZXJDbGFzc1xuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICBpZiAoc3ViQ2xhc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHN1YkNsYXNzJyk7XG4gICB9XG4gICBpZiAoc3VwZXJDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc3VwZXJDbGFzcycpO1xuICAgfVxuICAgdmFyIEY7XG4gICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICBGID0gbmV3IEZ1bmN0aW9uKCk7XG4gICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICBGLnByb3RvdHlwZSA9IHN1cGVyQ2xhc3MucHJvdG90eXBlO1xuICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IG5ldyBGKCk7XG4gICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgIHN1YkNsYXNzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzLnByb3RvdHlwZTtcbiAgIHN1YkNsYXNzLnN1cGVyQ29uc3RydWN0b3IgPSBzdXBlckNsYXNzO1xuICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBhcyB0aGUgYXMgdGhlIGtleXdpc2UgdW5pb24gb2YgdGhlIHByb3ZpZGVkIG9iamVjdHMuXG4gKiBXaGVuZXZlciBhIGtleSBleGlzdHMgaW4gYSBsYXRlciBvYmplY3QgdGhhdCBhbHJlYWR5IGV4aXN0ZWQgaW4gYW4gZWFybGllclxuICogb2JqZWN0LCB0aGUgYWNjb3JkaW5nIHZhbHVlIG9mIHRoZSBlYXJsaWVyIG9iamVjdCB0YWtlcyBwcmVjZWRlbmNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9iai4uLiBUaGUgb2JqZWN0cyB0byBtZXJnZVxuICovXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgcmVzdWx0ID0ge307XG4gICB2YXIgaSwgcHJvcGVydHk7XG4gICAgICBmb3IgKGkgPSBhcmd1bWVudHMubGVuZ3RoOyBpID4gMDsgLS1pKSB7XG4gICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2kgLSAxXTtcbiAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0gb2JqW3Byb3BlcnR5XTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIGZhbGxiYWNrIGZvciBPYmplY3Qua2V5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIG93biBwcm9wZXJ0aWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9rZXlzXG4gKi9cbnZhciBrZXlzID0gZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgfVxuXG4gICB2YXIgcmV0PVtdLHA7XG4gICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgICBpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwKSkge1xuICAgICAgICAgcmV0LnB1c2gocCk7XG4gICAgICB9XG4gICB9XG4gICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgb2JqZWN0IGFjY2Vzc29yc1xuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldFxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZGVmaW5lUHJvcGVydHlcbiAqL1xudmFyIGFjY2Vzc29yID0gZXhwb3J0cy5hY2Nlc3NvciA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZSwgZ2V0LCBzZXQpIHtcbiAgIC8vIEVDTUE1XG4gICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgIGdldDogZ2V0LFxuICAgICAgICAgc2V0OiBzZXRcbiAgICAgIH0pO1xuICAgLy8gbm9uLXN0YW5kYXJkXG4gICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYmplY3QuX19kZWZpbmVHZXR0ZXJfXyhuYW1lLCBnZXQpO1xuICAgICAgaWYgKHNldCkge1xuICAgICAgICAgb2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18obmFtZSwgc2V0KTtcbiAgICAgIH1cbiAgIH1cblx0cmV0dXJuO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gZGVmaW5lIG9yIG1vZGlmeSBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEFuIG9iamVjdCB3aG9zZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGNvbnN0aXR1dGUgZGVzY3JpcHRvcnMgZm9yIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQgb3IgbW9kaWZpZWQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9kZWZpbmVQcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydHMuYWNjZXNzb3JzID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICAga2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbihwcm9wS2V5KSB7XG4gICAgICBhY2Nlc3NvcihvYmplY3QsIHByb3BLZXksIHByb3BzW3Byb3BLZXldLmdldCwgcHJvcHNbcHJvcEtleV0uc2V0KTtcbiAgIH0pO1xuICAgcmV0dXJuO1xufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBXb3JraW5nIHdpdGggc3RyaW5nc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSBsb25nZXN0IGNvbW1vbiBzZWdtZW50IHRoYXQgdHdvIHN0cmluZ3NcbiAqIGhhdmUgaW4gY29tbW9uLCBzdGFydGluZyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIxIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyMiBhbm90aGVyIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gdGhlIGxvbmdlc3QgY29tbW9uIHNlZ21lbnRcbiAqL1xuZXhwb3J0cy5nZXRDb21tb25QcmVmaXggPSBmdW5jdGlvbiBnZXRDb21tb25QcmVmaXgoc3RyMSwgc3RyMikge1xuICAgIGlmIChzdHIxID09PSBudWxsIHx8IHN0cjIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChzdHIxLmxlbmd0aCA+IHN0cjIubGVuZ3RoICYmIHN0cjEuaW5kZXhPZihzdHIyKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyMjtcbiAgICB9IGVsc2UgaWYgKHN0cjIubGVuZ3RoID4gc3RyMS5sZW5ndGggJiYgc3RyMi5pbmRleE9mKHN0cjEpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHIxO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc3RyMS5sZW5ndGgsIHN0cjIubGVuZ3RoKTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cjFbaV0gIT0gc3RyMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjEuc2xpY2UoMCwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjEuc2xpY2UoMCwgbGVuZ3RoKTtcbn07IiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFV0aWxpZXMgZm9yIFVSSSBoYW5kbGluZy5cbiAqXG4gKi9cblxudmFyIFVSSV9SRUdFWCA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICtcbiAgICAnKD86JyArXG4gICAgICAnKFteOi8/Iy5dKyknICsgICAgICAgICAgICAgICAgICAgICAvLyBzY2hlbWUgLSBpZ25vcmUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VkIGJ5IG90aGVyIFVSTCBwYXJ0cyBzdWNoIGFzIDosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA/LCAvLCAjLCBhbmQgLlxuICAgICc6KT8nICtcbiAgICAnKD86Ly8nICtcbiAgICAgICcoPzooW14vPyNdKilAKT8nICsgICAgICAgICAgICAgICAgIC8vIHVzZXJJbmZvXG4gICAgICAnKFtcXFxcd1xcXFxkXFxcXC1cXFxcdTAxMDAtXFxcXHVmZmZmLiVdKiknICsgLy8gZG9tYWluIC0gcmVzdHJpY3QgdG8gbGV0dGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0cywgZGFzaGVzLCBkb3RzLCBwZXJjZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGVzLCBhbmQgdW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgICAgJyg/OjooWzAtOV0rKSk/JyArICAgICAgICAgICAgICAgICAgLy8gcG9ydFxuICAgICcpPycgK1xuICAgICcoW14/I10rKT8nICsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF0aFxuICAgICcoPzpcXFxcPyhbXiNdKikpPycgKyAgICAgICAgICAgICAgICAgICAvLyBxdWVyeVxuICAgICcoPzojKC4qKSk/JyArICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ21lbnRcbiAgICAnJCcpO1xuXG4vKipcbiAqIFJlc29sdmUgcGF0aCBhZ2FpbnN0IFVSSS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byByZXNvbHZlXG4gKi9cbnZhciByZXNvbHZlID0gZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24odXJpLCBwYXRoKSB7XG4gICB2YXIgbSA9IG1hdGNoKHVyaSk7XG4gICB2YXIgbiA9IG1hdGNoKHBhdGgpO1xuICAgdmFyIGhvc3QgPSBtWzFdICsgJzovLycgKyBtWzNdO1xuICAgaWYgKG5bMV0pIHtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgfVxuICAgaWYgKG1bNF0pIHtcbiAgICAgIGhvc3QgPSBob3N0ICsgXCI6XCIgKyBtWzRdO1xuICAgfVxuICAgdmFyIGFic29sdXRlUGF0aCA9IG1bNV07XG4gICBpZiAocGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgdmFyIGxhc3RTbGFzaEluZGV4ID0gYWJzb2x1dGVQYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICBhYnNvbHV0ZVBhdGggPSBhYnNvbHV0ZVBhdGguc3Vic3RyKDAsIGxhc3RTbGFzaEluZGV4ICsgMSkgKyBwYXRoO1xuICAgfSBlbHNlIHtcbiAgICAgIGFic29sdXRlUGF0aCA9IHBhdGg7XG4gICB9XG4gICByZXR1cm4gaG9zdCArIHJlbW92ZURvdFNlZ21lbnRzKGFic29sdXRlUGF0aCk7XG5cbn07XG5cbi8qKlxuICogVHJ5IHRvIG1hdGNoIGFuIFVSSSBhZ2FpbnN0IGEgcmVnZXggcmV0dXJuaW5nIHRoZSBmb2xsb3dpbmdcbiAqIGNhcHR1cmUgZ3JvdXBzOlxuICogICAgICQxID0gaHR0cCAgICAgICAgICAgICAgc2NoZW1lXG4gKiAgICAgJDIgPSA8dW5kZWZpbmVkPiAgICAgICB1c2VySW5mbyAtXFxcbiAqICAgICAkMyA9IHd3dy5pY3MudWNpLmVkdSAgIGRvbWFpbiAgICAgfCBhdXRob3JpdHlcbiAqICAgICAkNCA9IDx1bmRlZmluZWQ+ICAgICAgIHBvcnQgICAgIC0vXG4gKiAgICAgJDUgPSAvcHViL2lldGYvdXJpLyAgICBwYXRoXG4gKiAgICAgJDYgPSA8dW5kZWZpbmVkPiAgICAgICBxdWVyeSB3aXRob3V0ID9cbiAqICAgICAkNyA9IFJlbGF0ZWQgICAgICAgICAgIGZyYWdtZW50IHdpdGhvdXQgI1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqL1xudmFyIG1hdGNoID0gZXhwb3J0cy5tYXRjaCA9IGZ1bmN0aW9uKHVyaSkge1xuICAgcmV0dXJuIHVyaS5tYXRjaChVUklfUkVHRVgpO1xufTtcblxuLyoqXG4gKiBNYWtlIGFuIGFic29sdXRlIFVSSSByZWxhdGl2ZSB0byBkb2N1bWVudC5sb2NhdGlvbi5ocmVmXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAcmV0dXJucyBUaGUgcmVsYXRpdmUgVVJJIG9yIHRoZSB1bmNoYW5nZWQgVVJJIGlmIGl0J3Mgbm90XG4gKiBwb3NzaWJsZSB0byBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBwYXRoIG9mIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYuXG4gKi9cbnZhciBtYWtlUmVsYXRpdmUgPSBleHBvcnRzLm1ha2VSZWxhdGl2ZSA9IGZ1bmN0aW9uKHVyaSkge1xuICAgdmFyIGRvY0xvY1BhdGggPSByZXNvbHZlKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYsICcuLycpO1xuICAgaWYgKHVyaS5pbmRleE9mKGRvY0xvY1BhdGgpID09PSAwKSB7XG4gICAgICB1cmkgPSAnLi8nICsgdXJpLnN1YnN0cmluZyhkb2NMb2NQYXRoLmxlbmd0aCk7XG4gICB9XG4gICByZXR1cm4gdXJpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBpbiBnaXZlbiBwYXRoIGNvbXBvbmVudFxuICovXG52YXIgcmVtb3ZlRG90U2VnbWVudHMgPSBmdW5jdGlvbihwYXRoKSB7XG4gICBpZiAocGF0aCA9PSAnLi4nIHx8IHBhdGggPT0gJy4nKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICB9XG4gICB2YXIgbGVhZGluZ1NsYXNoID0gcGF0aC5pbmRleE9mKCcvJykgPiAtMTtcblxuICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgdmFyIG91dCA9IFtdO1xuXG4gICB2YXIgcG9zO1xuICAgZm9yIChwb3MgPSAwOyBwb3MgPCBzZWdtZW50cy5sZW5ndGg7ICkge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1twb3MrK107XG5cbiAgICAgIGlmIChzZWdtZW50ID09ICcuJykge1xuICAgICAgICAgaWYgKGxlYWRpbmdTbGFzaCAmJiBwb3MgPT0gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQucHVzaCgnJyk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNlZ21lbnQgPT0gJy4uJykge1xuICAgICAgICAgaWYgKG91dC5sZW5ndGggPiAxIHx8IG91dC5sZW5ndGggIT09IDEgJiYgb3V0WzBdICE9PSAnJykge1xuICAgICAgICAgICAgb3V0LnBvcCgpO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKGxlYWRpbmdTbGFzaCAmJiBwb3MgPT0gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQucHVzaCgnJyk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgb3V0LnB1c2goc2VnbWVudCk7XG4gICAgICAgICBsZWFkaW5nU2xhc2ggPSB0cnVlO1xuICAgICAgfVxuICAgfVxuICAgcmV0dXJuIG91dC5qb2luKCcvJyk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKlxuICogUHJvdmlkZXMgZmFjaWxpdGllcyBmb3IgcGFyc2luZyBhIHhtbCBTdHJpbmcuXG4gKlxuICogWW91IHdpbGwgdHlwaWNhbGx5IGdldCBhIGBnYW1lanMueG1sLkRvY3VtZW50YCBpbnN0YW5jZVxuICogYnkgbG9hZGluZyB0aGUgZGF0YSB3aXRoIG9uZSBvZiB0aGUgdHdvIHN0YXRpY1xuICogYERvY3VtZW50LmZyb21TdHJpbmcoc3RyaW5nKWAgb3IgYERvY3VtZW50LmZyb21VcmwodXJsKWAuXG5cbiAqIFF1ZXJ5aW5nIGZvciBgZWxlbWVudHMobmFtZSlgIG9yIGBjaGlsZHJlbigpYCB3aWxsIHJldHVybiBhXG4gKiBuZXcgYGdhbWVqcy54bWwuRG9jdW1lbnRgIG1hdGNoaW5nIHlvdXIgcmVzdWx0IChvciBudWxsKS5cbiAqXG4gKiBVc2UgYGF0dHJpYnV0ZXMobmFtZSlgIGFuZCBgdmFsdWUoKWAgdG8gZ2V0IHRoZSBkYXRhIHN0b3JlZFxuICogaW4gdGhlIFhNTCBEb2N1bWVudC5cbiAqL1xuXG4vKipcbiAqIFhNTFBhcnNlclxuICovXG52YXIgUGFyc2VyID0gZXhwb3J0cy5QYXJzZXIgPSBmdW5jdGlvbigpIHtcblxuICAgdmFyIHhtbERvYyA9IG51bGw7XG4gICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXG4gICB0aGlzLnBhcnNlRnJvbVN0cmluZyA9IGZ1bmN0aW9uKHhtbFN0cmluZykge1xuICAgICAgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcsICd0ZXh0L3htbCcpO1xuICAgICAgcmV0dXJuIHhtbERvYztcbiAgIH07XG5cbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSB3aXRoIHRoZSBzdGF0aWMgZnVuY3Rpb25zIGBEb2N1bWVudC5mcm9tU3RyaW5nKClgIGFuZCBgZnJvbVVSTCgpYC5cbiAqL1xudmFyIERvY3VtZW50ID0gZXhwb3J0cy5Eb2N1bWVudCA9IGZ1bmN0aW9uKHhtbERvY3VtZW50KSB7XG4gICBpZiAoIXhtbERvY3VtZW50IHx8ICgheG1sRG9jdW1lbnQgaW5zdGFuY2VvZiBYTUxEb2N1bWVudCkgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgYSB2YWxpZCB4bWxEb2N1bWVudC4nKTtcbiAgIH1cbiAgIC8qKiBAaWdub3JlICoqL1xuICAgdGhpcy5feG1sRG9jdW1lbnQgPSB4bWxEb2N1bWVudDtcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBjdXJyZW50IGRvY3VtZW50IHdob3NlIHRhZy1uYW1lIG1hdGNoZXNcbiAqIHRoZSBnaXZlbiAnbmFtZScuXG4gKiBAcmV0dXJucyBnYW1lanMueG1sLkRvY3VtZW50XG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24obmFtZSkge1xuICAgdmFyIGVsZW0gPSB0aGlzLl94bWxEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKVswXTtcbiAgIHJldHVybiBlbGVtICYmIG5ldyBEb2N1bWVudChlbGVtKSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBlbGVtZW50cyBpbiB0aGUgY3VycmVudCBkb2N1bWVudCB3aG9zZSB0YWctbmFtZSBtYXRjaGVzXG4gKiB0aGUgZ2l2ZW4gJ25hbWUnLlxuICogQHJldHVybnMgYW4gQXJyYXkgb2YgZ2FtZWpzLnhtbC5Eb2N1bWVudFxuICovXG5Eb2N1bWVudC5wcm90b3R5cGUuZWxlbWVudHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICB2YXIgZWxlbXMgPSB0aGlzLl94bWxEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKTtcbiAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWxlbXMsIFswXSkubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiBuZXcgRG9jdW1lbnQoZWxlbSk7XG4gICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoaXMgZG9jdW1lbnQuXG4gKlxuICogQHJldHVybnMgU3RyaW5nXG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS5hdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICB2YXIgYXR0cmlidXRlVmFsdWUgPSB0aGlzLl94bWxEb2N1bWVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZVZhbHVlID8gYXR0cmlidXRlVmFsdWUudHJpbSgpIDogbnVsbDtcbiAgIGlmIChhdHRyaWJ1dGVWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICB9XG4gICBpZiAoYXR0cmlidXRlVmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbiAgIGlmIChhdHRyaWJ1dGVWYWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnZmFsc2UnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICB2YXIgYXR0cmlidXRlSW50VmFsdWUgPSBwYXJzZUludChhdHRyaWJ1dGVWYWx1ZSwgMTApO1xuICAgdmFyIGF0dHJpYnV0ZUZsb2F0VmFsdWUgPSBwYXJzZUZsb2F0KGF0dHJpYnV0ZVZhbHVlLCAxMCk7XG4gICBpZiAoIWlzTmFOKGF0dHJpYnV0ZUludFZhbHVlKSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZUZsb2F0VmFsdWUgIT09IGF0dHJpYnV0ZUludFZhbHVlKSB7XG4gICAgICAgICByZXR1cm4gYXR0cmlidXRlRmxvYXRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVJbnRWYWx1ZTtcbiAgIH1cbiAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZXZhbHVlIG9mIHRoZSBjdXJyZW50IHhtbCBkb2N1bWVudFxuICogQHJldHVybnMgU3RyaW5nXG4gKi9cbkRvY3VtZW50LnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIHRoaXMuX3htbERvY3VtZW50Lm5vZGVWYWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgY2hpbGRyZW4gb2YgdGhpcyB4bWwgZG9jdW1lbnRcbiAqIEByZXR1cm5zIEFycmF5IG9mIGdhbWVqcy54bWwuRG9jdW1lbnRcbiAqL1xuRG9jdW1lbnQucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMuX3htbERvY3VtZW50LmNoaWxkTm9kZXMsIFswXSkubWFwKGZ1bmN0aW9uKGNOb2RlKSB7XG4gICAgICByZXR1cm4gbmV3IERvY3VtZW50KGNOb2RlKTtcbiAgIH0pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyBnYW1lanMueG1sLkRvY3VtZW50XG4gKi9cbkRvY3VtZW50LmZyb21TdHJpbmcgPSBmdW5jdGlvbih4bWxTdHJpbmcpIHtcbiAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICB2YXIgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcsICd0ZXh0L3htbCcpO1xuICAgcmV0dXJuIG5ldyBEb2N1bWVudCh4bWxEb2MpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyBnYW1lanMueG1sLkRvY3VtZW50XG4gKi9cbkRvY3VtZW50LmZyb21VUkwgPSBmdW5jdGlvbih1cmwpIHtcbiAgIHZhciByZXNwb25zZSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgcmVzcG9uc2Uub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICByZXNwb25zZS5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gICByZXNwb25zZS5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC94bWwnKTtcbiAgIHJlc3BvbnNlLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQveG1sJyk7XG4gICByZXNwb25zZS5zZW5kKCk7XG4gICByZXR1cm4gbmV3IERvY3VtZW50KHJlc3BvbnNlLnJlc3BvbnNlWE1MKTtcbn07XG4iXX0=
